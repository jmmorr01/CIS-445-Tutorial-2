MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "October 25, 2018" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "23:41:34" );
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Log";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
*------------------------------------------------------------*
* Training Log
Date:                October 25, 2018
Time:                23:41:34
*------------------------------------------------------------*
MPRINT(EM_DIAGRAM):    filename O2A1EN2O "J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   proc printto print=O2A1EN2O new;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOG "J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\EMLOG.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "October 25, 2018" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "23:41:34" );
MPRINT(EM_DIAGRAM):   file _LOG;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                jmmorr01";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "Site:                70080761";
MPRINT(EM_DIAGRAM):   put "Platform:            X64_8PRO";
MPRINT(EM_DIAGRAM):   put "Maintenance Release: 9.04.01M3P062415";
MPRINT(EM_DIAGRAM):   put "EM Version:          14.1";
MPRINT(EM_DIAGRAM):   put "* ";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\EMTRAIN.log" encoding="UTF-8" NOBOM;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _LOG MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_LOGIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   filename _LOGIN "J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\EMSCORE.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   file _LOG mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _LOGIN "J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\EMREPORT.log" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _LOGIN;
MPRINT(EM_DIAGRAM):    filename _LOG;
MPRINT(EM_DIAGRAM):    filename _OUT "J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\EMOUTPUT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   call symput('NLDATE', strip(put(date(), NLDATE.)));
MPRINT(EM_DIAGRAM):   call symput('NLTIME', strip(put(datetime(), NLTIME.)));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   nldate= sasmsg("sashelp.dmine", "log_date_note", 'N', "October 25, 2018" );
MPRINT(EM_DIAGRAM):   nltime= sasmsg("sashelp.dmine", "log_time_note", 'N', "23:41:34" );
MPRINT(EM_DIAGRAM):   file _OUT;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "User:                jmmorr01";
MPRINT(EM_DIAGRAM):   put nldate;
MPRINT(EM_DIAGRAM):   put nltime;
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Training Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\EMTRAIN.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):   ;
MPRINT(EM_COPYFILE):   data _null_;
MPRINT(EM_COPYFILE):   length line $20000;
MPRINT(EM_COPYFILE):   file _OUT MOD lrecl=20000;
MPRINT(EM_COPYFILE):   fid=fopen("_OUTIN",'i',20000,'v');
MPRINT(EM_COPYFILE):   if fid > 0 then do;
MPRINT(EM_COPYFILE):   do while(^fread(fid));
MPRINT(EM_COPYFILE):   rlen = frlen(fid);
MPRINT(EM_COPYFILE):   rc= fget(fid,line,20000);
MPRINT(EM_COPYFILE):   start = length(line)-length(left(line))+1;
MPRINT(EM_COPYFILE):   line=strip(line);
MPRINT(EM_COPYFILE):   put @start line;
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   if fid > 0 then rc=fclose(fid);
MPRINT(EM_COPYFILE):   end;
MPRINT(EM_COPYFILE):   run;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Score Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\EMSCORE.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    data _null_;
MPRINT(EM_DIAGRAM):   file _OUT mod;
MPRINT(EM_DIAGRAM):   put _page_;
MPRINT(EM_DIAGRAM):   put // "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   put "* Report Output";
MPRINT(EM_DIAGRAM):   put "*------------------------------------------------------------*";
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):    filename _OUTIN "J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\EMREPORT.out" encoding="UTF-8" NOBOM;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   filename _OUTIN;
MPRINT(EM_DIAGRAM):    filename _OUT;
MPRINT(EM_DIAGRAM):    filename _emtool_ 'J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\EMRUNSTATUS.xml' encoding="UTF-8" NOBOM;
29566      proc freq data=EMWS1.BINNING_VariableSet noprint;
MPRINT(EM_DIAGRAM):    proc freq data=EMWS1.BINNING_VariableSet noprint;
29567      table ROLE*LEVEL/out=WORK.BINNINGMETA;
MPRINT(EM_DIAGRAM):   table ROLE*LEVEL/out=WORK.BINNINGMETA;
29568      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 16 observations read from the data set EMWS1.BINNING_VARIABLESET.
NOTE: The data set WORK.BINNINGMETA has 5 observations and 4 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.07 seconds
      cpu time            0.01 seconds
      

29569      proc print data=WORK.BINNINGMETA label noobs;
MPRINT(EM_DIAGRAM):   proc print data=WORK.BINNINGMETA label noobs;
29570      var ROLE LEVEL COUNT;
MPRINT(EM_DIAGRAM):   var ROLE LEVEL COUNT;
29571      label ROLE = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel, NOQUOTE))" LEVEL = "%sysfunc(sasmsg(sashelp.dmine, meta_level_vlabel, NOQUOTE))" COUNT = "%sysfunc(sasmsg(sashelp.dmine, rpt_count_vlabel, NOQUOTE))";
MPRINT(EM_DIAGRAM):   label ROLE = "Role" LEVEL = "Measurement Level" COUNT = "Frequency Count";
29572      title9 ' ';
MPRINT(EM_DIAGRAM):   title9 ' ';
29573      title10 "%sysfunc(sasmsg(sashelp.dmine, rpt_varSummary_title  , NOQUOTE))";
MPRINT(EM_DIAGRAM):   title10 "Variable Summary";
MPRINT(EM_DIAGRAM):   run;
29574      run;

NOTE: There were 5 observations read from the data set WORK.BINNINGMETA.
NOTE: The PROCEDURE PRINT printed page 4.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

29575      title10;
MPRINT(EM_DIAGRAM):   title10;
29576      %let EMEXCEPTIONSTRING=;
MPRINT(EM_DIAGRAM):     *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * BINNING: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * BINNING: EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * System Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   length string $2000;
MPRINT(EM_DIAGRAM):   string = 'My Project';
MPRINT(EM_DIAGRAM):   call symput('EM_PROJECTNAME', trim(string));
MPRINT(EM_DIAGRAM):   string = 'My First Flow';
MPRINT(EM_DIAGRAM):   call symput('EM_WSNAME', trim(string));
MPRINT(EM_DIAGRAM):   run;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   * Properties Macro Variables ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------* ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Files Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Import Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Export Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Decision Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Statement Macro Variables;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   data _null_;
MPRINT(EM_DIAGRAM):   set EMWS1.Ids_EMINFO;
MPRINT(EM_DIAGRAM):   where key in('HPDMSAMPLE', 'IDSTABLE');
MPRINT(EM_DIAGRAM):   if key = 'HPDMSAMPLE' then call symput('_ForceGrid', '1');
MPRINT(EM_DIAGRAM):   else call symput('_IDS_TABLE', DATA);
MPRINT(EM_DIAGRAM):   run;
MPRINT(HPDM_PERFORMANCE):  ;
PERFORMANCE  DETAILS
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * General Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Target Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Input Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Rejected Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * Misc Variable Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End Create EM Macro Variables and Macros;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
29927      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
29928      * BINNING: Generation of macros and macro variables;
MPRINT(EM_DIAGRAM):   * BINNING: Generation of macros and macro variables;
29929      * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
MPRINT(EM_DIAGRAM):   * To see the code generated, set the EM_DEBUG macro variable to SOURCE or _ALL_;
29930      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;

29931      %let EMEXCEPTIONSTRING=;
29932      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
29933      * TRAIN: BINNING;
MPRINT(EM_DIAGRAM):   * TRAIN: BINNING;
29934      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
29935      %let EM_ACTION = TRAIN;
29936      %let syscc = 0;
29937      %macro main;
29938      
29939        filename temp catalog 'sashelp.emmdfy.binning_macros.source';
29940        %include temp;
29941        filename temp;
29942      
29943        %setProperties;
29944      
29945        %if %upcase(&EM_ACTION) = CREATE %then %do;
29946          filename temp catalog 'sashelp.emmdfy.binning_create.source';
29947          %include temp;
29948          filename temp;
29949      
29950          %create;
29951        %end;
29952      
29953         %else
29954         %if %upcase(&EM_ACTION) = TRAIN %then %do;
29955      
29956             filename temp catalog 'sashelp.emmdfy.binning_train.source';
29957             %include temp;
29958             filename temp;
29959             %train;
29960         %end;
29961      
29962        %else
29963        %if %upcase(&EM_ACTION) = SCORE %then %do;
29964          filename temp catalog 'sashelp.emmdfy.binning_score.source';
29965          %include temp;
29966          filename temp;
29967      
29968          %score;
29969      
29970        %end;
29971      
29972        %else
29973        %if %upcase(&EM_ACTION) = REPORT %then %do;
29974      
29975             filename temp catalog 'sashelp.emmdfy.binning_report.source';
29976             %include temp;
29977             filename temp;
29978      
29979             %report;
29980         %end;
29981      
29982         %doendm:
29983      %mend main;
29984      
29985      %main;
MPRINT(EM_DIAGRAM):    
MPRINT(MAIN):   filename temp catalog 'sashelp.emmdfy.binning_macros.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMMDFY.BINNING_MACROS.SOURCE.
29987     +%macro SetProperties;
29989     +     /* IGN options */
29990     +     %em_checkmacro(name=EM_PROPERTY_APPLYLEVELRULE, value=N, global=Y);
29991     +     %em_checkmacro(name=EM_PROPERTY_BINMETHOD,  value=QUANTILE, global=Y);
29992     +     %em_checkmacro(name=EM_PROPERTY_NUMBINS,    value=4, global=Y);
29994     +     %em_checkmacro(name=EM_PROPERTY_MISSINGASLEVEL, value=Y, global=Y);
29995     +     %em_checkmacro(name=EM_PROPERTY_PRECISION,    value=2, global=Y);
29996     +     %em_checkmacro(name=EM_PROPERTY_CREATEGROUPING, value=N, global=Y);
29997     +     %em_checkmacro(name=EM_PROPERTY_CREATEMETHOD, value=OVERWRITE, global=Y);
29998     +     %em_checkmacro(name=EM_PROPERTY_IMPORTGROUPING, value=N, global=Y);
29999     +     %em_checkmacro(name=EM_PROPERTY_IMPORTDATA, value=, global=Y);
30000     +     %em_checkmacro(name=EM_PROPERTY_FREEZE, value=N, global=Y);
30001     +     %em_checkmacro(name=EM_PROPERTY_VARSELMETHOD, value=GINI, global=Y);
30002     +     %em_checkmacro(name=EM_PROPERTY_GINICUTOFF,   value=20.0, global=Y);
30003     +     %em_checkmacro(name=EM_PROPERTY_GRPMSMNT,     value=ORDINAL, global=Y);
30004     +     %em_checkmacro(name=EM_PROPERTY_MAXVAR,       value=10, global=Y);
30005     +     %em_checkmacro(name=EM_PROPERTY_CLASSGROUPRARE, value=Y, global=Y);
30006     +     %em_checkmacro(name=EM_PROPERTY_GROUPCUTOFF,    value=0.5, global=Y);
30007     +     %em_checkmacro(name=EM_PROPERTY_GROUPMISSING,   value=N, global=Y);
30009     +     %em_checkmacro(name=EM_PROPERTY_INTTARGETMETHOD, value=CUTMEAN, global=Y);
30010     +     %em_checkmacro(name=EM_PROPERTY_USERCUTVALUE, value=0.2, global=Y);
30011     +     %em_checkmacro(name=EM_PROPERTY_RejectIntTarget, value=N, global=Y);
30014     +%mend SetProperties;
30015     +%macro appendfiles(fileref1, fileref2);
30016     +     data _null_;
30017     +       length c $256;
30018     +       fid1=fopen("&fileref1",'A');
30019     +       fid2=fopen("&fileref2",'I');
30020     +       cval = finfo(fid2,'lrecl');
30021     +       put cval= fid1= fid2=;
30022     +       if (fid2 > 0) then
30023     +         do while(fread(fid2)=0);
30024     +           rc = fget(fid2,c,256);
30025     +           _msg_=sysmsg();
30026     +           /* put rc= c= _msg_=; */
30027     +           rc = fput(fid1,strip(c));
30028     +           rc = fwrite(fid1);
30029     +         end;
30030     +         _msg_=sysmsg();
30031     +         put _msg_=;
30032     +       rc = fclose(fid1);
30033     +       rc = fclose(fid2);
30034     +     run;
30035     +%mend appendfiles;
30037     +%macro buildOptScoreCode;
30039     +    %em_register(key=BINCODE, type=FOLDER);
30041     +    filename x catalog 'sashelp.emutil.em_deldir.source';
30042     +    %inc x;
30043     +    filename x;
30044     +    %delDir(folder=%nrbquote(&em_user_bincode));
30046     +    data _null_; length rc $200;
30047     +       rc = dcreate('BINCODE', "&EM_NODEDIR");
30048     +    run;
30050     +    %if ^%sysfunc(exist(class_nosv)) %then %goto doendu;
30052     +    %let dsid = %sysfunc(open(class_nosv));
30053     +    %let nameNum    = %sysfunc(varnum(&dsid, DISPLAY_VAR));
30054     +    %let grpnameNum = %sysfunc(varnum(&dsid, _grp_variable_));
30056     +    %let oldname=;
30057     +    %do %while(^%sysfunc(fetch(&dsid)));
30058     +        %let name    = %sysfunc(getvarc(&dsid, &nameNum));
30059     +        %let grpname = %sysfunc(getvarc(&dsid, &grpnameNum));
30061     +        %if &name ne &oldname %then %do;
30062     +             filename _F1 "&em_user_bincode&em_dsep.&grpname..sas" MOD;
30063     +             data _null_;
30064     +                length string $200 flag endflag 8;
30065     +                retain string flag endflag;
30066     +                set class_nosv end=eof;
30067     +                where DISPLAY_VAR ="&name";
30068     +                by _variable_ _group_;
30069     +                file _F1;
30070     +                index = kindex(_variable_, "BIN_");
30071     +                if index gt 0 then do;
30072     +                   if first._variable_ then do;
30073     +                      put ' ';
30074     +                      put "&EM_CODEBAR;";
30075     +                      string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
30076     +                      put string;
30077     +                      put "&EM_CODEBAR;";
30079     +                      if origLabel ne "" then do;
30080     +                            string = 'LABEL '!!strip(_grp_variable_)!!' = ';
30081     +                            put string;
30082     +                            string = tranwrd(origLabel,"'","''");
30083     +                            string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
30084     +                            put string;
30085     +                      end;
30086     +                      else do;
30087     +                             string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
30088     +                             put string;
30089     +                      end;
30091     +                      put ' ';
30093     +                      string =  "if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
30094     +                      put string;
30095     +                      string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
30096     +                      put string;
30097     +                      put "end;";
30098     +                      string = "else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
30099     +                      put string;
30100     +                   end;
30101     +                   if first._group_ then do;
30102     +                      flag = 0;
30103     +                      endflag = 1;
30104     +                      if ^first._variable_ then do;
30105     +                         put "else";
30106     +                      end;
30107     +                      if LB ne . then do;
30108     +                         string = "if "!!strip(LB)!!" <= "!!strip(DISPLAY_VAR);
30109     +                      end;
30110     +                      else do;
30111     +                         flag = 1;
30112     +                         string = "if";
30113     +                      end;
30114     +                   end;
30115     +                   if last._Group_ then do;
30116     +                      if UB ne . then do;
30117     +                        if flag ne 1 then do;
30118     +                          string = strip(string)!!" AND "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
30119     +                        end;
30120     +                        else do;
30121     +                          string = "if "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
30122     +                        end;
30123     +                      end;
30124     +                      else do;
30125     +                         if flag=1 then do;
30126     +                            string = strip(DISPLAY_VAR) ;
30127     +                            string = strip(string)!!'='!!strip(_split_Value_)!!" then do;";
30128     +                            endflag=0;
30129     +                            string="";
30130     +                         end;
30131     +                         else do;
30132     +                            string = strip(string)!!" then do;";
30133     +                         end;
30134     +                      end;
30135     +                      put string;
30136     +                      string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
30137     +                      put string;
30138     +                      if endflag eq 1 then do;
30139     +                        put "end;";
30140     +                      end;
30141     +                   end;
30142     +                   if last._variable_ then do;
30143     +                     string = "end;";
30144     +                     put string;
30145     +                   end;
30147     +                end;
30148     +                else do;
30149     +                   _split_value_ = tranwrd(_split_value_,"'","''");
30150     +                   if first._group_ then do;
30151     +                      flag=0;
30152     +                      if ^first._variable_ then
30153     +                         put 'else';
30154     +                      else do;
30155     +                         put ' ';
30156     +                         put "&EM_CODEBAR;";
30157     +                         string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
30158     +                         put string;
30159     +                         put "&EM_CODEBAR;";
30161     +                         if origLabel ne "" then do;
30162     +                               string = 'LABEL '!!strip(_grp_variable_)!!' = ';
30163     +                               put string;
30164     +                               string = tranwrd(origLabel,"'","''");
30165     +                               string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
30166     +                               put string;
30167     +                         end;
30168     +                         else do;
30169     +                               string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
30170     +                               put string;
30171     +                         end;
30173     +                         put ' ';
30175     +                         if format ne '' then do;
30176     +                            if first._variable_ then do;
30177     +                               string = "_UFormat = put("!!strip(DISPLAY_VAR)!!","!!strip(format)!!");";
30178     +                               put string;
30179     +                               string = '%dmnormip(_UFormat);';
30180     +                               put string;
30182     +                               string ="if MISSING(_UFORMAT) then do;";
30183     +                               put string;
30184     +                               string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
30185     +                               put string;
30186     +                               put "end;";
30188     +                               string="else if NOT MISSING(_UFORMAT) then do;";
30189     +                               put string;
30191     +                            end;
30192     +                         end;
30193     +                         else do;
30194     +                            if type = 'N' then do;
30195     +                              string ="if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
30196     +                              put string;
30197     +                              string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
30198     +                              put string;
30199     +                              put "end;";
30201     +                              string="else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
30202     +                              put string;
30203     +                            end;
30204     +                            else if type='C' then do;
30205     +                              string = "_UFormat = "||strip(DISPLAY_VAR)||";";
30206     +                              put string;
30207     +                              string = '%dmnormip(_UFormat);';
30208     +                              put string;
30210     +                              string ="if MISSING(_UFORMAT) then do;";
30211     +                              put string;
30212     +                              string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
30213     +                              put string;
30214     +                              put "end;";
30216     +                              string="else if NOT MISSING(_UFORMAT) then do;";
30217     +                              put string;
30218     +                              string = '%dmnormip(_UFormat);';
30219     +                              put string;
30220     +                           end;
30221     +                         end;
30222     +                      end;
30223     +                      if format ne '' OR type='C' then do;
30224     +                        string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
30225     +                      end;
30226     +                      else do;
30227     +                        string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
30228     +                      end;
30229     +                   end;
30230     +                   else do;
30231     +                      if flag ne 1 then do;
30232     +                       if format ne '' OR type='C' then do;
30233     +                         tempstring = strip(string)!!" OR _UFORMAT eq '"!!strip(_split_value_)!!"'";
30234     +                       end;
30235     +                       else do;
30236     +                         tempstring = strip(string)!!" OR "!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
30237     +                       end;
30238     +                         length = length(tempstring);
30240     +                         if length < 195 then do;
30241     +                            string = tempstring;
30242     +                         end;
30243     +                         else do;
30245     +                            string = strip(string);
30246     +                            put string;
30247     +                            string = ") then do;";
30248     +                            put string;
30250     +                            string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
30251     +                            put string;
30252     +                            put "end;";
30254     +                            put 'else';
30255     +                            if format ne '' OR type='C' then do;
30256     +                              string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
30257     +                            end;
30258     +                            else do;
30259     +                              string = "if "!!strip(DISPLAY_VAR)!!" eq ("!!strip(_split_value_);
30260     +                            end;
30261     +                         end;
30262     +                      end;
30263     +                   end;
30265     +                   if last._group_ then do;
30266     +                      string = strip(string);
30267     +                      put string;
30269     +                      string = ") then do;";
30270     +                      put string;
30272     +                      string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
30273     +                      put string;
30274     +                      put "end;";
30275     +                   end;
30277     +                   if last._variable_ then do;
30278     +                     put "else do;";
30280     +                     string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
30281     +                     put string;
30283     +                     put "end;";
30284     +                     put "end;";
30285     +                   end;
30286     +                end;
30287     +             run;
30289     +             %let oldname = &name;
30290     +        %end;
30291     +    %end;
30292     +    %let dsid = %sysfunc(close(&dsid));
30294     +    filename _F1 "&em_user_bincode&em_dsep._ALL_.sas";
30295     +    data _null_;
30296     +       file _F1;
30297     +       put "length _UFormat $200;";
30298     +       put "drop _UFormat;";
30299     +       put "_UFormat='';";
30300     +    run;
30301     +    filename _F1;
30303     +   %em_register(key=EMSCOREVAR, type=DATA);
30304     +   %let scorevarDs = %scan(&em_user_emscorevar, 2, .);
30305     +   proc datasets lib=&em_lib nolist;
30306     +      delete &scorevarDs;
30307     +   run;
30308     +   quit;
30310     +   %let filrf=mydir;
30311     +   %let rc=%sysfunc(filename(filrf,&em_user_bincode));
30312     +   %let did=%sysfunc(dopen(&filrf));
30314     +   %if &did %then %do;  %PUT  did= &did;
30315     +       %let memcount=%sysfunc(dnum(&did));
30316     +       %if &memcount > 0 %then %do;
30317     +           data &em_user_emscorevar;
30318     +              length Name $32 formula $70 file $200;
30319     +              keep NAME Formula file;
30320     +              formula  = '';
30321     +           %if %sysfunc(fileexist(&em_user_bincode&em_dsep._ALL_.sas)) %then %do;
30322     +               name=''; file="BINCODE&em_dsep._ALL_.sas";
30323     +               output;
30324     +           %end;
30325     +           %do i=1 %to &memcount;
30326     +               %let name =%nrbquote(%sysfunc(dread(&did,&i)));
30327     +               %let newvar = %scan(&name, 1, .);
30328     +               %if "&newvar" ne "_ALL_" %then %do;
30329     +                   name = "&newvar"; file="BINCODE&em_dsep&name";
30330     +                   output;
30331     +               %end;
30332     +           %end;
30334     +           run;
30335     +       %end;
30336     +       %let did = %sysfunc(dclose(&did));
30337     +  %end;
30339     +   %doendu:
30340     +%mend buildOptScoreCode;
30343     +%macro buildScoreCode(flowCode, publishCode);
30346     +  filename x "&flowCode";
30348     +  proc sort data=&EM_USER_SPLITVALS; by display_var _split_Value_; run;
30349     +  proc sort data=&EM_USER_BINMAPPINGS; by display_var bin; run;
30350     +  proc sort data=&EM_USER_coarse out=tempcoarse; by display_var _group_; run;
30352     +  data temp;
30353     +    merge &EM_USER_SPLITVALS &EM_USER_BINMAPPINGS(rename=(BIN=_SPLIT_VALUE_ BIN_NAME=_VARIABLE_));
30354     +    by display_var _Split_value_;
30355     +     if upcase(_Split_value_) ne 'MISSING';
30356     +   run;
30358     +   data temp_missing;
30359     +     merge &EM_USER_SPLITVALS(rename=(_GROUP_=MISSGRP)) &EM_USER_BINMAPPINGS(rename=(
30360     +          BIN=_SPLIT_VALUE_ BIN_NAME=_VARIABLE_));
30361     +     by display_var _Split_value_;
30362     +     if upcase(_Split_value_) eq 'MISSING';
30363     +     keep _variable_ display_var missgrp;
30364     +   run;
30366     +   proc sort data=temp_missing; by display_var missgrp; run;
30368     +   data temp_missing;
30369     +     merge temp_missing(in=_a) tempcoarse(rename=(_GROUP_=MISSGRP));
30370     +     by display_var missgrp;
30371     +     if ^_a then delete;
30372     +     keep _variable_ display_var missgrp ;
30373     +   run;
30375     +   data temp;
30376     +     merge temp temp_missing;
30377     +     by display_var;
30378     +     if display_Var eq '' then delete;
30379     +    run;
30381     +    /* pull in wtev values */
30382     +    proc sort data=&EM_USER_varmappings out=tempmappings; by _variable_; run;
30383     +    proc sort data=&EM_IMPORT_DATA_CMETA out=tempcmeta; by NAME; run;
30384     +    proc sort data=temp;  by display_var _group_; run;
30386     +   data temp;
30387     +      merge temp tempcoarse(keep=display_var _group_  role) ;
30388     +      by display_var _group_;
30389     +    run;
30391     +    data temp;
30392     +      merge temp tempmappings(rename=(_variable_ = display_var)) tempcmeta(keep=NAME FORMAT TYPE LABEL rename=(NAME=display_var LABEL=origLabel));
30393     +      by display_var;
30395     +      if _group_ = . then delete;
30396     +      if _variable_ = '' then delete;
30397     +    run;
30399     +    proc sort data=temp out=class;
30400     +       by _variable_ _group_ LB;
30401     +    run;
30403     +    data _null_;
30404     +      file X;
30406     +      put "length _UFormat $200;";
30407     +      put "drop _UFormat;";
30408     +      put "_UFormat='';";
30409     +    run;
30411     +    data class_nosv;
30412     +      set class;
30413     +      if upcase(role)="INPUT";
30414     +    run;
30416     +    data _null_;
30417     +       file X MOD;
30418     +       length string $200 flag endflag 8;
30419     +       retain string flag endflag;
30420     +       set class_nosv end=eof;
30421     +       by _variable_ _group_;
30423     +       index = kindex(_variable_, "BIN_");
30424     +       if index gt 0 then do;
30426     +         if first._variable_ then do;
30427     +            put ' ';
30428     +            put "&EM_CODEBAR;";
30429     +            string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
30430     +            put string;
30431     +            put "&EM_CODEBAR;";
30434     +            if origLabel ne "" then do;
30435     +              string = 'LABEL '!!strip(_grp_variable_)!!' = ';
30436     +              put string;
30437     +              string = tranwrd(origLabel,"'","''");
30438     +              string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
30439     +              put string;
30440     +            end;
30441     +            else do;
30442     +             string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
30443     +             put string;
30444     +            end;
30446     +            put ' ';
30448     +            string =  "if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
30449     +            put string;
30450     +            string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
30451     +            put string;
30452     +            put "end;";
30453     +            string = "else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
30454     +            put string;
30455     +          end;
30456     +           if first._group_ then do;
30457     +              flag = 0;
30458     +              endflag = 1;
30459     +              if ^first._variable_ then do;
30460     +                put "else";
30461     +              end;
30462     +              if LB ne . then do;
30463     +                 string = "if "!!strip(LB)!!" <= "!!strip(DISPLAY_VAR);
30464     +              end;
30465     +              else do;
30466     +                 flag = 1;
30467     +                 string = "if";
30468     +              end;
30470     +           end;
30471     +           if last._Group_ then do;
30472     +              if UB ne . then do;
30473     +                if flag ne 1 then do;
30474     +                  string = strip(string)!!" AND "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
30475     +                end;
30476     +                else do;
30477     +                  string = "if "!!strip(DISPLAY_VAR)!!" < "!!strip(UB)!!" then do;";
30478     +                end;
30479     +              end;
30480     +              else do;
30481     +                 if flag=1 then do;
30482     +                   string = strip(DISPLAY_VAR) ;
30483     +                   string = strip(string)!!'='!!strip(_split_Value_)!!" then do;";
30484     +                   endflag = 0;
30485     +                   string="";
30486     +                 end;
30487     +                 else do;
30488     +                   string = strip(string)!!" then do;";
30489     +                 end;
30490     +              end;
30491     +              put string;
30493     +              string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
30494     +              put string;
30495     +              if endflag eq 1 then do;
30496     +                put "end;";
30497     +              end;
30498     +           end;
30499     +           if last._variable_ then do;
30500     +             string = "end;";
30501     +             put string;
30502     +           end;
30503     +       end;
30504     +       else do;
30505     +           _split_value_ = tranwrd(_split_value_,"'","''");
30506     +           if first._group_ then do;
30507     +              flag=0;
30508     +              if ^first._variable_ then
30509     +                 put 'else';
30510     +              else do;
30511     +                 put ' ';
30512     +                 put "&EM_CODEBAR;";
30513     +                 string= "* Variable: "!!strip(DISPLAY_VAR)!!";";
30514     +                 put string;
30515     +                 put "&EM_CODEBAR;";
30517     +                 if origLabel ne "" then do;
30518     +                   string = 'LABEL '!!strip(_grp_variable_)!!' = ';
30519     +                   put string;
30520     +                   string = tranwrd(origLabel,"'","''");
30521     +                   string = "'Grouped: "!!%nrbquote(strip(substr(string, 1,188)))!!"';";
30522     +                   put string;
30523     +                 end;
30524     +                 else do;
30525     +                   string = 'LABEL '!!strip(_grp_variable_)!!' = "Grouped: '!!%nrbquote(strip(DISPLAY_VAR))!!'";';
30526     +                   put string;
30527     +                 end;
30529     +                 put ' ';
30531     +                if format ne '' then do;
30532     +                  if first._variable_ then do;
30533     +                    string = "_UFormat = put("!!strip(DISPLAY_VAR)!!","!!strip(format)!!");";
30534     +                    put string;
30535     +                    string = '%dmnormip(_UFormat);';
30536     +                    put string;
30538     +                     string ="if MISSING(_UFORMAT) then do;";
30539     +                     put string;
30540     +                     string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
30541     +                     put string;
30542     +                     put "end;";
30544     +                     string="else if NOT MISSING(_UFORMAT) then do;";
30545     +                     put string;
30547     +                  end;
30548     +                end;
30549     +                else do;
30550     +                     if type = 'N' then do;
30551     +                       string ="if MISSING("!!strip(DISPLAY_VAR)!!") then do;";
30552     +                       put string;
30553     +                       string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
30554     +                       put string;
30555     +                       put "end;";
30557     +                       string="else if NOT MISSING("!!strip(DISPLAY_VAR)!!") then do;";
30558     +                       put string;
30560     +                     end;
30561     +                     else if type='C' then do;
30562     +                        string = "_UFormat = "||strip(DISPLAY_VAR)||";";
30563     +                        put string;
30564     +                        string = '%dmnormip(_UFormat);';
30565     +                        put string;
30567     +                        string ="if MISSING(_UFORMAT) then do;";
30568     +                        put string;
30569     +                        string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
30570     +                        put string;
30571     +                        put "end;";
30573     +                        string="else if NOT MISSING(_UFORMAT) then do;";
30574     +                        put string;
30575     +                        string = '%dmnormip(_UFormat);';
30576     +                        put string;
30577     +                    end;
30578     +                end;
30579     +              end;
30580     +              if format ne '' OR type='C' then do;
30581     +                string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
30582     +              end;
30583     +              else do;
30584     +                string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
30585     +              end;
30586     +           end;
30587     +           else do;
30588     +              if flag ne 1 then do;
30589     +                if format ne '' OR type='C' then do;
30590     +                  tempstring = strip(string)!!" OR _UFORMAT eq '"!!strip(_split_value_)!!"'";
30591     +                end;
30592     +                else do;
30593     +                  tempstring = strip(string)!!" OR "!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
30594     +                end;
30595     +                length = klength(tempstring);
30597     +                if length < 195 then do;
30598     +                   string = tempstring;
30599     +                end;
30600     +                else do;
30602     +                   string = strip(string);
30603     +                   put string;
30604     +                   string = ") then do;";
30605     +                   put string;
30607     +                   string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
30608     +                   put string;
30609     +                   put "end;";
30611     +                 /*  string = strip(string)||",'...';"; */
30613     +                   put 'else';
30614     +                   if format ne '' OR type='C' then do;
30615     +                     string = "if (_UFORMAT eq '"!!strip(_split_value_)!!"'";
30616     +                   end;
30617     +                   else do;
30618     +                     string = "if ("!!strip(DISPLAY_VAR)!!" eq "!!strip(_split_value_);
30619     +                   end;
30622     +                end;
30623     +              end;
30624     +           end;
30626     +           if last._group_ then do;
30627     +              string = strip(string);
30628     +              put string;
30629     +              string = ") then do;";
30630     +              put string;
30632     +              string = strip(_grp_variable_)!!" = "!!strip(_GROUP_)!!";";
30633     +              put string;
30634     +              put "end;";
30635     +           end;
30637     +           if last._variable_ then do;
30638     +             put "else do;";
30640     +             string = strip(_grp_variable_)!!" = "!!strip(MISSGRP)!!";";
30641     +             put string;
30643     +             put "end;";
30644     +             put "end;";
30645     +           end;
30646     +         *end;
30647     +       end;
30648     +    run;
30650     +    /* generate PublishCode the same as flowscorecode */
30651     +    filename Y "&publishCode";
30653     +    /* if publishCode already exists, wipe it out first */
30654     +    %if %sysfunc(fexist(Y)) eq 1 %then %do;
30655     +      %let rc = %sysfunc(fdelete(Y));
30656     +    %end;
30658     +    %appendfiles(Y, X);
30660     +    %if %EM_BINARY_TARGET= %then %do;
30661     +      %if %symexist(EM_NUM_INTERVAL_TARGET)=0 %then %do;
30662     +         %em_varMacro(name=EM_INTERVAL_TARGET, metadata=&EM_DATA_variableSet, where=%nrbquote(ROLE="TARGET" and LEVEL="INTERVAL" and (USE="Y" or USE="D")), nummacro=em_num_interval_Target);
30663     +      %end;
30664     +      %let ibn_inttarget=%EM_INTERVAL_TARGET;
30665     +      %let ibn_inttarget_orig = &ibn_inttarget;
30667     +      %if %symexist(IGNBinTarget)=0 %then %do;
30668     +         %global ignbintarget ignfreqvar;
30669     +         filename temp catalog 'sashelp.emutil.em_getvarname.source';
30670     +         %include temp;
30671     +         filename temp;
30672     +         %getVarName(&EM_IMPORT_DATA, BIN_%substr(&ibn_inttarget,1,%sysfunc(min(%length(&ibn_inttarget),28))), IGNBinTarget);
30674     +         %if &EM_PROPERTY_INTTARGETMETHOD = DUPFREQ %then %do;
30675     +            %getVarName(&EM_IMPORT_DATA, _FREQ_, ignfreqvar);
30676     +         %end;
30677     +      %end;
30678     +      %if &EM_PROPERTY_INTTARGETMETHOD = CUTMEAN %then %do;
30679     +         proc sql noprint;
30680     +            %if %EM_FREQ ne %then %do;
30681     +               select sum(&ibn_inttarget * %EM_FREQ) / sum(%EM_FREQ)
30682     +            %end;
30683     +            %else %do;
30684     +               select mean(&ibn_inttarget)
30685     +            %end;
30686     +            into :ignbincut trimmed from &EM_IMPORT_DATA;
30687     +         quit;
30688     +      %end;
30690     +      %let dsid=%sysfunc(open(&EM_IMPORT_DATA,i));
30691     +      %if &dsid %then %do;
30692     +         %let tarlabel=%trim(%sysfunc(varlabel(&dsid,%sysfunc(varnum(&dsid,&ibn_inttarget)))));
30693     +         %let rc=%sysfunc(close(&dsid));
30694     +      %end;
30695     +      %if %length(&tarlabel)=0 %then %let tarlabel = &ibn_inttarget;
30697     +      data _null_;
30698     +         file x mod;
30699     +         put ' ';
30701     +         %if &EM_PROPERTY_INTTARGETMETHOD = CUTMEAN %then %do;
30702     +             put "&EM_CODEBAR;";
30703     +             %let note = Mean Cutoff Binary Transformation for Target;
30704     +             put "* &note;";
30705     +             put "&EM_CODEBAR;";
30706     +         %end;
30707     +         %else %if &EM_PROPERTY_INTTARGETMETHOD = CUTUSER %then %do;
30708     +             put "&EM_CODEBAR;";
30709     +             %let note = User-Specified Cutoff Binary Transformation for Target;
30710     +             put "* &note;";
30711     +             put "&EM_CODEBAR;";
30712     +             %let ignbincut = &EM_PROPERTY_USERCUTVALUE;
30713     +         %end;
30714     +         put "if &ibn_inttarget = . then &IGNBinTarget = .;";
30715     +         put "else do;";
30716     +         put "   if &ibn_inttarget > &ignbincut then &IGNBinTarget=1;";
30717     +         put "   else &IGNBinTarget=0;";
30718     +         put "end;";
30720     +         put "label &IGNBinTarget = 'Binary: %nrbquote(%substr(&tarlabel,1,192))';";
30721     +      run;
30723     +      filename deltaref "&EM_FILE_CDELTA_TRAIN";
30725     +      %if &EM_PROPERTY_RejectIntTarget = Y %then %do;
30727     +         data _null_;
30728     +            file deltaref;
30729     +            put "if name='&ibn_inttarget_orig' then role='REJECTED';";
30730     +            put "if name='&IGNBinTarget' then do;";
30731     +            put "   role='TARGET';";
30732     +            put "   level='BINARY';";
30733     +            put "end;";
30734     +         run;
30736     +      %end;
30737     +      %else %do;
30739     +         data _null_;
30740     +            file deltaref;
30741     +            put "if name='&ibn_inttarget_orig' then role='TARGET';";
30742     +            put "if name='&IGNBinTarget' then do;";
30743     +            put "   role='REJECTED';";
30744     +            put "   level='BINARY';";
30745     +            put "end;";
30746     +         run;
30747     +      %end;
30749     +      filename deltaref;
30751     +   %end;
30753     +    filename X;
30754     +    filename Y;
30756     +    %buildOptScoreCode;
30758     +    proc datasets library=work nolist;
30759     +      delete class class_nosv temp temp_missing tempmappings tempcmeta;
30760     +    run;
30761     +    quit;
30763     +%mend buildScoreCode;
30765     +%macro buildMetaCode(DeltaCodeFile=);
30767     +   /* set variable roles based on New Role column in the Results table */
30768     +   data _null_;
30769     +      file &DeltaCodeFile %if %length(%EM_BINARY_TARGET)=0 %then mod;;
30770     +      %let dsid = %sysfunc(open(&EM_USER_RESULTSTABLE));
30771     +      %if &dsid %then %do;
30772     +        %let obs = %sysfunc(fetch(&dsid));
30773     +        %let vnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
30774     +        %let rnum = %sysfunc(VARNUM(&dsid, _new_role_));
30775     +        %let ornum = %sysfunc(VARNUM(&dsid, _role_));
30777     +        %do %while(&obs=0);
30778     +          %let inputname = %sysfunc(getvarc(&dsid, &vnum));
30779     +          %let role      = %upcase(%sysfunc(getvarc(&dsid, &rnum)));
30780     +          %let oldrole   = %upcase(%sysfunc(getvarc(&dsid, &ornum)));
30782     +          /* retrieve grp and woe names from varmappings dataset */
30783     +          %let choice = _VARIABLE_ = "&inputname";
30784     +          %let cdsid = %sysfunc(open(&EM_USER_VARMAPPINGS(where=(&choice))));
30785     +          %let cobs = %sysfunc(fetchobs(&cdsid, 1));
30786     +          %let grpnum = %sysfunc(VARNUM(&cdsid, _GRP_VARIABLE_));
30787     +          %let grpname = %sysfunc(getvarc(&cdsid, &grpnum));
30788     +          %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
30790     +          put "if name = '&inputname' then role='REJECTED';";
30791     +          %if "&role" ne "DEFAULT" %then %do;
30792     +            put "if name = '&grpname' then role='&role';";
30793     +          %end;
30794     +          %else %do;
30795     +            put "if name = '&grpname' then role='&oldrole';";
30796     +          %end;
30797     +          put "if name = '&grpname' then level='&EM_PROPERTY_GRPMSMNT';";
30799     +          %let obs = %sysfunc(fetch(&dsid));
30800     +        %end;
30801     +      %end;
30802     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
30803     +   run;
30805     +   /* drop all vars in the splitvals dataset that aren't present in the varmappings dataset */
30806     +   data _null_;
30807     +      file &DeltaCodeFile MOD;
30809     +      %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
30810     +      %if &sdsid %then %do;
30811     +        %let sobs = %sysfunc(fetch(&sdsid));
30812     +        %do %while(&sobs=0);
30813     +          %let varnum = %sysfunc(VARNUM(&sdsid, _VARIABLE_));
30814     +          %let checkname = %sysfunc(getvarc(&sdsid, &varnum));
30815     +          %let dispvarnum = %sysfunc(VARNUM(&sdsid, DISPLAY_VAR));
30816     +          %let displayvar = %sysfunc(getvarc(&sdsid, &dispvarnum));
30818     +          %let checkgrp = GRP_&checkname;
30819     +          %let lenname = %length(&checkgrp);
30820     +          %if %eval(&lenname-32) > 0 %then %do;
30821     +            %let checkgrp = %substr(&checkgrp, 1, 32);
30822     +          %end;
30824     +          %let choice = _VARIABLE_ ="&checkname";
30825     +          %let vdsid = %sysfunc(open(&EM_USER_VARMAPPINGS(where=(&choice))));
30827     +          /* if var not found in varmappings, delete variables; */
30828     +          /* this could happen when freeze=Y and vars in the frozen dataset aren't in the incoming training data */
30829     +          %if &vdsid eq 0 %then %do;
30830     +            put 'if name="&displayvar" then delete;';
30831     +            %let dispgrp = GRP_&displayvar;
30832     +            put 'if name="&dispgrp" then delete;';
30833     +          %end;
30835     +          %if &vdsid > 0 %then %let vdsid = %sysfunc(close(&vdsid));
30836     +          %let sobs = %sysfunc(fetch(&sdsid));
30837     +        %end;
30838     +      %end;
30839     +      %if &sdsid > 0 %then %let sdsid= %sysfunc(close(&sdsid));
30840     +   run;
30842     +%mend buildMetaCode;
30844     +%macro EM_GENERATE_RESULTSTABLE(coarse, resultstable, varmappings);
30846     +   proc sort data=&coarse out=sortedcoarse nodupkey;
30847     +     by display_var;
30848     +   run;
30849     +   proc sort data=&varmappings nodupkey;
30850     +     by _variable_;
30851     +   run;
30852     +   %if %sysfunc(exist(&resultstable, data)) %then %do;
30853     +     proc sort data=&resultstable; by display_var; run;
30855     +     /* check that _new_role exists - did not exist in earlier releases */
30856     +     %let rds=%sysfunc(open(&resultstable));
30857     +     %let _newrolenum = %sysfunc(VARNUM(&rds, _new_role_));
30858     +     %let rds=%sysfunc(close(&rds));
30859     +   %end;
30861     +   data &resultstable (Keep = display_var _gini_  _role_ _new_role_ procLevel);
30862     +     merge sortedcoarse(in=_a) &varmappings(rename=(_Variable_ = DISPLAY_VAR))
30863     +     %if %sysfunc(exist(&resultstable, data)) %then %do;
30864     +        &resultstable (keep = display_var %if &_newrolenum %then _new_role_; )
30865     +     %end;
30866     +     ;
30867     +     by display_var;
30868     +     length _role_ _new_role_ $10;
30869     +     label display_var = "%sysfunc(sasmsg(sashelp.dmine, rpt_variable_vlabel , NOQUOTE))"
30870     +           _gini_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_ginistatistic_vlabel , NOQUOTE))"
30871     +           _role_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_calcrole_vlabel, NOQUOTE))"
30872     +           _new_role_ = "%sysfunc(sasmsg(sashelp.dmine, meta_NEWROLE_vlabel, NOQUOTE))"
30873     +           LEVEL      = "%sysfunc(sasmsg(sashelp.dmine, rpt_level_vlabel , NOQUOTE))"
30874     +           ;
30876     +           %if &EM_PROPERTY_VARSELMETHOD eq GINI %then %do;
30877     +             if _gini_ < &EM_PROPERTY_GINICUTOFF then
30878     +                _role_ = "Rejected";
30879     +             else _role_ = "Input";
30880     +           %end;
30881     +           %else %do;
30882     +             _role_ = "Input";
30883     +           %end;
30884     +           if _new_role_ eq "" then _new_role_="Default";
30885     +      if ^_a then do;
30886     +        _gini_ = 0;
30887     +        _role_ = 'Rejected';
30888     +        if _new_role_ eq "" then _new_role_="Default";
30889     +      end;
30890     +   run;
30891     +   proc sort data=&EM_DATA_VARIABLESET out=outlabel(keep=NAME LABEL LEVEL rename=(NAME=display_var LABEL=_label_));
30892     +     by NAME;
30893     +   run;
30894     +   data outlabel;
30895     +     set outlabel;
30896     +     if _label_ = '' then _label_ = _variable_;
30897     +   run;
30898     +   data &resultstable;
30899     +     merge &resultstable(in=_a_) outlabel;
30900     +     by display_Var;
30901     +     if _a_ then output;
30902     +   run;
30903     +   proc datasets library=work nolist;
30904     +     delete sortedcoarse outlabel;
30905     +   run;
30906     +   quit;
30907     +   proc sort data=&resultstable nodupkey;
30908     +      by DESCENDING
30909     +        _gini_ display_Var;
30910     +   run;
30911     +   data &resultstable;
30912     +     set &resultstable;
30914     +     label giniOrder = "%sysfunc(sasmsg(sashelp.dmine, rpt_giniorder_vlabel , NOQUOTE))"
30915     +           LEVEL      = "%sysfunc(sasmsg(sashelp.dmine, rpt_level_vlabel , NOQUOTE))";
30916     +     giniOrder = _N_;
30917     +     _gini_ = round(_GINI_, .001);
30918     +     drop _variable_;
30919     +   run;
30921     +   proc print data=&resultstable label;
30922     +   run;
30924     +   /* merge role, infovalOrder or giniOrder back into Coarse table as well */
30925     +   data &coarse;
30926     +     set &coarse;
30927     +     length role $10;
30928     +     %let dsid = %sysfunc(open(&resultstable));
30929     +     %if &dsid %then %do;
30930     +       %let disnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
30931     +       %let rolenum = %sysfunc(VARNUM(&dsid, _ROLE_));
30932     +       %let orderNum = %sysfunc(VARNUM(&dsid, giniOrder));
30934     +       %let obs = %sysfunc(fetch(&dsid));
30935     +       %do %while(&obs=0);
30936     +          %let displayvar = %sysfunc(getvarc(&dsid, &disnum));
30937     +          %let role       = %sysfunc(getvarc(&dsid, &rolenum));
30938     +          %let order = %sysfunc(getvarn(&dsid, &ordernum));
30940     +                                                                                               if DISPLAY_VAR = "&displayVar" then do;
30941     +            label giniOrder = "%sysfunc(sasmsg(sashelp.dmine, rpt_giniorder_vlabel , NOQUOTE))";
30942     +            giniOrder = &order;
30943     +            role = "&role";
30944     +          end;
30946     +          %let obs = %sysfunc(fetch(&dsid));
30947     +       %end;
30948     +     %end;
30949     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
30950     +   run;
30953     +%mend EM_GENERATE_RESULTSTABLE;
30955     +%macro EM_GENERATE_EXPORTGROUP(exportGrouping, createMethod);
30957     +    /* instantiate the zchar macro to be used in adding bin definition */
30958     +    filename _temp catalog 'sashelp.emmacs.zchar.source';
30959     +    %inc _temp;
30960     +    filename _temp;
30962     +    proc sort data=&EM_USER_FINEDETAILDATA out=sortedfine;
30963     +      by _variable_ binFlag _group_ LB;
30964     +    run;
30966     +    data tempExport;
30967     +      set sortedFine;
30968     +      by _variable_ binFlag _group_;
30969     +      length _split_value_ $200;
30971     +      /* for all binned variables, need to modify the split value to original cutoff as well as change level to interval */
30972     +      if binFlag = 0 then do;
30973     +        index = kindex(_variable_, "BIN_");
30974     +        if index gt 0 then do;
30975     +          _LEVEL_ = "INTERVAL";
30976     +        end;
30977     +        _Split_value_ = _split_value_;
30978     +        output;
30979     +      end;
30980     +      else do;
30981     +         * if last._group_ then do;
30982     +          index = kindex(_variable_, "BIN_");
30983     +          if index gt 0 then do;
30984     +            _LEVEL_ = "INTERVAL";
30985     +          end;
30986     +          _Split_value_ = %zchar(UB);
30987     +          output;
30988     +         * end;
30989     +      end;
30991     +      rename display_Var = _variable_;
30992     +      keep display_var _level_ _group_ _split_value_ binFlag;
30993     +    run;
30995     +    %if &CREATEMETHOD eq OVERWRITE %then %do;
30996     +       data &EXPORTGROUPING;
30997     +         set tempexport;
30998     +       run;
30999     +    %end;
31000     +    %else %do;
31001     +       /* determine if EXPORTGROUPING already exists */
31002     +       %if %sysfunc(exist(&EXPORTGROUPING, DATA)) %then %do;
31003     +         data &EXPORTGROUPING;
31004     +            set &EXPORTGROUPING tempexport;
31005     +         run;
31006     +       %end;
31007     +       %else %do;
31008     +         data &EXPORTGROUPING;
31009     +            set tempexport;
31010     +         run;
31011     +       %end;
31012     +    %end;
31014     +    proc datasets lib=work nolist;
31015     +      delete sortedFine tempexport;
31016     +    run;
31017     +    quit;
31019     +%mend EM_GENERATE_EXPORTGROUP;
NOTE: %INCLUDE (level 1) ending.
MPRINT(MAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(MAIN):  ;
MPRINT(MAIN):   filename temp catalog 'sashelp.emmdfy.binning_train.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMMDFY.BINNING_TRAIN.SOURCE.
31025     +%macro train;
31027     +   /* include training macros */
31028     +   filename trtemp catalog 'sashelp.emmdfy.binning_trainmacros.source';
31029     +   %include trtemp;
31030     +   filename trtemp;
31032     +   /* trick IGN into thinking it is a model node to build decmeta; further down, set %EM_MODEL ASSESS=N
31033     +   %let EM_TOOLTYPE = MODEL; */
31035     +   %if &EM_IMPORT_DATA eq %then %do;
31036     +       %let  EMEXCEPTIONSTRING = exception.server.IMPORT.NOTRAIN, 1;
31037     +       %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, error_nodeTrainRawData_note , NOQUOTE));
31038     +       %put &em_codebar;
31039     +       %put &errmsg;
31040     +       %put &em_codebar;
31041     +       %goto doendm;
31042     +   %end;
31044     +   %if  &EM_NUM_TARGET ne 1 %then %do;
31045     +        %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1BINORINTTARGET;
31046     +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, METADATA.USE1BINORINTTARGET_ERR  , NOQUOTE));
31047     +        %put &em_codebar;
31048     +        %put &errmsg;
31049     +        %put &em_codebar;
31050     +        %goto doendm;
31051     +   %end;
31053     +  %if  &EM_NUM_BINARY_TARGET ne 1 and &EM_NUM_INTERVAL_TARGET ne 1 %then %do;
31054     +        %let EMEXCEPTIONSTRING = exception.server.METADATA.USE1BINORINTTARGET;
31055     +        %put &em_codebar;
31056     +        %let errormsg = %sysfunc(sasmsg(sashelp.dmine, METADATA.USE1BINORINTTARGET_ERR, NOQUOTE));
31057     +        %put &errormsg;
31058     +        %put &em_codebar;
31059     +        %goto doendm;
31060     +   %end;
31062     +   /* Initialize property macro variables */
31063     +   %SetProperties;
31064     +   %EM_GETNAME(key=NEWTRAIN, type=DATA);
31066     +   /* check actual num of target levels */
31067     +   %let target_level = %EM_TARGET_LEVEL;
31068     +   %let target_var = %EM_TARGET;
31069     +   %if (&target_Level eq BINARY) %then %do;
31070     +      /* retrieve target information */
31071     +      /* does decmeta exist?  If not, retrieve target information elsewhere */
31072     +      %global target_event;
31073     +      %let target_event=;
31075     +     /* need to check that order is the same in both for cases where they can be out of synch */
31076     +     %if "&EM_DEC_DECMETA" ne "" %then %do;
31077     +         /* retrieve target information */
31078     +         %let dsid=%sysfunc(open(&EM_DEC_DECMETA(where=(_TYPE_='TARGET'))));
31080     +         %let vn_event =%sysfunc(varnum(&dsid, EVENT));
31081     +         %let vn_target_type = %sysfunc(varnum(&dsid, TYPE));
31082     +         %let vn_target_format = %sysfunc(varnum(&dsid, FORMAT));
31083     +         %let vn_target_order = %sysfunc(varnum(&dsid, ORDER));
31085     +         %do %while(^ %sysfunc(fetch(&dsid)));
31086     +            %let temp = %nrbquote(%sysfunc(getvarc(&dsid, &vn_event)));
31087     +            %let Target_Event = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
31088     +            %let Target_Type =  %sysfunc(getvarc(&dsid, &vn_target_type));
31089     +            %let Target_Format = %sysfunc(getvarc(&dsid, &vn_target_format));
31090     +            %let Target_Order_DM = %sysfunc(getvarc(&dsid, &vn_target_order));
31091     +         %end;
31092     +         %let dsid = %sysfunc(close(&dsid));
31093     +     %end;
31094     +     %else %let Target_Order_DM=;
31096     +     /* retrieve type and format from variableset */
31097     +     %let eventorder = DESC;
31098     +     data temp;
31099     +       set &EM_DATA_VARIABLESET;
31100     +       where NAME ="%EM_BINARY_TARGET";
31101     +     run;
31103     +     %let dsid = %sysfunc(open(work.temp));
31104     +     %if &dsid %then %do;
31105     +       %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
31106     +       %let formatnum = %sysfunc(VARNUM(&dsid, FORMAT));
31107     +       %let ordernum  = %sysfunc(VARNUM(&dsid, ORDER));
31108     +       %let obs = %sysfunc(fetchobs(&dsid, 1));
31109     +       %let Target_type = %sysfunc(getvarc(&dsid, &typenum));
31110     +       %let Target_Format = %sysfunc(getvarc(&dsid, &formatnum));
31111     +       %let Target_Order  = %sysfunc(getvarc(&dsid, &ordernum));
31112     +     %end;
31113     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31115     +     %if "&EM_DEC_DECMETA" eq "" or ("&Target_Order" ne "&Target_Order_DM") %then %do;
31117     +       %if &TARGET_ORDER  = ASC %then %let eventorder = ASC;
31118     +          %else
31119     +       %if &TARGET_ORDER  = DESC %then %let eventorder = DESC;
31120     +          %else
31121     +       %if &TARGET_ORDER  = FMTASC %then %let eventorder = ASCFMT;
31122     +          %else
31123     +       %if &TARGET_ORDER  = FMTDESC %then %let eventorder = DESFMT;
31125     +        /* retrieve target_event and Target_nonEvent values */
31126     +        proc dmdb data=&EM_IMPORT_DATA(where=(^missing(%EM_BINARY_TARGET))) classout=EVENTOUT;
31127     +          target %EM_BINARY_TARGET;
31128     +          class  %EM_BINARY_TARGET(&eventorder);
31129     +        run;
31131     +        data _null_;
31132     +          dsid = open("EVENTOUT");
31133     +          if dsid>0 then do;
31134     +          levelnum = VARNUM(dsid, "LEVEL");
31135     +          if levelnum then do;
31136     +            if ^fetch(dsid) then
31137     +              call symput('TARGET_EVENT',   strip(getvarc(dsid, levelnum)));
31139     +            if ^fetch(dsid) then
31140     +              call symput('TARGET_NONEVENT',strip(getvarc(dsid, levelnum)));
31141     +          end;
31142     +          dsid=close(dsid);
31143     +          end;
31144     +        run;
31145     +        proc datasets library=work nolist;
31146     +           delete eventout;
31147     +        run;
31148     +        quit;
31149     +      %end;
31150     +      %else %do;
31151     +          %let dsid=%sysfunc(open(&EM_DEC_DECDATA(where=(%EM_BINARY_TARGET ne "&Target_Event"))));
31152     +          %let obs = %sysfunc(fetchobs(&dsid, 1));
31153     +           %let vn_nonevent = %sysfunc(varnum(&dsid, %EM_BINARY_TARGET));
31154     +           %let Target_NonEvent= %sysfunc(getvarc(&dsid, &vn_nonevent));
31155     +         %let dsid = %sysfunc(close(&dsid));
31156     +      %end;
31158     +      %global ignbintarget;
31159     +      %let ignbintarget = %EM_BINARY_TARGET;
31161     +      data &EM_USER_NEWTRAIN;
31162     +        set &EM_IMPORT_DATA;
31163     +      run;
31164     +   %end;
31165     +   %else %do; /* preprocessing for interval target */
31166     +      %if &EM_PROPERTY_INTTARGETMETHOD=CUTUSER %then %do;
31167     +         proc dmdb data=&EM_IMPORT_DATA varout=minmax;
31168     +            var &target_var;
31169     +         run;
31171     +         data _null_;
31172     +            set minmax;
31173     +            call symput('tarmax',strip(max));
31174     +            call symput('tarmin',strip(min));
31175     +         run;
31177     +         /* cutoff can equal tarmin but not tarmax */
31178     +         %if %sysevalf(&EM_PROPERTY_USERCUTVALUE >= &tarmax) or %sysevalf(&EM_PROPERTY_USERCUTVALUE < &tarmin) %then %do;
31179     +            %let EMEXCEPTIONSTRING = exception.server.IGN.CUTOFFOUTOFRANGE,&tarmin,&tarmax;
31180     +            %put &em_codebar;
31181     +            %let errormsg = %sysfunc(sasmsg(sashelp.dmine, cutoffoutofrange_error, NOQUOTE, &tarmin, &tarmax));
31182     +            %put &errormsg;
31183     +            %put &em_codebar;
31184     +            %goto doendm;
31185     +         %end;
31186     +      %end;
31188     +      %global ignbintarget;
31189     +      %getVarName(&EM_IMPORT_DATA, BIN_%substr(%EM_INTERVAL_TARGET,1,%sysfunc(min(%length(%EM_INTERVAL_TARGET),28))), IGNBinTarget);
31191     +      %EM_IBN_IntTargetTrans(%EM_INTERVAL_TARGET,&EM_PROPERTY_INTTARGETMETHOD,newLevels=igntbinlevs);
31192     +      %if &igntbinlevs ne 2 %then %do;
31193     +         %let EMEXCEPTIONSTRING = exception.server.IGN.NONBINTARGETTRANS;
31194     +         %put &em_codebar;
31195     +         %let errormsg = %sysfunc(sasmsg(sashelp.dmine, nonbintargettrans_error, NOQUOTE));
31196     +         %put &errormsg;
31197     +         %put &em_codebar;
31198     +         %goto doendm;
31199     +      %end;
31201     +      %let Target_Event = 1;
31202     +      %let Target_NonEvent = 0;
31203     +      %let Target_Type = BINARY;
31204     +      %let Target_Format = ;
31206     +   %end;
31208     +   /* data sets */
31209     +   %EM_GETNAME(key=BINDATA,        type=DATA);
31210     +   %EM_GETNAME(key=SPLITVALS,      type=DATA);
31211     +   %EM_GETNAME(key=VARMAPPINGS,    type=DATA);
31212     +   %EM_GETNAME(key=BINMAPPINGS,    type=DATA);
31213     +   %EM_GETNAME(key=COARSE,          type=DATA);
31214     +   %EM_GETNAME(key=FINEDETAILDATA, type=DATA);
31215     +   %EM_GETNAME(key=RESULTSTABLE,   type=DATA);
31217     +   /* files */
31218     +   %EM_GETNAME(key=BINNINGCODE, type=FILE, extension=sas);
31219     +   %EM_GETNAME(key=GROUPMAPPINGSCORECODE, type=FILE, extension=sas);
31221     +   /* if freeze eq Y and no finedetaildata exists, throw an exception */
31222     +   %if &EM_PROPERTY_FREEZE eq Y %then %do;
31223     +     %if %sysfunc(exist(&EM_USER_FINEDETAILDATA, DATA)) ne 1 %then %do;
31224     +        %let EMEXCEPTIONSTRING = exception.server.EMTOOL.NOFINEDETAIL;
31225     +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, nofinedetail_error , NOQUOTE));
31227     +        %put &em_codebar;
31228     +        %put &errmsg;
31229     +        %put &em_codebar;
31230     +        %goto doendm;
31231     +     %end;
31232     +   %end;
31234     +   %global useImport;
31235     +   %let useImport = 0;
31237     +   %EM_GETNAME(key=IMPORTSUBSET, type=DATA);
31239     +   %if %sysfunc(exist(&EM_USER_IMPORTSUBSET, DATA)) %then %do;
31240     +     proc datasets library=&EM_LIB nolist;
31241     +       delete &EM_NODEID._IMPORTSUBSET;
31242     +     run;
31243     +     quit;
31244     +   %end;
31246     +   /* if importGrouping=Y, verify that data and all vars exist and are of the correct type */
31247     +   %if &EM_PROPERTY_IMPORTGROUPING eq Y %then %do;
31249     +     /* if import eq Y and no importtable exists, throw an exception */
31250     +     %if %sysfunc(exist(&EM_PROPERTY_IMPORTDATA, DATA)) ne 1 %then %do;
31251     +        %let EMEXCEPTIONSTRING = exception.server.EMTOOL.NOIMPORT;
31252     +        %let  errmsg = %sysfunc(sasmsg(sashelp.dmine, noimport_error , NOQUOTE));
31254     +        %put &em_codebar;
31255     +        %put &errmsg;
31256     +        %put &em_codebar;
31257     +        %goto doendm;
31258     +     %end;
31260     +      %let dsid = %sysfunc(open(&EM_PROPERTY_IMPORTDATA));
31261     +      %if &dsid %then %do;
31262     +         %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
31263     +         %let splitnum = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
31264     +         %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
31265     +         %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
31267     +         %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
31268     +           %let vtype = %sysfunc(VARTYPE(&dsid, &varnuM));
31269     +           %let stype = %sysfunc(VARTYPE(&dsid, &splitnum));
31270     +           %let gtype = %sysfunc(VARTYPE(&dsid, &grpnum));
31271     +           %let ltype = %sysfunc(VARTYPE(&dsid, &lvlnum));
31272     +         %end;
31273     +      %end;
31274     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31276     +      %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
31277     +        %if ((&vtype eq C) AND (&stype eq C) AND (&gtype eq N) AND (&ltype eq C)) %then %do;
31279     +        /* generate subset of data that contains those vars also found in training data and add display_var information */
31280     +        proc sort data=&EM_PROPERTY_IMPORTDATA out=tempimport;
31281     +           by _VARIABLE_ ;
31282     +        run;
31284     +        proc sort data=&EM_DATA_VARIABLESET out=tempvarset(keep=NAME rename=(NAME=_VARIABLE_));
31285     +          by NAME;
31286     +          where ((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y');
31287     +        run;
31289     +        data &EM_USER_IMPORTSUBSET;
31290     +          merge tempimport(in=_a) tempvarset(in=_b);
31291     +          length display_Var $32;
31292     +          by _VARIABLE_;
31293     +          display_var = _Variable_;
31294     +          if _a and _b then output;
31295     +        run;
31297     +        proc datasets library=work nolist;
31298     +          delete tempimport tempvarset;
31299     +        run;
31300     +        quit;
31302     +        %end;
31303     +      %end;
31304     +   %end;
31306     +   /* set useImport flag if there are obs in the importSubset dataset */
31307     +   %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET));
31308     +   %if &dsid %then %do;
31309     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
31310     +     %if &nobs gt 0 %then %let useimport = 1;
31311     +   %end;
31312     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31314     +   %global useFreeze;
31315     +   %let useFreeze = 0;
31317     +   /* if Freeze=Y, verify that data and all vars exist and are of the correct type */
31318     +   %EM_GETNAME(key=FREEZESUBSET, type=DATA);
31320     +   %if %sysfunc(exist(&EM_USER_FREEZESUBSET, DATA)) %then %do;
31321     +     proc datasets library=&EM_LIB nolist;
31322     +       delete &EM_NODEID._FREEZESUBSET;
31323     +     run;
31324     +     quit;
31325     +   %end;
31327     +   %if &EM_PROPERTY_FREEZE eq Y %then %do;
31329     +      /* create freezesubset data to contain information on pre-binned data and raw values */
31330     +      %EM_GENERATE_EXPORTGROUP(&EM_USER_FREEZESUBSET, OVERWRITE);
31332     +      %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET));
31333     +      %if &dsid %then %do;
31334     +         %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
31335     +         %let splitnum = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
31336     +         %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
31337     +         %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
31339     +         %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
31340     +           %let vtype = %sysfunc(VARTYPE(&dsid, &varnuM));
31341     +           %let stype = %sysfunc(VARTYPE(&dsid, &splitnum));
31342     +           %let gtype = %sysfunc(VARTYPE(&dsid, &grpnum));
31343     +           %let ltype = %sysfunc(VARTYPE(&dsid, &lvlnum));
31344     +         %end;
31345     +      %end;
31346     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31348     +      %if (&varnum AND &splitnum AND &grpnum AND &lvlnum) %then %do;
31349     +        %if ((&vtype eq C) AND (&stype eq C) AND (&gtype eq N) AND (&ltype eq C)) %then %do;
31351     +        /* generate subset of data that contains those vars also found in training data */
31352     +        proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze;
31353     +           by _VARIABLE_ ;
31354     +        run;
31356     +        proc sort data=&EM_DATA_VARIABLESET out=tempvarset(keep=NAME rename=(NAME=_VARIABLE_));
31357     +          by NAME;
31358     +          where ((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y');
31359     +        run;
31361     +        data &EM_USER_FREEZESUBSET;
31362     +          merge tempfreeze(in=_a) tempvarset(in=_b);
31363     +          length display_Var $32;
31364     +          by _VARIABLE_;
31365     +          display_var = _Variable_;
31366     +          if _a and _b then output;
31367     +        run;
31369     +        proc datasets library=work nolist;
31370     +          delete tempfreeze tempvarset;
31371     +        run;
31372     +        quit;
31373     +        %end;
31374     +      %end;
31375     +   %end;
31377     +   /* set useFreeze flag if there are obs in the freezeSubset dataset */
31378     +   %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET));
31379     +   %if &dsid %then %do;
31380     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
31381     +     %if &nobs gt 0 %then %let useFreeze = 1;
31382     +   %end;
31383     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31385     +   /* if finedetail already exists, delete prior to re-run */
31386     +   %if %sysfunc(exist(&EM_USER_FINEDETAILDATA, DATA)) %then %do;
31387     +     proc datasets library=&EM_LIB nolist;
31388     +       delete &EM_NODEID._FINEDETAILDATA;
31389     +     run;
31390     +     quit;
31391     +   %end;
31393     +   data tempvarnames;
31394     +     set &EM_DATA_VARIABLESET;
31395     +     where ((ROLE='INPUT' and USE in('Y', 'D')) or (ROLE='REJECTED' and USE='Y')) and level ne 'UNARY';
31396     +     keep NAME LEVEL LABEL;
31397     +   run;
31399     +   proc dmdb data=tempvarnames outtable=tempmapping nameserver;
31400     +     names NAME;
31401     +     prefix WOE_ GRP_ ;
31402     +   run;
31404     +   proc sort data=tempmapping; by name; run;
31405     +   proc sort data=tempvarnames; by name; run;
31406     +   data tempmapping;
31407     +     merge tempmapping tempvarnames;
31408     +     by NAME;
31409     +     rename LEVEL=procLevel;
31410     +   run;
31412     +   /* generate initial columns of mapping table by setting grpflag=0 */
31413     +   %EM_GENERATE_MAPPING_TABLE;
31415     +   proc datasets library=work nolist;
31416     +     delete tempImport tempScore;
31417     +   run;
31418     +   quit;
31420     +   /* delete splitvals dataset if this existed prior to run */
31421     +   %let nvars=0;
31422     +   %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
31423     +   %if &sdsid > 0 %then %do;
31424     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
31425     +   %end;
31426     +   %if &sdsid > 0 %then  %let sdsid=%sysfunc(close(&sdsid));
31428     +   %if &nvars > 0 %then %do;
31429     +      proc datasets library=&EM_LIB nolist;
31430     +        delete &EM_NODEID._SPLITVALS;
31431     +      run;
31432     +      quit;
31433     +   %end;
31435     +   %global classvars qclassvars;
31436     +   %let classvars=;
31437     +   %let qclassvars=;
31439     +   /* generate the intervalvars and classvars macros */
31440     +   %EM_PRE_BINNING(&EM_USER_NEWTRAIN);
31442     +   /* update varmappings with any changes to procLevel based on discretemid */
31443     +   data &EM_USER_VARMAPPINGS;
31444     +     set &EM_USER_VARMAPPINGS;
31445     +     /* procLevel column to indicate the level used by proc; this handles*/
31446     +     /* cases in which var is marked INTERVAL in metadat but treated as  */
31447     +     /* ordinal in prebinning because of # unique levels                 */
31448     +     %let dsid = %sysfunc(open(work._discretemid));
31449     +     %if &dsid %then %do;
31450     +       %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
31451     +       %let obs = %sysfunc(fetch(&dsid));
31452     +       %do %while(&obs=0);
31453     +          %let varname = %sysfunc(getvarc(&dsid, &varnum));
31454     +          if _variable_ = "&varname" then procLevel = "ORDINAL";
31455     +          %let obs = %sysfunc(fetch(&dsid));
31456     +       %end;
31457     +     %end;
31458     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31459     +     label procLevel =  "%sysfunc(sasmsg(sashelp.dmine, rpt_proclevel_vlabel , NOQUOTE))";
31460     +   run;
31462     +   /* generate Grp_xxx variables for interval inputs */
31463     +   %if &EM_PROPERTY_BINMETHOD eq QUANTILE %then %do;
31464     +     %EM_QUANTILE_BINNING(&EM_USER_NEWTRAIN, WORK.PCTILE, &EM_USER_BINDATA, &EM_USER_BINNINGCODE);
31466     +   %end;
31467     +   %else %do;
31468     +     %EM_EQUAL_SPACED_BINNING(&EM_USER_NEWTRAIN, &EM_USER_BINDATA, &EM_USER_BINNINGCODE);
31469     +   %end;
31471     +   /* generate GRP_XXX variables for nominal inputs */
31472     +   %EM_CLASSVARS_GROUP(&EM_PROPERTY_CLASSGROUPRARE);
31474     +   /* generate GRP_XXX variables for ordinal inputs */
31475     +   %EM_ORDVARS_GROUP;
31477     +   proc print data=&EM_USER_VARMAPPINGS label;
31478     +     var _VARIABLE_ _GRP_VARIABLE_ ;
31479     +   run;
31481     +   /* add _proc_var_ to varmappings data to know names of processed variables; could be original input, could be bin_xxx */
31482     +   proc sort data=&EM_USER_SPLITVALS out=tempsplitvals nodupkey;
31483     +     by _VARIABLE_;
31484     +   run;
31486     +   data &EM_USER_VARMAPPINGS;
31487     +     set &EM_USER_VARMAPPINGS;
31488     +     length _proc_var_ $32;
31489     +     %let dsid = %sysfunc(open(work.tempsplitvals));
31490     +     %if &dsid %then %do;
31491     +        %let obs = %sysfunc(fetch(&dsid));
31492     +        %do %while(&obs=0);
31493     +          %let dispnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
31494     +          %let dispvar = %sysfunc(getvarc(&dsid, &dispnum));
31495     +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
31496     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
31498     +          if upcase(_VARIABLE_) = %upcase("&dispvar") then _proc_var_ = "&var";
31499     +          %let obs = %sysfunc(fetch(&dsid));
31500     +        %end;
31501     +     %end;
31502     +     if missing(_proc_var_) then _proc_var_=_variable_;
31503     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31504     +   run;
31506     +   proc datasets library=work nolist;
31507     +     delete sortedbin tempsplitvals;
31508     +   run;
31509     +   quit;
31511     +   /* calculate Fine Detail statistics for each input */
31512     +   %EM_FINE_DETAIL(&EM_USER_BINDATA, &EM_USER_VARMAPPINGS, &EM_USER_FINEDETAILDATA, &EM_USER_SPLITVALS, &EM_USER_BINMAPPINGS);
31514     +   /* apply grouping and create grouped dataset */
31515     +   %EM_CREATE_GROUPING(&EM_USER_BINDATA, &EM_USER_FINEDETAILDATA, &EM_USER_COARSE);
31517     +   /* generate _label_ values in the COARSE dataset from the Scored data */
31518     +   filename Y "&EM_USER_GROUPMAPPINGSCORECODE";
31519     +   %EM_GENERATE_LABELVALUES(Y, &EM_USER_SPLITVALS, &EM_USER_BINMAPPINGS, &EM_USER_COARSE);
31520     +   filename Y;
31522     +   /* set EM_MODEL ASSESS=N to prevent assessment reports from being generated */
31523     +   %EM_MODEL(Target= &ignbintarget, ASSESS=N);
31525     +   /* generate reports */
31526     +   %EM_REPORT(key=COARSE, viewtype=DATA, block=MODEL, description=EVENTRATESTAT, autodisplay=N, spk=N);
31529     +   %doendm:
31530     +%mend train;
NOTE: %INCLUDE (level 1) ending.
MPRINT(MAIN):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(TRAIN):   filename trtemp catalog 'sashelp.emmdfy.binning_trainmacros.source';
NOTE: %INCLUDE (level 1) file TRTEMP is file SASHELP.EMMDFY.BINNING_TRAINMACROS.SOURCE.
31532     +%macro EM_GENERATE_MAPPING_TABLE;
31534     +  %EM_GETNAME(key=VARMAPPINGS, type=DATA);
31535     +  data &EM_USER_VARMAPPINGS(keep=_variable_  _grp_variable_ procLevel label);
31536     +   length _variable_  _grp_variable_  $32 procLevel $8;
31537     +   set tempmapping;
31538     +   label _variable_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_inputvar_vlabel , NOQUOTE))"
31539     +         _grp_variable_ = "%sysfunc(sasmsg(sashelp.dmine, rpt_grpvar_vlabel , NOQUOTE))";
31541     +         _variable_ = NAME;
31542     +         _grp_variable_ = GRP;
31543     + run;
31545     +%mend EM_GENERATE_MAPPING_TABLE;
31547     +%macro EM_PRE_BINNING(input);
31548     +    /* Determine which of our variables are interval  */
31550     +    data tempvariableset;
31551     +      set &EM_DATA_VARIABLESET;
31552     +      where LEVEL = 'INTERVAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
31553     +    run;
31555     +    /* add all interval vars to the intervalvar macro
31556     +    %let dsid = %sysfunc(open(work.tempvariableset));
31557     +    %if &dsid %then %do;
31558     +       %let varnum = %sysfunc(VARNUM(&dsid, NAME));
31559     +       %let obs = %sysfunc(fetch(&dsid));
31560     +       %do %while(&obs=0);
31561     +          %let varname = %sysfunc(getvarc(&dsid, &varnum));
31562     +          %let intervalvars = &intervalvars &varname;
31563     +          %let obs = %sysfunc(fetch(&dsid));
31564     +       %end;
31565     +    %end;
31566     +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31567     + */
31569     +   %em_varmacro(name=intervalvars, metadata=tempvariableset, key=NAME, nummacro=num_intvars);
31571     +    /* Determine which variables marked as interval are true interval distributions; */
31572     +    /* intmid contains variables that are actually interval and should be binned; */
31573     +    /* discretemid contains variables that are actually discrete and should NOT be binned */
31574     +    %if %intervalvars ne %then %do;
31575     +      %let _maxlevel = %eval(&EM_PROPERTY_NUMBINS + 1);
31576     +      proc dmdb data=&input classout=_CLASSOUT maxlevel=&_maxlevel;
31577     +        class %intervalvars;
31578     +      run;
31579     +      proc freq data=_CLASSOUT order=DATA noprint;
31580     +         table NAME / OUT= _COUNT(where=(COUNT<&_maxlevel));
31581     +      run;
31583     +      %let _INTBINS=;
31584     +      data _null_;
31585     +        set _COUNT;
31586     +        call symput('_INTBINS',symget('_INTBINS') !! ' ' !! ktrim(kleft(NAME)));
31587     +      run;
31589     +      proc sort data=_CLASSOUT;
31590     +        by NAME;
31591     +      run;
31592     +      proc transpose data=_CLASSOUT out=_OUT(DROP=_NAME_ RENAME=(NAME=VARIABLE)) prefix=_MIDPOINT;
31593     +        var NRAW;
31594     +        by NAME;
31595     +      run;
31597     +      data _null_;
31598     +        dsid = open('_OUT');
31599     +        if dsid then do;
31600     +           call symput('NUMCLASSBARS', kleft(ktrim(put(attrn(dsid, 'NVARS')-1, best12.))));
31601     +           csid = close(dsid);
31602     +        end;
31603     +      run;
31604     +      data _INTMID;
31605     +        set _OUT;
31606     +        keep VARIABLE _MIDPOINT1--_MIDPOINT&numclassbars;
31607     +        %if "&EM_PROPERTY_APPLYLEVELRULE" ne "N" %then %do;
31608     +          if ^indexw("&_INTBINS", VARIABLE) then output;
31609     +        %end;
31610     +      run;
31612     +      %if "&EM_PROPERTY_APPLYLEVELRULE" ne "N" %then %do;
31613     +        data _DISCRETEMID;
31614     +          set _OUT;
31615     +          keep VARIABLE _MIDPOINT1--_MIDPOINT&numclassbars;
31616     +          if indexw("&_INTBINS", VARIABLE) then output;
31617     +        run;
31618     +      %end;
31619     +      %else %do;
31620     +         %if %sysfunc(exist(_discretemid)) %then %do;
31621     +            proc delete data=_discretemid;
31622     +            run;
31623     +         %end;
31624     +      %end;
31626     +      /* add vars from the _DISCRETEMID dataset to the classvars macro
31627     +      %let dsid = %sysfunc(open(WORK._DISCRETEMID));
31628     +      %if &dsid %then %do;
31629     +        %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
31630     +        %let obs = %sysfunc(fetch(&dsid));
31632     +        %do %while(&obs=0);
31633     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
31634     +          %let classvars = &classvars &var;
31635     +          %let qclassvars = &qclassvars "&var";
31636     +          %let obs = %sysfunc(fetch(&dsid));
31637     +        %end;
31638     +      %end;
31639     +      %if &dsid  %then %let dsid = %sysfunc(close(&dsid));
31640     +*/
31641     +    %end;
31642     +    %else %do;
31643     +      %if %sysfunc(exist(_intmid)) %then %do;
31644     +         proc delete data=_intmid;
31645     +         run;
31646     +      %end;
31648     +      %if %sysfunc(exist(_discretemid)) %then %do;
31649     +         proc delete data=_discretemid;
31650     +         run;
31651     +      %end;
31652     +    %end;
31654     +    /* if import grouping then remove interval vars in import data from _INTMID */
31655     +    %if &useImport eq 1 %then %do;
31657     +      proc sort data=&EM_USER_IMPORTSUBSET out=tempsubset nodupkey;
31658     +        by _VARIABLE_;
31659     +      run;
31661     +      data &EM_USER_IMPORTSUBSET;
31662     +        length CODEVAR $32;
31663     +        set &EM_USER_IMPORTSUBSET;
31664     +        if CODEVAR eq '' then CODEVAR=_VARIABLE_;
31665     +      run;
31667     +      proc sort data=&EM_USER_IMPORTSUBSET out=tempsubset nodupkey;
31668     +        by _VARIABLE_;
31669     +      run;
31671     +      %let dsid = %sysfunc(open(work.tempsubset));
31672     +      %let nobs = 0;
31673     +      %if &dsid %then %do;
31674     +        %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
31675     +      %end;
31676     +      %if &dsid %then %let dsid=%sysfunc(close(&dsid));
31678     +      data tempsubset;
31679     +        set tempsubset;
31680     +        length  binVar suffix $32;
31681     +        array binnames{&nobs} $32 _temporary_;
31682     +        retain binVar binnames;
31683     +        by _VARIABLE_;
31685     +        binVar = 'BIN_'!!strip(CODEVAR);
31686     +        binVar = ksubstr(binVar, 1, 32);
31687     +        count = 1;
31689     +        do i=1 to _N_;
31690     +           do while(binvar eq binnames(i));
31691     +              suffix = strip(put(count,best.));
31692     +              binvar = ksubstr(binvar, 1, 32-klength(suffix))!!suffix;
31693     +              count + 1;
31694     +           end;
31695     +        end;
31696     +        binnames(_N_)= binvar;
31697     +        output;
31698     +        drop suffix count i;
31699     +     run;
31701     +     data &EM_USER_IMPORTSUBSET;
31702     +       set &EM_USER_IMPORTSUBSET;
31703     +       length binVar $32;
31705     +        %let dsid = %sysfunc(open(work.tempsubset));
31706     +        %if &dsid %then %do;
31707     +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
31708     +          %let binnum = %sysfunc(VARNUM(&dsid, binVar));
31709     +          %let obs = %sysfunc(fetch(&dsid));
31711     +          %do %while(&obs=0);
31712     +            %let var = %sysfunc(getvarc(&dsid, &varnuM));
31713     +            %let binvar = %sysfunc(getvarc(&dsid, &binnum));
31715     +            if _variable_ = "&var" and _level_="INTERVAL" then binVar="&binvar";
31716     +            %let obs = %sysfunc(fetch(&dsid));
31717     +          %end;
31718     +        %end;
31719     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31720     +        /* replace _LEVEL_ to ORDINAL for all binned interval vars; */
31721     +        if binVar ne "" then do;
31722     +          _LEVEL_ = "ORDINAL";
31723     +        end;
31725     +      run;
31727     +      %let idsidexists=0;
31728     +      %let idsid = %sysfunc(open(work._intmid));
31729     +      %if &idsid %then %do;
31730     +        %let idsidexists=1;
31731     +        %let idsid = %sysfunc(close(&idsid));
31732     +      %end;
31734     +      %if &idsidexists = 1 %then %do;
31735     +      data _INTMID;
31736     +        set _INTMID;
31738     +        %let dsid = %sysfunc(open(work.tempsubset));
31739     +        %if &dsid %then %do;
31740     +          %let varnum = %sysfunc(VARNUM(&dsid, CODEVAR));
31741     +          %let obs = %sysfunc(fetch(&dsid));
31743     +          %do %while(&obs=0);
31744     +            %let codevar = %sysfunc(getvarc(&dsid, &varnuM));
31745     +            if variable = "&codevar" then delete;
31746     +            %let obs = %sysfunc(fetch(&dsid));
31747     +          %end;
31748     +        %end;
31749     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31750     +      run;
31751     +      %end;
31753     +      proc datasets library=work nolist;
31754     +        delete tempsubset;
31755     +      run;
31756     +      quit;
31757     +    %end;
31759     +    /* if freeze then remove interval vars in import data from _INTMID */
31760     +    %if &useFreeze eq 1 %then %do;
31762     +      data &EM_USER_FREEZESUBSET;
31763     +        length CODEVAR $32;
31764     +        set &EM_USER_FREEZESUBSET;
31765     +        if CODEVAR eq '' then CODEVAR=_VARIABLE_;
31766     +      run;
31768     +      proc sort data=&EM_USER_FREEZESUBSET out=tempsubset nodupkey;
31769     +        by _VARIABLE_;
31770     +      run;
31772     +      %let dsid = %sysfunc(open(work.tempsubset));
31773     +      %let nobs = 0;
31774     +      %if &dsid %then %do;
31775     +        %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
31776     +      %end;
31777     +      %if &dsid %then %let dsid=%sysfunc(close(&dsid));
31779     +      data tempsubset;
31780     +        set tempsubset;
31781     +        length  binVar suffix $32;
31782     +        array binnames{&nobs} $32 _temporary_;
31783     +        retain binVar binnames;
31784     +        by _VARIABLE_;
31786     +        binVar = 'BIN_'!!strip(CODEVAR);
31787     +        binVar = ksubstr(binVar, 1, 32);
31788     +        count = 1;
31790     +        do i=1 to _N_;
31791     +           do while(binvar eq binnames(i));
31792     +              suffix = strip(put(count,best.));
31793     +              binvar = ksubstr(binvar, 1, 32-klength(suffix))!!suffix;
31794     +              count + 1;
31795     +           end;
31796     +        end;
31797     +        binnames(_N_)= binvar;
31798     +        output;
31799     +        drop suffix count i;
31800     +     run;
31802     +     data &EM_USER_FREEZESUBSET;
31803     +       set &EM_USER_FREEZESUBSET;
31804     +       length binVar $32;
31806     +        %let dsid = %sysfunc(open(work.tempsubset));
31807     +        %if &dsid %then %do;
31808     +          %let varnum = %sysfunc(VARNUM(&dsid, _VARIABLE_));
31809     +          %let binnum = %sysfunc(VARNUM(&dsid, binVar));
31810     +          %let obs = %sysfunc(fetch(&dsid));
31812     +          %do %while(&obs=0);
31813     +            %let var = %sysfunc(getvarc(&dsid, &varnuM));
31814     +            %let binvar = %sysfunc(getvarc(&dsid, &binnum));
31816     +            if _variable_ = "&var" and _level_="INTERVAL" then binVar="&binvar";
31817     +            %let obs = %sysfunc(fetch(&dsid));
31818     +          %end;
31819     +        %end;
31820     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31822     +        /* replace _LEVEL_ to ORDINAL for all binned interval vars; */
31823     +        if binVar ne "" then do;
31824     +          _LEVEL_ = "ORDINAL";
31825     +        end;
31827     +      run;
31829     +      %let idsidexists= 0;
31830     +      %let idsid = %sysfunc(open(work._intmid));
31831     +      %if &idsid %then %do;
31832     +        %let idsidexists=1;
31833     +        %let idsid = %sysfunc(close(&idsid));
31834     +      %end;
31835     +      %if &idsidexists eq 1 %then %do;
31836     +      data _INTMID;
31837     +        set _INTMID;
31839     +        %let dsid = %sysfunc(open(work.tempsubset));
31840     +        %if &dsid %then %do;
31841     +          %let varnum = %sysfunc(VARNUM(&dsid, CODEVAR));
31842     +          %let obs = %sysfunc(fetch(&dsid));
31844     +          %do %while(&obs=0);
31845     +            %let codevar = %sysfunc(getvarc(&dsid, &varnuM));
31846     +            if variable = "&codevar" then delete;
31847     +            %let obs = %sysfunc(fetch(&dsid));
31848     +          %end;
31849     +        %end;
31850     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
31851     +      run;
31852     +      %end;
31854     +      proc datasets library=work nolist;
31855     +        delete tempsubset;
31856     +      run;
31857     +      quit;
31859     +    %end;
31861     +%mend EM_PRE_BINNING;
31863     +%macro EM_IMPORT_BINNING(binningCode);
31866     +   data tempintimport;
31867     +     set &EM_USER_IMPORTSUBSET;
31868     +     if binflag = 1;
31869     +   run;
31871     +   %let idsid = %sysfunc(open(work.tempintimport));
31872     +   %if &idsid %then %do;
31873     +     %let nvars = %sysfunc(ATTRN(&idsid, NVARS));
31874     +     %let nobs = %sysfunc(ATTRN(&idsid, NOBS));
31875     +   %end;
31876     +   %else %do;
31877     +     %let nvars = 0;
31878     +     %let nobs = 0;
31879     +   %end;
31880     +   %if &idsid %then %let idsid=%sysfunc(close(&idsid));
31882     +   proc datasets library=work nolist;
31883     +     delete tempintimport;
31884     +   run;
31885     +   quit;
31887     +   %if ((&nobs gt 0) and (&nvars gt 0))%then %do;
31889     +      filename X "&binningCode";
31890     +      data _null_;
31891     +        FILE X MOD;
31892     +        %let bin_variables=;
31893     +        %let quote_bin_variables = ;
31894     +        %let choice = binflag = 1;
31895     +        %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET(where=(&choice))));
31896     +        %if &dsid %then %do;
31897     +           %let namenum = %sysfunc(VARNUM(&dsid, CODEVAR));
31898     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
31899     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
31900     +           %let note = %sysfunc(sasmsg(sashelp.dmine, generatingbins_note , NOQUOTE));
31902     +           put "&EM_CODEBAR;";
31903     +           put " &note; ";
31904     +           put "&EM_CODEBAR;";
31906     +           /* retrieve value for first obs */
31907     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
31908     +           %let oldname = %sysfunc(getvarc(&dsid, &namenum));
31909     +           %let value   = %sysfunc(getvarc(&dsid,  &valnum));
31911     +           %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
31912     +           %let i = 1;
31913     +           %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
31914     +             %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
31915     +           %end;
31916     +           %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
31917     +           put " ";
31918     +           put "if &oldname eq . then &binvalue = .;";
31920     +           /* cycle through special codes if they exist */
31921     +           %let index2 = %index(&oldname, SV_);
31922     +           %if &index2 gt 0 %then %do;
31923     +             %let choice = CODEVAR ="&oldname";
31924     +             %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
31925     +             %if &cdsid %then %do;
31926     +                %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
31927     +                %let cobs = %sysfunc(fetch(&cdsid));
31928     +                %do %while(&cobs=0);
31929     +                   %let code = %sysfunc(getvarc(&cdsid, &codenum));
31930     +                    put "else if &oldname eq &code then &binvalue = &code;";
31931     +                   %let cobs = %sysfunc(fetch(&cdsid));
31932     +                %end;
31933     +             %end;
31934     +             %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
31935     +           %end;
31936     +           put "else ";
31937     +           %if "&value" eq "." %then %do;
31938     +             put " &binvalue=&i;";
31939     +           %end;
31940     +           %else %do;
31941     +             put "  if &oldname < &value then &binvalue=&i;";
31942     +           %end;
31944     +           %let i= %eval(&i+1);
31946     +           %let obs = %sysfunc(fetch(&dsid));
31947     +           %do %while(&obs=0);
31948     +              %let namevalue = %sysfunc(getvarc(&dsid, &namenum));
31949     +              %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
31950     +              %let value    = %sysfunc(getvarc(&dsid,  &valnum));
31952     +              %if "&oldname" ne "&namevalue" %then %do;
31954     +                /* if variable has been re-coded for special codes, must include these values as well */
31955     +                put;
31956     +                put "if &namevalue eq . then &binvalue = .;";
31958     +                %let i=1;
31959     +                %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
31960     +                  %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
31961     +                %end;
31962     +                %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
31964     +                /* cycle through special codes if they exist */
31965     +                %let index2 = %index(&namevalue, SV_);
31966     +                %if &index2 gt 0 %then %do;
31967     +                  %let choice = CODEVAR ="&namevalue";
31968     +                  %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
31969     +                  %if &cdsid %then %do;
31970     +                     %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
31971     +                     %let cobs = %sysfunc(fetch(&cdsid));
31972     +                     %do %while(&cobs=0);
31973     +                       %let code = %sysfunc(getvarc(&cdsid, &codenum));
31974     +                       put "else if &namevalue eq &code then &binvalue = &code;";
31975     +                       %let cobs = %sysfunc(fetch(&cdsid));
31976     +                     %end;
31977     +                  %end;
31978     +                %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
31979     +                %end;
31980     +                put "else ";
31981     +                %if "&value" ne "." %then %do;
31982     +                  put "  if &namevalue < &value then &binvalue=&i;";
31983     +                %end;
31984     +                %else %do;
31985     +                  put " &binvalue=&i;";
31986     +                %end;
31988     +              %end;
31989     +              %else %do;
31990     +                put "else ";
31991     +                %if "&value" ne "." %then %do;
31992     +                  put "  if &namevalue < &value then &binvalue=&i;";
31993     +                %end;
31994     +                %else %do;
31995     +                  put "  &binvalue=&i;";
31996     +                %end;
31997     +              %end;
31998     +              %let i = %eval(&i + 1);
31999     +              %let obs = %sysfunc(fetch(&dsid));
32000     +              %let oldname = &namevalue;
32001     +              %let oldbinvalue = &binvalue;
32002     +           %end;
32003     +        %end;
32004     +        %if &dsid >0 %then %let dsid = %sysfunc(close(&dsid));
32006     +      run;
32007     +      filename X;
32008     +      /* generate BINMAPPINGS dataset */
32009     +      data TEMPBINMAPPINGS;
32010     +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var grp_name $32;
32012     +        %let choice = binflag = 1;
32013     +        %let dsid = %sysfunc(open(&EM_USER_IMPORTSUBSET(where=(&choice))));
32014     +        %if &dsid %then %do;
32015     +           %let varnum  = %sysfunc(VARNUM(&dsid, _VARIABLE_));
32016     +           %let codenum = %sysfunc(VARNUM(&dsid, CODEVAR));
32017     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
32018     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
32019     +           %let grpnum  = %sysfunc(VARNUM(&dsid, _group_));
32021     +           /* retrieve information from first obs */
32022     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
32023     +           %let oldvar = %sysfunc(getvarc(&dsid, &varnum));
32024     +           %let oldcodevar = %sysfunc(getvarc(&dsid, &codenum));
32025     +           %let oldbinvar  = %sysfunc(getvarc(&dsid, &binnum));
32026     +           %let oldgrpvar = GRP_%sysfunc(ksubstr(&oldbinvar,5));
32027     +           %let oldvalue   = %sysfunc(getvarc(&dsid, &valnum));
32028     +           %let oldgrpvalue = %sysfunc(getvarn(&dsid, &grpnum));
32029     +           %let i = 1;
32031     +           NAME = "&OLDCODEVAR";
32032     +           BIN_NAME = "&OLDBINVAR";
32033     +           GRP_NAME = "&OLDGRPVAR";
32034     +           BIN = "&i";
32035     +           GRP = "&oldgrpvalue";
32036     +           LB = . ;
32037     +           UB = &oldvalue;
32038     +           EM_BIN_LABEL = "&oldvar < &oldvalue" ;
32039     +           DISPLAY_VAR = "&oldvar";
32040     +           output;
32042     +           %let i = 2;
32043     +           %let obs = %sysfunc(fetch(&dsid));
32044     +           %do %while(&obs=0);
32045     +             %let var = %sysfunc(getvarc(&dsid, &varnum));
32046     +             %let codevar = %sysfunc(getvarc(&dsid, &codenum));
32047     +             %let binvar  = %sysfunc(getvarc(&dsid, &binnum));
32048     +             %let grpvar = GRP_%sysfunc(ksubstr(&binvar,5));
32049     +             %let value   = %sysfunc(getvarc(&dsid, &valnum));
32050     +             %let group   = %sysfunc(getvarn(&dsid, &grpnum));
32052     +             %if "&oldvar" ne "&var" %then %do;
32053     +              %let i = 1;
32054     +               %let oldvalue = .;
32055     +             %end;
32057     +             NAME = "&CODEVAR";
32058     +             BIN_NAME = "&BINVAR";
32059     +             GRP_NAME = "&GRPVAR";
32060     +             BIN = "&i";
32061     +             GRP = "&group";
32062     +             LB = &oldvalue ;
32063     +             UB = &value;
32064     +             %if "&oldvalue" ne "." AND "&value" ne "." %then %do;
32065     +               EM_BIN_LABEL = "&oldvalue <= &var < &value" ;
32066     +             %end;
32067     +             %else %do;
32068     +               %if "&oldvalue" eq "." %then %do;
32069     +                 EM_BIN_LABEL = "&var < &value" ;
32070     +               %end;
32071     +               %if "&value" eq "." %then %do;
32072     +                 EM_BIN_LABEL = "&oldvalue <= &var";
32073     +               %end;
32074     +             %end;
32075     +             DISPLAY_VAR = "&var";
32076     +             output;
32078     +             %let oldvar = &var;
32079     +             %let oldcodevar = &codevar;
32080     +             %let oldbinvar = &binvar;
32081     +             %let oldgrpvar = &grpvar;
32082     +             %let oldvalue   = &value;
32083     +             %let oldgrpvalue   = &group;
32084     +             %let i = %eval(&i + 1);
32085     +             %let obs = %sysfunc(fetch(&dsid));
32086     +           %end;
32087     +        %end;
32088     +        %if &dsid %then %let dsid=%sysfunc(close(&dsid));
32089     +      run;
32091     +      data &EM_USER_BINMAPPINGS;
32092     +        set &EM_USER_BINMAPPINGS tempBinMappings;
32093     +        if NAME = "" and BIN_NAME = "" and BIN= "" then delete;
32094     +      run;
32096     +      /* update importsubset with bin values instead of raw values */
32097     +      data &EM_USER_IMPORTSUBSET;
32098     +        set &EM_USER_IMPORTSUBSET;
32100     +        %let dsid = %sysfunc(open(&EM_USER_BINMAPPINGS));
32101     +        %if &dsid %then %do;
32102     +          %let binvarnum = %sysfunc(VARNUM(&dsid, BIN_NAME));
32103     +         %let displaynum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
32104     +          %let binnum    = %sysfunc(VARNUM(&dsid, BIN));
32105     +          %let codenum   = %sysfunc(VARNUM(&dsid, NAME));
32106     +          %let ubnum     = %sysfunc(VARNUM(&dsid, UB));
32107     +          %let lbnum     = %sysfunc(VARNUM(&dsid, LB));
32109     +          %let oldvar = ;
32110     +          %let obs = %sysfunc(fetch(&dsid));
32111     +          %do %while(&obs=0);
32112     +            %let binvar = %sysfunc(getvarc(&dsid, &binvarnum));
32113     +            %let codevar = %sysfunc(getvarc(&dsid, &codenum));
32114     +            %let displayvar = %sysfunc(getvarc(&dsid, &displaynum));
32115     +            %let bin    = %sysfunc(getvarc(&dsid, &binnum));
32116     +            %let ub     = %sysfunc(getvarn(&dsid, &ubnum));
32117     +            %let lb     = %sysfunc(getvarn(&dsid, &lbnum));
32119     +            %if "&oldvar" eq "&displayvar" %then %do;
32120     +              else
32121     +            %end;
32122     +            if BinVar = "&binvar" and _SPLIT_VALUE_ = "&UB" then do;
32123     +               _SPLIT_VALUE_ = "&bin";
32124     +            end;
32125     +            %let oldvar = &displayvar;
32126     +            %let obs = %sysfunc(fetch(&dsid));
32127     +          %end;
32128     +        %end;
32129     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
32130     +      run;
32132     +      proc sort data=&EM_USER_IMPORTSUBSET;
32133     +        by _VARIABLE_ _SPLIT_VALUE_;
32134     +      run;
32136     +      proc datasets library=work nolist;
32137     +        delete tempBinMappings;
32138     +      run;
32139     +      quit;
32140     +  %end;
32141     +%mend EM_IMPORT_BINNING;
32143     +%macro EM_FREEZE_BINNING(binningCode);
32145     +   data tempintfreeze;
32146     +     set &EM_USER_FREEZESUBSET;
32147     +     if binflag = 1;
32148     +   run;
32150     +   %let idsid = %sysfunc(open(work.tempintfreeze));
32151     +   %if &idsid %then %do;
32152     +     %let nvars = %sysfunc(ATTRN(&idsid, NVARS));
32153     +     %let nobs = %sysfunc(ATTRN(&idsid, NOBS));
32154     +   %end;
32155     +   %else %do;
32156     +     %let nvars = 0;
32157     +     %let nobs = 0;
32158     +   %end;
32159     +   %if &idsid %then %let idsid=%sysfunc(close(&idsid));
32161     +   proc datasets library=work nolist;
32162     +     delete tempintimport;
32163     +   run;
32164     +   quit;
32166     +   %if ((&nobs gt 0) and (&nvars gt 0))%then %do;
32168     +      filename X "&binningCode";
32169     +      data _null_;
32170     +        FILE X MOD;
32172     +        %let bin_variables=.;
32173     +        %let quote_bin_variables=.;
32174     +        %let freeze_variables=;
32175     +        %let choice = binflag = 1;
32176     +        %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET(where=(&choice))));
32177     +        %if &dsid %then %do;
32178     +           %let namenum = %sysfunc(VARNUM(&dsid, CODEVAR));
32179     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
32180     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
32181     +           %let vnum    = %sysfunc(VARNUM(&dsid, _variable_));
32183     +           %let note = %sysfunc(sasmsg(sashelp.dmine, generatingfrozenbins_note , NOQUOTE));
32184     +           put "&EM_CODEBAR;";
32185     +           put "&note;";
32186     +           put "&EM_CODEBAR;";
32188     +           /* retrieve value for first obs */
32189     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
32190     +           %let oldname = %sysfunc(getvarc(&dsid, &namenum));
32191     +           %let value   = %sysfunc(getvarc(&dsid,  &valnum));
32192     +           %let variable = %sysfunc(getvarc(&dsid, &vnum));
32194     +           %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
32195     +           %let i = 1;
32196     +           %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
32197     +             %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
32198     +           %end;
32199     +           %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
32200     +           %let FREEZE_VARIABLES = &FREEZE_VARIABLES "&variable";
32202     +           put " ";
32203     +           put "if &oldname eq . then &binvalue = .;";
32205     +           /* cycle through special codes if they exist */
32206     +           %let index2 = %index(&oldname, SV_);
32207     +           %if &index2 gt 0 %then %do;
32208     +             %let choice = CODEVAR ="&oldname";
32209     +             %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
32210     +             %if &cdsid %then %do;
32211     +                %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
32212     +                %let cobs = %sysfunc(fetch(&cdsid));
32213     +                %do %while(&cobs=0);
32214     +                   %let code = %sysfunc(getvarc(&cdsid, &codenum));
32215     +                    put "else if &oldname eq &code then &binvalue = &code;";
32216     +                   %let cobs = %sysfunc(fetch(&cdsid));
32217     +                %end;
32218     +             %end;
32219     +             %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
32220     +           %end;
32221     +           put "else ";
32222     +           %if "&value" eq "." %then %do;
32223     +             put " &binvalue=&i;";
32224     +           %end;
32225     +           %else %do;
32226     +             put "  if &oldname < &value then &binvalue=&i;";
32227     +           %end;
32229     +           %let i= %eval(&i+1);
32231     +           %let obs = %sysfunc(fetch(&dsid));
32232     +           %do %while(&obs=0);
32233     +              %let namevalue = %sysfunc(getvarc(&dsid, &namenum));
32234     +              %let binvalue = %sysfunc(getvarc(&dsid, &binnum));
32235     +              %let value    = %sysfunc(getvarc(&dsid,  &valnum));
32236     +              %let variable = %sysfunc(getvarc(&dsid, &vnum));
32238     +              %if "&oldname" ne "&namevalue" %then %do;
32240     +                /* if variable has been re-coded for special codes, must include these values as well */
32241     +                put;
32242     +                put "if &namevalue eq . then &binvalue = .;";
32244     +                %let i=1;
32245     +                %if %sysfunc(index(%upcase(&BIN_VARIABLES) , %upcase(&binvalue))) eq 0 %then %do;
32246     +                  %let BIN_VARIABLES=&BIN_VARIABLES &binvalue;
32247     +                %end;
32248     +                %let QUOTE_BIN_VARIABLES=&QUOTE_BIN_VARIABLES "&namevalue";
32249     +                %let FREEZE_VARIABLES = &FREEZE_VARIABLES "&variable";
32251     +                /* cycle through special codes if they exist */
32252     +                %let index2 = %index(&namevalue, SV_);
32253     +                %if &index2 gt 0 %then %do;
32254     +                  %let choice = CODEVAR ="&namevalue";
32255     +                  %let cdsid = %sysfunc(open(&EM_USER_CODEMAPPINGS(where=(&choice))));
32256     +                  %if &cdsid %then %do;
32257     +                     %let codenum = %sysfunc(VARNUM(&cdsid, CODE));
32258     +                     %let cobs = %sysfunc(fetch(&cdsid));
32259     +                     %do %while(&cobs=0);
32260     +                       %let code = %sysfunc(getvarc(&cdsid, &codenum));
32261     +                       put "else if &namevalue eq &code then &binvalue = &code;";
32262     +                       %let cobs = %sysfunc(fetch(&cdsid));
32263     +                     %end;
32264     +                  %end;
32265     +                %if &cdsid %then %let cdsid = %sysfunc(close(&cdsid));
32266     +                %end;
32267     +                put "else ";
32268     +                %if "&value" ne "." %then %do;
32269     +                  put "  if &namevalue < &value then &binvalue=&i;";
32270     +                %end;
32271     +                %else %do;
32272     +                  put " &binvalue=&i;";
32273     +                %end;
32275     +              %end;
32276     +              %else %do;
32277     +                put "else ";
32278     +                %if "&value" ne "." %then %do;
32279     +                  put "  if &namevalue < &value then &binvalue=&i;";
32280     +                %end;
32281     +                %else %do;
32282     +                  put " &binvalue=&i;";
32283     +                %end;
32284     +              %end;
32285     +              %let i = %eval(&i + 1);
32286     +              %let obs = %sysfunc(fetch(&dsid));
32287     +              %let oldname = &namevalue;
32288     +              %let oldbinvalue = &binvalue;
32289     +           %end;
32290     +        %end;
32291     +        %if &dsid >0 %then %let dsid = %sysfunc(close(&dsid));
32293     +      run;
32294     +      filename X;
32295     +      /* generate BINMAPPINGS dataset */
32296     +      data TEMPBINMAPPINGS;
32297     +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var grp_name $32;
32299     +        %let choice = binflag = 1;
32300     +        %let dsid = %sysfunc(open(&EM_USER_FREEZESUBSET(where=(&choice))));
32301     +        %if &dsid %then %do;
32302     +           %let varnum  = %sysfunc(VARNUM(&dsid, _VARIABLE_));
32303     +           %let codenum = %sysfunc(VARNUM(&dsid, CODEVAR));
32304     +           %let binnum  = %sysfunc(VARNUM(&dsid, binVar));
32305     +           %let valnum  = %sysfunc(VARNUM(&dsid, _SPLIT_VALUE_));
32306     +           %let grpnum  = %sysfunc(VARNUM(&dsid, _group_));
32308     +           /* retrieve information from first obs */
32309     +           %let obs = %sysfunc(fetchobs(&dsid, 1));
32310     +           %let oldvar = %sysfunc(getvarc(&dsid, &varnum));
32311     +           %let oldcodevar = %sysfunc(getvarc(&dsid, &codenum));
32312     +           %let oldbinvar  = %sysfunc(getvarc(&dsid, &binnum));
32313     +           %let oldgrpvar = GRP_%sysfunc(ksubstr(&oldbinvar, 5));
32314     +           %let oldvalue   = %sysfunc(getvarc(&dsid, &valnum));
32315     +           %let oldgrpvalue = %sysfunc(getvarn(&dsid, &grpnum));
32316     +           %let i = 1;
32318     +           NAME = "&OLDCODEVAR";
32319     +           BIN_NAME = "&OLDBINVAR";
32320     +           GRP_NAME = "&OLDGRPVAR";
32321     +           BIN = "&i";
32322     +           GRP = "&oldgrpvalue";
32323     +           LB = . ;
32324     +           UB = &oldvalue;
32325     +           EM_BIN_LABEL = "&oldvar < &oldvalue" ;
32326     +           DISPLAY_VAR = "&oldvar";
32327     +           output;
32329     +           %let i = 2;
32330     +           %let obs = %sysfunc(fetch(&dsid));
32331     +           %do %while(&obs=0);
32332     +             %let var = %sysfunc(getvarc(&dsid, &varnum));
32333     +             %let codevar = %sysfunc(getvarc(&dsid, &codenum));
32334     +             %let binvar  = %sysfunc(getvarc(&dsid, &binnum));
32335     +             %let grpvar = GRP_%sysfunc(ksubstr(&binvar, 5));
32336     +             %let value   = %sysfunc(getvarc(&dsid, &valnum));
32337     +             %let group   = %sysfunc(getvarn(&dsid, &grpnum));
32339     +             %if "&oldvar" ne "&var" %then %do;
32341     +               %let i = 1;
32342     +               %let oldvalue = .;
32343     +             %end;
32345     +             NAME = "&CODEVAR";
32346     +             BIN_NAME = "&BINVAR";
32347     +             GRP_NAME = "&GRPVAR";
32348     +             BIN = "&i";
32349     +             GRP = "&group";
32350     +             LB = &oldvalue ;
32351     +             UB = &value;
32352     +             %if "&oldvalue" ne "." AND "&value" ne "." %then %do;
32353     +               EM_BIN_LABEL = "&oldvalue <= &var < &value" ;
32354     +             %end;
32355     +             %else %do;
32356     +               %if "&oldvalue" eq "." %then %do;
32357     +                 EM_BIN_LABEL = "&var < &value" ;
32358     +               %end;
32359     +               %if "&value" eq "." %then %do;
32360     +                 EM_BIN_LABEL = "&oldvalue <= &var";
32361     +               %end;
32362     +             %end;
32363     +             DISPLAY_VAR = "&var";
32364     +             output;
32366     +             %let oldvar = &var;
32367     +             %let oldcodevar = &codevar;
32368     +             %let oldbinvar = &binvar;
32369     +             %let oldgrpvar = &grpvar;
32370     +             %let oldvalue   = &value;
32371     +             %let oldgrpvalue = &group;
32372     +             %let i = %eval(&i + 1);
32373     +             %let obs = %sysfunc(fetch(&dsid));
32374     +           %end;
32375     +        %end;
32377     +        %if &dsid %then %let dsid=%sysfunc(close(&dsid));
32378     +      run;
32380     +      /* remove obs from EM_USER_BINMAPPINGS that have vars also in tempBinMappings -- prevents duplicate entries */
32381     +      data &EM_USER_BINMAPPINGS;
32382     +        set &EM_USER_BINMAPPINGS;
32383     +        if NAME in (&FREEZE_VARIABLES) then delete;
32384     +      run;
32386     +      data &EM_USER_BINMAPPINGS;
32387     +        length NAME BIN_NAME $32 BIN GRP $8 LB UB 8 EM_BIN_LABEL $200 display_Var grp_name $32;
32389     +        set &EM_USER_BINMAPPINGS tempBinMappings;
32390     +        if NAME = "" and BIN_NAME = "" and BIN= "" then delete;
32391     +      run;
32393     +      /* update freezesubset with bin values instead of raw values */
32394     +      data &EM_USER_FREEZESUBSET;
32395     +        set &EM_USER_FREEZESUBSET;
32397     +        %let dsid = %sysfunc(open(&EM_USER_BINMAPPINGS));
32398     +        %if &dsid %then %do;
32399     +          %let binvarnum = %sysfunc(VARNUM(&dsid, BIN_NAME));
32400     +         %let displaynum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
32401     +          %let binnum    = %sysfunc(VARNUM(&dsid, BIN));
32402     +          %let codenum   = %sysfunc(VARNUM(&dsid, NAME));
32403     +          %let ubnum     = %sysfunc(VARNUM(&dsid, UB));
32404     +          %let lbnum     = %sysfunc(VARNUM(&dsid, LB));
32406     +          %let oldvar = ;
32407     +          %let obs = %sysfunc(fetch(&dsid));
32408     +          %do %while(&obs=0);
32409     +            %let binvar = %sysfunc(getvarc(&dsid, &binvarnum));
32410     +            %let codevar = %sysfunc(getvarc(&dsid, &codenum));
32411     +            %let displayvar = %sysfunc(getvarc(&dsid, &displaynum));
32412     +            %let bin    = %sysfunc(getvarc(&dsid, &binnum));
32413     +            %let ub     = %sysfunc(getvarn(&dsid, &ubnum));
32414     +            %let lb     = %sysfunc(getvarn(&dsid, &lbnum));
32416     +            %if "&oldvar" eq "&displayvar" %then %do;
32417     +              else
32418     +            %end;
32419     +            if BinVar = "&binvar" and _SPLIT_VALUE_ = "&UB" then do;
32420     +               _SPLIT_VALUE_ = "&bin";
32421     +            end;
32422     +            %let oldvar =&displayvar;
32423     +            %let obs = %sysfunc(fetch(&dsid));
32424     +          %end;
32425     +        %end;
32426     +        %if &dsid %then %let dsid = %sysfunc(close(&dsid));
32427     +      run;
32429     +      proc sort data=&EM_USER_FREEZESUBSET;
32430     +        by _VARIABLE_ _SPLIT_VALUE_;
32431     +      run;
32433     +      proc datasets library=work nolist;
32434     +        delete tempBinMappings;
32435     +      run;
32436     +      quit;
32437     +   %end;
32438     +%mend EM_FREEZE_BINNING;
32440     +%macro EM_EQUAL_SPACED_BINNING(input, bindata, binningCode);
32443     +/* initialize new bucket_binning macro */
32444     +filename temp catalog 'sashelp.emapps.bucket_binning.source';
32445     +%include temp;
32446     +filename temp;
32448     +/* create fileref for generation of binningCode */
32449     +filename X "&binningCode";
32451     +/* determine if there are inputs to be binned */
32452     +%let numbinvars = 0;
32453     +%let intdsid = %sysfunc(open(work._intmid));
32454     +%if &intdsid %then %do;
32455     +  %let numbinvars = %sysfunc(ATTRN(&intdsid, NOBS));
32456     +%end;
32457     +%if &intdsid ne %then %let intdsid = %sysfunc(close(&intdsid));
32458     +%if &numbinvars > 0 %then %do;
32461     +/* get data in format needed for quantile_binning macro */
32462     +data work.vartable;
32463     +  set work._intmid;
32464     +  level = "INTERVAL";
32465     +  role  = "INPUT";
32466     +  rename variable=name;
32467     +run;
32469     +/* if freq var exists, add this to vartable so it will be processed by quantile_binning */
32470     +%if %EM_FREQ ne %then %do;
32471     +   data work.freq;
32472     +     name="%EM_FREQ";
32473     +     role="FREQ";
32474     +   run;
32476     +   data work.vartable;
32477     +     set work.vartable work.freq;
32478     +   run;
32479     +%end;
32481     +/* perform bucket binning of data */
32482     +%let precision =  1 / %sysevalf(10**&EM_PROPERTY_PRECISION);
32483     +%em_apps_bucket_binning( &input, work.vartable, &EM_PROPERTY_NUMBINS, &EM_USER_BINMAPPINGS, X, precision=&precision, dropOriginal=Y);
32485     +proc sort data=&EM_USER_BINMAPPINGS; by name lb; run;
32486     +%end;
32487     +%else %do;
32488     +  /* initialize binmappings table */
32489     +  data &EM_USER_BINMAPPINGS;
32490     +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
32491     +  run;
32493     +  data _null_;
32494     +    FILE X;
32496     +    put "&EM_CODEBAR;";
32497     +    %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
32498     +    put "* &note;";
32499     +    put "&EM_CODEBAR;";
32500     +  run;
32502     +%end;
32504     +/* assign display_var values to binmappings table as well as initial group values */
32505     +data &EM_USER_BINMAPPINGS;
32506     +  set &EM_USER_BINMAPPINGS;
32507     +  length display_var $32 grp $8;
32508     +  display_var = name;
32510     +  %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
32511     +    GRP = BIN + 1;
32512     +  %end;
32513     +  %else %do;
32514     +    GRP = BIN;
32515     +  %end;
32516     +run;
32518     +/* de-assign fileref */
32519     +filename X;
32521     +    /* append to binning code those values that were included in the importSubset data */
32522     +    %if &useImport eq 1 %then %do;
32523     +      %EM_IMPORT_BINNING(&binningcode);
32524     +    %end;
32526     +    /* append to binning code those values that were included in the freezeSubset data */
32527     +    %if &useFreeze eq 1 %then %do;
32528     +      %EM_FREEZE_BINNING(&binningcode);
32529     +    %end;
32531     +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
32532     +     by NAME;
32533     +     run;
32535     +     /* create grouping for missing level */
32536     +    data tempmissvalues;
32537     +    run;
32539     +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
32540     +       data tempmissvalues;
32541     +         %if &useImport eq 1 %then %do;
32542     +           merge sortedmapping &EM_USER_IMPORtSUBSET(in=_a rename=(_variable_=NAME));
32543     +         %end;
32544     +         %if &useFreeze eq 1 %then %do;
32545     +           merge sortedmapping &EM_USER_FreezeSUBSET(in=_b rename=(_variable_=NAME));
32546     +         %end;
32547     +         %else %do;
32548     +           set sortedmapping;
32549     +         %end;
32550     +         GRP="1";
32551     +         bin="Missing";
32552     +         _split_value_ = "Missing";
32553     +         %if &useImport eq 1 %then %do;
32554     +            if _a then delete;
32555     +         %end;
32556     +         %if &useFreeze eq 1 %then %do;
32557     +            if _b then delete;
32558     +         %end;
32560     +       run;
32561     +    %end;
32563     +    /* create binData from binningCode */
32564     +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
32565     +      by NAME;
32566     +    run;
32568     +    filename X "&binningCode";
32569     +    data &bindata;
32570     +      set &input;
32571     +      %inc X;
32572     +    run;
32574     +    filename X;
32576     +    /* create splitvals dataset */
32577     +    data tempsplitvals;
32578     +      set &EM_USER_BINMAPPINGS
32579     +        %let tdsid = %sysfunc(open(work.tempmissvalues));
32580     +        %if &tdsid %then %do;
32581     +          tempmissvalues
32582     +        %end;
32583     +        %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
32584     +      ;
32585     +      length newgroup _group_ 8 _level_ $8;
32586     +      newgroup =.;
32587     +      _LEVEL_ = 'ORDINAL';
32588     +      _Group_ = grp;
32589     +      rename NAME=DISPLAY_VAR BIN=_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
32590     +      keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_;
32591     +    run;
32593     +    data tempsplitvals;
32594     +      set tempsplitvals;
32595     +      _order_ = _N_;
32596     +    run;
32598     +    /* determine if EM_USER_SPLITVALS already exists */
32599     +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
32600     +    %if &sdsid > 0 %then %do;
32601     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
32602     +      %if &nvars > 0 %then %do;
32603     +        proc sql;
32604     +          reset noprint;
32605     +          select count(*) into :nobs from &EM_USER_SPLITVALS;
32606     +        quit;
32607     +      %end;
32608     +      %else %let nobs=0;
32609     +    %end;
32610     +    %else %do;
32611     +       %let nobs=0;
32612     +       %let nvars=0;
32613     +    %end;
32614     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
32616     +    /* if useIMport=1 also include import definitions here as well */
32617     +    %if &useImport eq 1 %then %do;
32618     +      data tempImport;
32619     +        set &EM_USER_IMPORTSUBSET;
32620     +        _variable_ = binVar;
32621     +      run;
32622     +    %end;
32624     +    /* if useFreeze=1 also include import definitions here as well */
32625     +    %if &useFreeze eq 1 %then %do;
32626     +      data tempFreeze;
32627     +        length display_var $32;
32628     +        set &EM_USER_FREEZESUBSET;
32629     +        display_var = _variable_;
32630     +        _variable_ = binVar;
32631     +      run;
32632     +    %end;
32635     +    data &EM_USER_SPLITVALS;
32636     +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
32637     +        set &EM_USER_SPLITVALS tempsplitvals
32638     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
32639     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
32640     +        %end;
32641     +        %if &useFreeze eq 1 %then %do;
32642     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
32643     +        %end;
32644     +        ;
32645     +      %end;
32646     +      %else %do;
32647     +        set tempsplitvals
32648     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
32649     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
32650     +        %end;
32651     +        %if &useFreeze eq 1 %then %do;
32652     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
32653     +        %end;
32654     +        ;
32655     +      %end;
32656     +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _ORDER_;
32657     +    run;
32659     +    /* create temporary mapping dataset of normalized and non-normalized values for char variables*/
32660     +    data tempvariableset;
32661     +      set &EM_DATA_VARIABLESET;
32662     +      where TYPE = 'C';
32663     +    run;
32665     +    /* add all interval vars that aren't special codes to the intervalvar macro
32666     +    %let dsid = %sysfunc(open(work.tempvariableset));
32667     +    %if &dsid %then %do;
32668     +      %let varnum = %sysfunc(VARNUM(&dsid, NAME));
32669     +      %let obs = %sysfunc(fetch(&dsid));
32670     +      %do %while(&obs=0);
32671     +        %let varname = %sysfunc(getvarc(&dsid, &varnum));
32672     +        %let classvars = &classvars &varname;
32673     +        %let qclassvars = &qclassvars "&varname";
32674     +        %let obs = %sysfunc(fetch(&dsid));
32675     +      %end;
32676     +    %end;
32677     +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
32678     +    */
32679     +   %em_varmacro(name=classvars, metadata=tempvariableset, key=NAME, nummacro=num_classvars);
32681     +    %if %classvars ne %then %do;
32682     +      proc dmdb data =&bindata classout=_classout nonorm;
32683     +        class %classvars;
32684     +      run;
32686     +      proc dmdb data=&bindata classout=_classout2;
32687     +       class %classvars;
32688     +      run;
32690     +      proc sort data=_classout; by NAME CRAW; run;
32691     +      proc sort data=_classout2; by NAME CRAW; run;
32693     +      data _classout;
32694     +        length _variable_ $32;
32695     +        merge _classout _classout2 (rename=(LEVEL=_split_value_));
32696     +        _split_value_ = trim(left(_split_value_));
32697     +        LEVEL = trim(left(LEVEL));
32698     +        by NAME CRAW;
32699     +       _variable_ = NAME;
32700     +      run;
32702     +      proc sort data=_classout; by _variable_ _split_value_; run;
32703     +      proc sort data=&EM_USER_SPLITVALS; by _variable_ _split_value_; run;
32705     +      data &EM_USER_SPLITVALS;
32706     +        length _norm_level_ $200 _split_value_ $200;
32707     +        merge &EM_USER_SPLITVALS _classout(rename=(LEVEL=_norm_level_));
32708     +        by _variable_ _split_value_;
32709     +        LEVEL = trim(left(LEVEL));
32710     +        _norm_level_ = trim(left(_norm_level_));
32711     +        _split_value_ = trim(left(_split_value_));
32712     +        if _norm_level_ eq '' then _norm_level_= _split_value_;
32713     +        drop NAME FREQUENCY TYPE CRAW NRAW;
32714     +      run;
32716     +      proc datasets library=work nolist;
32717     +        delete _classout _classout2;
32718     +      run;
32719     +      quit;
32720     +    %end;
32721     +    data &EM_USER_SPLITVALS;
32722     +      set &EM_USER_SPLITVALS;
32723     +      if _norm_level_ eq '' then _norm_level_= _split_value_;
32724     +    run;
32726     +    proc sort data=&EM_USER_SPLITVALS;
32727     +      by DISPLAY_VAR _Group_;
32728     +    run;
32730     +   proc datasets library=work nolist;
32731     +     delete tempBinMappings temp_binmappings tempBinNames tempsplitvals sortedmapping tempmissvalues
32732     +      %if &useImport eq 1 %then %do;
32733     +        tempImport
32734     +      %end;
32735     +      %if &useFreeze eq 1 %then %do;
32736     +        tempFreeze
32737     +      %end;
32738     +     ;
32739     +   run;
32740     +   quit;
32742     +%mend;
32744     +%macro EM_QUANTILE_BINNING(input, pctdata, bindata, binningCode);
32746     +/* initialize new quantile_binning macro */
32747     +filename temp catalog 'sashelp.emapps.quantile_binning.source';
32748     +%include temp;
32749     +filename temp;
32751     +/* generate fileref for quantile_binning macro */
32752     +filename X "&binningCode";
32754     +/* determine if there are inputs to be binned */
32755     +%let numbinvars = 0;
32756     +%let intdsid = %sysfunc(open(work._intmid));
32757     +%if &intdsid %then %do;
32758     +  %let numbinvars = %sysfunc(ATTRN(&intdsid, NOBS));
32759     +%end;
32760     +%if &intdsid ne %then %let intdsid = %sysfunc(close(&intdsid));
32761     +%if &numbinvars > 0 %then %do;
32763     +/* get data in format needed for quantile_binning macro */
32764     +data work.vartable;
32765     +  set work._intmid;
32766     +  level = "INTERVAL";
32767     +  role  = "INPUT";
32768     +  rename variable=name;
32769     +run;
32771     +/* if freq var exists, add this to vartable so it will be processed by quantile_binning */
32772     +%if %EM_FREQ ne %then %do;
32773     +   data work.freq;
32774     +     name="%EM_FREQ";
32775     +     role="FREQ";
32776     +   run;
32778     +   data work.vartable;
32779     +     set work.vartable work.freq;
32780     +   run;
32781     +%end;
32784     +/* perform quantile binning of data */
32785     +%let precision =  1 / %sysevalf(10**&EM_PROPERTY_PRECISION);
32786     +%em_apps_quantile_binning( &input, work.vartable, &EM_PROPERTY_NUMBINS, &EM_USER_BINMAPPINGS, X, precision=&precision, dropOriginal=Y);
32788     +proc sort data=&EM_USER_BINMAPPINGS; by name lb; run;
32789     +%end;
32790     +%else %do;
32791     +  /* initialize binmappings table */
32792     +  data &EM_USER_BINMAPPINGS;
32793     +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
32794     +  run;
32796     +  data _null_;
32797     +    FILE X;
32799     +    put "&EM_CODEBAR;";
32800     +    %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
32801     +    put "* &note;";
32802     +    put "&EM_CODEBAR;";
32803     +  run;
32805     +%end;
32807     +/* assign display_var values to binmappings table as well as initial group values */
32808     +data &EM_USER_BINMAPPINGS;
32809     +  set &EM_USER_BINMAPPINGS;
32810     +  length display_var $32 grp $8;
32811     +  display_var = name;
32813     +  %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
32814     +    GRP = BIN + 1;
32815     +  %end;
32816     +  %else %do;
32817     +    GRP = BIN;
32818     +  %end;
32819     +run;
32821     +/* de-assign fileref */
32822     +filename X;
32824     +    /* append to binning code those values that were included in the importSubset data */
32825     +    %if &useImport eq 1 %then %do;
32826     +      %EM_IMPORT_BINNING(&binningcode);
32827     +    %end;
32829     +    /* append to binning code those values that were included in the freezeSubset data */
32830     +    %if &useFreeze eq 1 %then %do;
32831     +      %EM_FREEZE_BINNING(&binningcode);
32832     +    %end;
32834     +    proc sort data=&EM_USER_BINMAPPINGS out=sortedmapping nodupkey;
32835     +      by NAME;
32836     +    run;
32838     +    /* create grouping for missing level */
32839     +    data tempmissvalues;
32840     +    run;
32842     +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
32843     +       data tempmissvalues;
32844     +         %if ((&useImport eq 1) OR (&useFreeze eq 1)) %then %do;
32845     +           merge sortedmapping
32846     +           %if &useImport eq 1 %then %do;
32847     +              &EM_USER_IMPORtSUBSET(in=_a rename=(_variable_=NAME))
32848     +           %end;
32849     +           %if &useFreeze eq 1 %then %do;
32850     +             &EM_USER_FreezeSUBSET(in=_b rename=(_variable_=NAME))
32851     +           %end;
32852     +           ;
32853     +         %end;
32854     +         %else %do;
32855     +           set sortedmapping;
32856     +         %end;
32857     +         GRP="1";
32858     +         bin="Missing";
32859     +         _split_value_ = "Missing";
32860     +         %if &useImport eq 1 %then %do;
32861     +            if _a then delete;
32862     +         %end;
32863     +         %if &useFreeze eq 1 %then %do;
32864     +            if _b then delete;
32865     +         %end;
32867     +       run;
32868     +    %end;
32871     +    /* create binData from binningCode */
32872     +    filename X "&binningCode";
32874     +    data &bindata;
32875     +      set &input;
32876     +      %inc X;
32877     +    run;
32879     +    filename X;
32881     +    /* create splitvals dataset */
32882     +    data tempsplitvals;
32883     +      set &EM_USER_BINMAPPINGS tempmissvalues;
32884     +      length newgroup _group_ _order_ 8 _level_ $8;
32885     +      newgroup =.;
32886     +      _LEVEL_ = 'ORDINAL';
32887     +      _Group_ = grp;
32888     +      rename NAME=DISPLAY_VAR BIN =_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
32889     +      keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_ _ORDER_;
32890     +    run;
32892     +    data tempsplitvals;
32893     +      set tempsplitvals;
32894     +      _order_ = _N_;
32895     +    run;
32897     +    /* determine if EM_USER_SPLITVALS already exists */
32898     +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
32899     +    %if &sdsid > 0 %then %do;
32900     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
32901     +      %if &nvars > 0 %then %do;
32902     +        proc sql;
32903     +          reset noprint;
32904     +          select count(*) into :nobs from &EM_USER_SPLITVALS;
32905     +        quit;
32906     +      %end;
32907     +      %else %let nobs=0;
32908     +    %end;
32909     +    %else %do;
32910     +       %let nobs=0;
32911     +       %let nvars=0;
32912     +    %end;
32913     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
32915     +    /* if useIMport=1 also include import definitions here as well */
32916     +    %if &useImport eq 1 %then %do;
32917     +      data tempImport;
32918     +        set &EM_USER_IMPORTSUBSET;
32919     +        _variable_ = binVar;
32920     +      run;
32921     +    %end;
32923     +    /* if useFreeze=1 also include frozen definitions here as well */
32924     +    %if &useFreeze eq 1 %then %do;
32925     +      data tempFreeze;
32926     +        length display_var $32;
32927     +        set &EM_USER_FreezeSUBSET;
32928     +        display_var = _variable_;
32929     +        _variable_ = binVar;
32930     +      run;
32931     +    %end;
32933     +    data &EM_USER_SPLITVALS;
32934     +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
32935     +        set &EM_USER_SPLITVALS tempsplitvals
32936     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
32937     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
32938     +        %end;
32939     +        %if &useFreeze eq 1 %then %do;
32940     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
32941     +        %end;
32942     +        ;
32943     +      %end;
32944     +      %else %do;
32945     +        set tempsplitvals
32946     +        %if ((&useImport eq 1) AND (&useFreeze eq 0)) %then %do;
32947     +           tempImport( where=(binVar ne "" and _split_value_ eq "MISSING"))
32948     +        %end;
32949     +        %if &useFreeze eq 1 %then %do;
32950     +           tempFreeze( where=(binVar ne "" and _split_value_ eq "MISSING"))
32951     +        %end;
32952     +        ;
32953     +      %end;
32954     +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _order_;
32955     +    run;
32957     +    /* create temporary mapping dataset of normalized and non-normalized values for char variables*/
32958     +    data tempvariableset;
32959     +      set &EM_DATA_VARIABLESET;
32960     +      where LEVEL ^= 'INTERVAL' and TYPE = 'C' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
32961     +    run;
32963     +   %em_varmacro(name=classvars, metadata=tempvariableset, key=NAME, nummacro=num_classvars);
32965     +    /* add all interval vars that aren't special codes to the intervalvar macro
32966     +    %let dsid = %sysfunc(open(work.tempvariableset));
32967     +    %if &dsid %then %do;
32968     +      %let varnum = %sysfunc(VARNUM(&dsid, NAME));
32969     +      %let obs = %sysfunc(fetch(&dsid));
32970     +      %do %while(&obs=0);
32971     +        %let varname = %sysfunc(getvarc(&dsid, &varnum));
32972     +        %let classvars = &classvars &varname;
32973     +        %let qclassvars = &qclassvars "&varname";
32974     +        %let obs = %sysfunc(fetch(&dsid));
32975     +      %end;
32976     +    %end;
32977     +    %if &dsid %then %let dsid = %sysfunc(close(&dsid));
32978     +*/
32979     +    %if %classvars ne %then %do;
32980     +      proc dmdb data =&bindata classout=_classout nonorm;
32981     +        class %classvars;
32982     +      run;
32984     +      proc dmdb data=&bindata classout=_classout2;
32985     +       class %classvars;
32986     +      run;
32988     +      proc sort data=_classout; by NAME CRAW; run;
32989     +      proc sort data=_classout2; by NAME CRAW; run;
32991     +      data _classout;
32992     +        length _variable_ $32;
32993     +        merge _classout _classout2 (rename=(LEVEL=_split_value_));
32994     +        by NAME CRAW;
32995     +       _variable_ = NAME;
32996     +      run;
32998     +      proc sort data=_classout; by _variable_ _split_value_; run;
32999     +      proc sort data=&EM_USER_SPLITVALS; by _variable_ _split_value_; run;
33001     +      data &EM_USER_SPLITVALS;
33002     +        length _norm_level_ $200 _split_value_ $200;
33003     +        merge &EM_USER_SPLITVALS _classout(rename=(LEVEL=_norm_level_));
33004     +        by _variable_ _split_value_;
33005     +        LEVEL = trim(left(LEVEL));
33006     +        _split_value_ = trim(left(_split_value_));
33007     +        _norm_level_ = trim(left(_norm_level_));
33008     +        if _norm_level_ eq '' then _norm_level_= _split_value_;
33009     +        drop NAME FREQUENCY TYPE CRAW NRAW;
33010     +      run;
33012     +      proc datasets library=work nolist;
33013     +        delete _classout _classout2;
33014     +      run;
33015     +      quit;
33016     +    %end;
33018     +    data &EM_USER_SPLITVALS;
33019     +      set &EM_USER_SPLITVALS;
33020     +      if _norm_level_ eq '' then _norm_level_= _split_value_;
33021     +    run;
33024     +    proc sort data=&EM_USER_SPLITVALS;
33025     +      by DISPLAY_VAR _Group_;
33026     +    run;
33028     +    proc datasets library=work nolist;
33029     +      delete sortedmapping tempsplitvals tempmissvalues
33030     +      %if &useImport eq 1 %then %do;
33031     +        tempImport
33032     +      %end;
33033     +      %if &useFreeze eq 1 %then %do;
33034     +        tempFreeze
33035     +      %end;
33036     +      ;
33037     +    run;
33038     +    quit;
33039     +/*
33040     +%end;
33041     +%else %do;
33042     +    data &bindata;
33043     +      set &input;
33044     +    run;
33045     +%end;
33046     +*/
33047     +%mend EM_QUANTILE_BINNING;
33049     +%macro EM_ORDVARS_GROUP;
33051     +   /* retrieve all ordinal variables from the incoming dataset */
33052     +   proc sort data=&EM_DATA_VARIABLESET out=tempvariableset;
33053     +     by NAME;
33054     +     where LEVEL = 'ORDINAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
33055     +   run;
33057     +   /* add all vars marked as interval that are actually class vars to this data */
33058     +   %let nobs = 0;
33059     +   %let dsid = %sysfunc(open(WORK._DISCRETEMID));
33060     +   %if &dsid %then %do;
33061     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
33062     +     %if &nobs gt 0 %then %do;
33064     +     data tempvars;
33065     +       set &EM_DATA_VARIABLESET;
33066     +       if NAME in (
33067     +         %let obs = %sysfunc(fetch(&dsid));
33068     +         %do %while(&obs=0);
33069     +           %let varnum = %sysfunc(VARNUM(&dsid, VARIABLE));
33070     +           %let varname = %sysfunc(GETVARC(&dsid, &varnum));
33071     +           "&varname"
33072     +           %let obs = %sysfunc(fetch(&dsid));
33073     +         %end;
33074     +        );
33075     +     run;
33076     +     data tempvariableset;
33077     +       set tempvariableset tempvars;
33078     +     run;
33079     +     %end;
33080     +   %end;
33081     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
33083     +   %if &useImport eq 1 %then %do;
33084     +     /* remove all variables from tempvariableset that are included in the importsubset */
33085     +     proc sort data=&EM_USER_IMPORTSUBSET out=tempimport(rename=(_VARIABLE_ = NAME));
33086     +       by _VARIABLE_ ;
33087     +     run;
33088     +     proc sort data=tempvariableset; by NAME; run;
33090     +     data tempvariableset;
33091     +       merge tempimport(in=_a) tempvariableset(in=_b);
33092     +       by NAME;
33093     +       if ^_a then output;
33094     +     run;
33095     +   %end;
33097     +   %if &useFreeze eq 1 %then %do;
33098     +     /* remove all variables from tempvariableset that are included in the freezesubset */
33099     +     proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze(rename=(_VARIABLE_ = NAME));
33100     +       by _VARIABLE_ ;
33101     +     run;
33102     +     proc sort data=tempvariableset; by NAME; run;
33104     +     data tempvariableset;
33105     +       merge tempfreeze(in=_a) tempvariableset(in=_b);
33106     +       by NAME;
33107     +       if ^_a then output;
33108     +     run;
33109     +   %end;
33111     +   /* get dataset of distinct values for the ordinal variable */
33112     +   %let nobs = 0;
33113     +   %let dsid = %sysfunc(open(WORK.tempvariableset));
33114     +   %if &dsid %then %do;
33115     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
33116     +     %if &nobs gt 0 %then %do;
33117     +         %let obs = %sysfunc(fetch(&dsid));
33118     +         %do %while(&obs=0);
33119     +           %let varnum = %sysfunc(VARNUM(&dsid, NAME));
33120     +           %let varname = %sysfunc(GETVARC(&dsid, &varnum));
33121     +           %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
33122     +           %let input_type = %sysfunc(getvarc(&dsid, &typenum));
33123     +           %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
33124     +           %let input_fmt = %sysfunc(getvarc(&dsid, &fmtnum));
33125     +           %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
33126     +           %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
33127     +           %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
33129     +           data temp;
33130     +             set &EM_USER_BINDATA(keep=&varname);
33131     +             %if &input_fmt ne %then %do;
33132     +               %dmnormcp(put(&varname, &input_fmt), _norm);
33133     +             %end;
33134     +             %else %do;
33135     +               %dmnormcp(&varname, _norm);
33136     +             %end;
33137     +             keep &varname _norm;
33138     +           run;
33140     +          proc dmdb data=temp classout=_classout2;
33141     +           class _norm;
33142     +         run;
33143     +         proc sort data=_classout2; by LEVEL; run;
33145     +         /* re-order numeric inputs based on non-normalized values */
33146     +         %if &input_type eq N %then %do;
33147     +           proc sort data=temp nodupkey; by _norm; run;
33148     +           data varvals;
33149     +             merge temp _classout2(rename=(LEVEL=_norm));
33150     +             by _norm;
33151     +             if craw='' and _norm ne '.' then delete;
33152     +             keep &varname _norm nraw craw;
33153     +           run;
33155     +           proc sort data=varvals; by &varname; run;
33156     +         %end;
33157     +         %else %do;
33158     +           data varvals;
33159     +              set _classout2(rename=(LEVEL=_norm));
33160     +              if _norm='' then delete;
33161     +              if _norm='.' then delete;
33162     +              keep _norm;
33163     +           run;
33164     +         %end;
33165     +         data varvals;
33166     +           set varvals;
33167     +           if &varname="." then delete;
33168     +           if upcase(&varname) = "MISSING" then delete;
33169     +         run;
33171     +          /* generate Splitvals Data */
33172     +          data tempsplitvals;
33173     +            length DISPLAY_VAR _VARIABLE_ $32 _Split_value_ $200 newgroup _group_ _order_ 8 _level_ $8 _norm_level_ $200 ;
33175     +            %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
33176     +              DISPLAY_VAR="&varname";
33177     +              _VARIABLE_ ="&varname";
33178     +              newgroup   =.;
33179     +              _group_    =1;
33180     +              _Split_Value_="Missing";
33181     +              _level_    ="ORDINAL";
33182     +              output;
33183     +              %let group=2;
33184     +            %end;
33185     +            %else %let group=1;
33187     +            %let vdsid = %sysfunc(open(WORK.VARVALS));
33188     +            %if &vdsid %then %do;
33189     +            %let namenum = %sysfunc(VARNUM(&vdsid, _norm));
33190     +            /*%let group = 2;*/
33191     +            %let vobs = %sysfunc(fetch(&vdsid));
33192     +            %do %while(&vobs=0);
33193     +                %let nameval = %bquote(%upcase(%sysfunc(getvarc(&vdsid, &namenum))));
33195     +                DISPLAY_VAR   = "&varname";
33196     +                _variable_    = "&varname";
33197     +                newgroup      = .;
33198     +                _group_       = &group;
33199     +                _split_value_ = "&nameval";
33200     +                _level_       = 'ORDINAL';
33201     +                output;
33203     +              %let group = %eval(&group + 1);
33204     +              %let vobs = %sysfunc(fetch(&vdsid));
33205     +            %end;
33206     +            %if &vdsid %then %let vdsid = %sysfunc(close(&vdsid));
33207     +          run;
33209     +          /* determine if EM_USER_SPLITVALS already exists */
33210     +          %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
33211     +          %if &sdsid > 0 %then %do;
33212     +            %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
33213     +            %if &nvars > 0 %then %do;
33214     +               proc sql;
33215     +                reset noprint;
33216     +                select count(*) into :nobs from &EM_USER_SPLITVALS;
33217     +               quit;
33218     +            %end;
33219     +            %else %let nobs=0;
33220     +            %end;
33221     +            %else %do;
33222     +              %let nobs=0;
33223     +              %let nvars=0;
33224     +            %end;
33225     +          %end;
33226     +          %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
33228     +          /* if tempsplitvals doesn't exist; create empty data set */
33229     +          %let sdsid = %sysfunc(open(work.tempsplitvals));
33230     +          %if &sdsid <= 0 %then %do;
33231     +            data tempsplitvals;
33232     +              length DISPLAY_VAR _VARIABLE_ $32 _Split_value_ $200 newgroup _group_ 8 _level_ $8 ;
33233     +            run;
33234     +          %end;
33235     +          %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
33237     +          data tempsplitvals;
33238     +            set tempsplitvals;
33239     +            _order_ = _N_;
33240     +          run;
33242     +          %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
33243     +             proc sort data = &EM_USER_SPLITVALS; by _variable_ _split_value_; run;
33244     +             proc sort data = tempsplitvals nodupkey; by _variable_ _split_Value_ _group_; run;
33245     +          %end;
33247     +          data &EM_USER_SPLITVALS;
33248     +           %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
33249     +             merge &EM_USER_SPLITVALS tempsplitvals;
33250     +             by _variable_ _split_value_;
33251     +           %end;
33252     +           %else %do;
33253     +             set tempsplitvals;
33254     +           %end;
33255     +           if display_var eq "" then delete;
33256     +           if _norm_level_ eq "" then _norm_level_ = _split_value_;
33257     +           keep display_var _split_value_ _variable_ newgroup _group_ _level_ _norm_level_ _order_;
33258     +         run;
33260     +           %let obs = %sysfunc(fetch(&dsid));
33261     +         %end;
33262     +     %end;
33263     +   %end;
33264     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
33266     +   proc sort data=&EM_USER_SPLITVALS;
33267     +      by DISPLAY_VAR _Group_;
33268     +   run;
33270     +   /* delete temporary datasets */
33271     +   proc datasets library= work nolist;
33272     +     delete tempsplitvals varvals tempvariableset tempvars
33273     +     ;
33274     +   run;
33275     +   quit;
33276     +%mend EM_ORDVARS_GROUP;
33279     +%macro EM_CLASSVARS_GROUP(groupRare);
33281     +   /* retrieve all class variables from the incoming dataset */
33282     +   proc sort data=&EM_DATA_VARIABLESET out=tempvariableset;
33283     +     by NAME;
33284     +     where ((LEVEL = 'NOMINAL') OR (LEVEL='BINARY')) and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
33285     +   run;
33287     +   %if &useImport eq 1 %then %do;
33288     +     /* remove all variables from tempvariableset that are included in the importsubset */
33289     +     proc sort data=&EM_USER_IMPORTSUBSET out=tempimport(rename=(_VARIABLE_ = NAME));
33290     +       by _VARIABLE_ ;
33291     +     run;
33292     +     proc sort data=tempvariableset; by NAME; run;
33294     +     data tempvariableset;
33295     +       merge tempimport(in=_a) tempvariableset(in=_b);
33296     +       by NAME;
33297     +       if ^_a then output;
33298     +     run;
33299     +   %end;
33301     +   %if &useFreeze eq 1 %then %do;
33302     +     /* remove all variables from tempvariableset that are included in the freezesubset */
33303     +     proc sort data=&EM_USER_FREEZESUBSET out=tempfreeze(rename=(_VARIABLE_ = NAME));
33304     +       by _VARIABLE_ ;
33305     +     run;
33306     +     proc sort data=tempvariableset; by NAME; run;
33308     +     data tempvariableset;
33309     +       merge tempfreeze(in=_a) tempvariableset(in=_b);
33310     +       by NAME;
33311     +       if ^_a then output;
33312     +     run;
33313     +   %end;
33315     +   /* run dmdb to retrieve list of all class levels and counts */
33316     +   %let dsid = %sysfunc(open(work.tempvariableset));
33317     +   %let nobs = 0;
33318     +   %if &dsid %then %do;
33319     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
33321     +   %end;
33323     +   %if &nobs gt 0 %then %do;
33324     +     proc dmdb data=&EM_IMPORT_DATA classout=tempclassout;
33325     +       class
33327     +        %let namenum = %sysfunc(VARNUM(&dsid, NAME));
33328     +        %let obs = %sysfunc(fetch(&dsid));
33329     +        %do %while(&obs=0);
33330     +           %let name = %sysfunc(getvarc(&dsid, &namenum));
33331     +           &name
33332     +           %let obs = %sysfunc(fetch(&dsid));
33333     +        %end;
33334     +     ;
33336     +     %if %EM_FREQ ne %then %do;
33337     +        freq %EM_FREQ;
33338     +     %end;
33339     +    run;
33340     +   %end;
33341     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
33343     +   %let dsid = %sysfunc(open(work.tempclassout));
33344     +   %let nobs = 0;
33345     +   %if &dsid %then %do;
33346     +     %let nobs = %sysfunc(ATTRN(&dsid, NOBS));
33347     +     %let dsid = %sysfunc(close(&dsid));
33348     +   %end;
33350     +   %if &nobs gt 0 %then %do;
33351     +    data tempclassout;
33352     +       set tempclassout;
33353     +       if LEVEL='MISSING' then level='Missing';
33354     +    run;
33356     +    proc sort data=tempclassout nodupkey;
33357     +      by NAME descending FREQUENCY LEVEL;
33358     +    run;
33360     +    data tempds(keep=NAME NOBS);
33361     +      retain NOBS;
33362     +      set tempclassout;
33363     +      by NAME;
33364     +      if first.NAME then
33365     +        NOBS = frequency;
33366     +      else
33367     +        NOBS=NOBS+frequency;
33368     +      if last.name then do;
33369     +        output;
33370     +      end;
33371     +    run;
33373     +    data tempds;
33374     +      merge tempclassout
33375     +      tempds;
33376     +      by NAME;
33377     +      if ((LEVEL ne '') AND (LEVEL ne "."));
33378     +      %if &groupRare eq Y %then %do;
33379     +        PCT = 100 * (FREQUENCY/NOBS);
33380     +        if PCT < &EM_PROPERTY_GROUPCUTOFF then flag=1;
33381     +        else flag=0;
33382     +      %end;
33383     +      %else %do;
33384     +        flag = 0;
33385     +      %end;
33386     +    run;
33388     +    %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
33389     +      data tempmissvalues;
33390     +        length NAME $32 LEVEL $200 _LEVEL_ $8 _GROUP_ 8;
33392     +      %let dsid = %sysfunc(open(WORK.TEMPVARIABLESET));
33393     +      %if &dsid %then %do;
33394     +        %let varnum = %sysfunc(VARNUM(&dsid, NAME));
33395     +        %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
33396     +        %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
33397     +        %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
33398     +        %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
33399     +        %let obs = %sysfunc(fetch(&dsid));
33401     +        %do %while(&obs=0);
33402     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
33403     +          %let format = %sysfunc(getvarc(&dsid, &fmtnum));
33404     +          %let type = %sysfunc(getvarc(&dsid, &typenum));
33405     +          %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
33407     +          NAME="&var";
33408     +          LEVEL="Missing";
33409     +          _LEVEL_="&varlvl";
33410     +          _group_ = 1;
33411     +          output;
33413     +          %let obs = %sysfunc(fetch(&dsid));
33414     +        %end;
33415     +      %end;
33416     +      %if &dsid %then %let dsid = %sysfunc(close(&dsid));
33417     +      run;
33418     +    %end;
33420     +    /* generate Splitvals Data */
33421     +    data tempsplitvals;
33422     +      length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
33424     +      set tempclassout
33425     +      %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
33426     +         tempmissvalues
33427     +      %end;
33428     +      ;
33429     +      if ((level ne '') AND (level ne '.'));
33431     +     %let dsid = %sysfunc(open(WORK.TEMPVARIABLESET));
33432     +     %if &dsid %then %do;
33433     +        %let varnum = %sysfunc(VARNUM(&dsid, NAME));
33434     +        %let fmtnum = %sysfunc(VARNUM(&dsid, FORMAT));
33435     +        %let typenum = %sysfunc(VARNUM(&dsid, TYPE));
33436     +        %let lblnum  = %sysfunc(VARNUM(&dsid, LABEL));
33437     +        %let varlvlnum = %sysfunc(VARNUM(&dsid, LEVEL));
33438     +        %let obs = %sysfunc(fetch(&dsid));
33440     +        %do %while(&obs=0);
33441     +          %let var = %sysfunc(getvarc(&dsid, &varnum));
33442     +          %let format = %sysfunc(getvarc(&dsid, &fmtnum));
33443     +          %let type = %sysfunc(getvarc(&dsid, &typenum));
33444     +          %let varlvl = %sysfunc(getvarc(&dsid, &varlvlnum));
33446     +          if NAME = "&var" then do;
33447     +            _LEVEL_ = "&varlvl";
33449     +          /* cycle through levels, assigning group values;              */
33450     +          /* flag=1 indicates to put value in "_OTHER_" group;          */
33451     +          /* flag=0 indicates that value shoudld be in group of its own */
33452     +          %let choice = ((NAME="&Var") and (FLAG=0));
33453     +          %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
33454     +            %let group=2;
33455     +          %end;
33456     +          %else %do;
33457     +            %let group = 1;
33458     +          %end;
33459     +          %let fdsid = %sysfunc(open(work.tempds(where=(&choice))));
33460     +          %if &fdsid %then %do;
33462     +            %let lvlnum = %sysfunc(VARNUM(&fdsid, LEVEL));
33463     +            %let fobs = %sysfunc(fetch(&Fdsid));
33464     +            %let fflag = 0;
33465     +            %do %while(&fobs=0);
33466     +              %let fflag = 1;
33467     +              %let temp = %nrbquote(%sysfunc(getvarc(&fdsid, &lvlnum)));
33468     +              %let level = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
33469     +              %let level = %nrbquote(%sysfunc(strip(&level)));
33470     +              %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
33471     +                %if &group eq 2 %then %do;
33472     +                   if LEVEL = "&level" then _GROUP_ = &group;
33473     +                %end;
33474     +                %else %do;
33475     +                   else if LEVEL = "&level" then _GROUP_ = &group;
33476     +                %end;
33477     +              %end;
33478     +              %else %do;
33479     +                %if &group eq 1 %then %do;
33480     +                   if LEVEL = "&level" then _GROUP_ = &group;
33481     +                %end;
33482     +                %else %do;
33483     +                   else if LEVEL = "&level" then _GROUP_ = &group;
33484     +                %end;
33485     +              %end;
33487     +              %let group = %eval(&group + 1);
33488     +              %let fobs = %sysfunc(fetch(&fdsid));
33489     +            %end;
33491     +          %end;
33492     +          %if &fflag eq 1 %then %do;
33493     +            else if LEVEL ^='Missing' then _GROUP_ = &group;
33494     +          %end;
33495     +          end;
33497     +          %if &fdsid %then %let fdsid = %sysfunc(close(&fdsid));
33498     +          %let obs = %sysfunc(fetch(&dsid));
33499     +        %end;
33500     +     %end;
33501     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
33502     +     _VARIABLE_ = NAME;
33503     +     newgroup = .;
33504     +     rename NAME = DISPLAY_VAR
33505     +            LEVEL = _SPLIT_VALUE_;
33506     +     keep NAME NEWGROUP _VARIABLE_ LEVEL _LEVEL_ _GROUP_;
33507     +    run;
33508     +  %end;
33509     +   %if &dsid %then %let dsid = %sysfunc(close(&dsid));
33511     +    /* determine if EM_USER_SPLITVALS already exists */
33512     +    %let sdsid = %sysfunc(open(&EM_USER_SPLITVALS));
33513     +    %if &sdsid > 0 %then %do;
33514     +      %let nvars = %sysfunc(ATTRN(&sdsid, NVARS));
33515     +      %if &nvars > 0 %then %do;
33516     +        proc sql;
33517     +          reset noprint;
33518     +          select count(*) into :nobs from &EM_USER_SPLITVALS;
33519     +        quit;
33520     +      %end;
33521     +      %else %let nobs=0;
33522     +    %end;
33523     +    %else %do;
33524     +       %let nobs=0;
33525     +       %let nvars=0;
33526     +    %end;
33527     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
33529     +   /* if tempsplitvals doesn't exist; create empty data set */
33530     +    %let sdsid = %sysfunc(open(work.tempsplitvals));
33531     +    %if &sdsid <= 0 %then %do;
33532     +      data tempsplitvals;
33533     +        length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
33534     +      run;
33535     +    %end;
33536     +    %if &sdsid > 0 %then %let sdsid = %sysfunc(close(&sdsid));
33538     +    %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
33539     +      proc sort data = &EM_USER_SPLITVALS; by _variable_ _split_value_; run;
33540     +      proc sort data = tempsplitvals nodupkey; by _variable_ _split_Value_ _group_; run;
33541     +    %end;
33543     +    /* if useIMport=1 also include import definitions here as well */
33544     +    %if &useImport eq 1 %then %do;
33545     +      proc sort data=&EM_USER_IMPORTSUBSET; by _variable_ _split_value_; run;
33546     +    %end;
33547     +    %if &useFreeze eq 1 %then %do;
33548     +      proc sort data=&EM_USER_FREEZESUBSET; by _variable_ _split_value_; run;
33549     +    %end;
33550     +    data &EM_USER_SPLITVALS;
33551     +      %if ((&nobs > 0) AND (&nvars > 0)) %then %do;
33552     +        merge &EM_USER_SPLITVALS tempsplitvals
33553     +        %if &useImport eq 1 %then %do;
33554     +           &EM_USER_IMPORTSUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
33555     +        %end;
33556     +        %if &useFreeze eq 1 %then %do;
33557     +           &EM_USER_FREEZESUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
33558     +        %end;
33560     +        ;
33561     +        by _variable_ _split_value_
33562     +        ;
33563     +      %end;
33564     +      %else %do;
33565     +        set tempsplitvals
33566     +        %if &useImport eq 1 %then %do;
33567     +           &EM_USER_IMPORTSUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
33568     +        %end;
33569     +        %if &useFreeze eq 1 %then %do;
33570     +           &EM_USER_FREEZESUBSET(where=(binVar eq "" and _level_ ne "INTERVAL"))
33571     +        %end;
33572     +        ;
33573     +      %end;
33574     +      if display_var eq "" then delete;
33575     +      if _norm_level_ eq "" then _norm_level_ = _split_value_;
33576     +      keep display_var _split_value_ _variable_ newgroup _group_ _level_ _norm_level_;
33577     +    run;
33579     +    proc sort data=&EM_USER_SPLITVALS;
33580     +      by DISPLAY_VAR _Group_;
33581     +    run;
33583     +   /* delete temporary datasets */
33584     +   proc datasets library= work nolist;
33585     +     delete tempsplitvals tempds tempclassout tempvariableset tempvars
33586     +     %if &EM_PROPERTY_MISSINGASLEVEL eq Y %then %do;
33587     +       tempmissvalues
33588     +     %end;
33589     +     ;
33590     +   run;
33591     +   quit;
33592     +%mend EM_CLASSVARS_GROUP;
33595     +%macro EM_SUMMARIZE_TABLE(data, inputData, outData, varname=);
33597     +  proc sort data=&EM_DATA_VARIABLESET out=tempvarset; by name; run;
33599     +  data temptrain ;
33600     +    set &data;
33601     +  run;
33603     +  /* normalize all values prior to calculating counts */
33604     +  filename _temp catalog 'sashelp.emapps.em_Prenormalizeclassvars.source';
33605     +  %include _temp;
33606     +  filename _temp;
33607     +  filename _temp catalog 'sashelp.emapps.em_Normalizeclassvars.source';
33608     +  %include _temp;
33609     +  filename _temp;
33611     +  proc sort data=&EM_USER_VARMAPPINGS
33612     +  %if &varname ne %then %do;
33613     +    (where=(_variable_="&varname"))
33614     +  %end;
33615     +  out=tempmap; by _variable_; run;
33617     +  data _cmeta;
33618     +    merge tempvarset tempmap(in=_a rename=(_variable_=name ));
33619     +    by name;
33620     +    if ((_a) or (role="TARGET"));
33621     +    if role="INPUT" or (role="REJECTED" and Use="Y") then name=_proc_var_;
33622     +    %if %length(%EM_BINARY_TARGET) %then %do;
33623     +      if role="TARGET" then role="INPUT";
33624     +    %end;
33625     +    level = procLevel;
33626     +    index = kindex(name, "BIN_");
33627     +    if index gt 0 then do;
33628     +     level="ORDINAL";
33629     +     format = "";
33630     +    end;
33631     +    drop index;
33632     +  run;
33634     +  %em_PreNormalizeClassVars(incmeta=_cmeta, outcmeta=_cmetatmp);
33635     +  %em_NormalizeClassVars(indata=work.temptrain, cmeta=_cmetatmp, encodedTarget=N, outdata=_tmp_train);
33637     +  proc sort data=&inputData out=sortedmap; by _proc_var_; run;
33639     +  data _null_;
33640     +    set sortedmap end=eof;
33641     +    by _proc_var_;
33642     +    if _n_=1 then do;
33643     +      call execute("ods output CrossTabFreqs=crosstabfreq ;");
33644     +      call execute("ods listing close;");
33645     +      call execute("proc freq data=_tmp_train order=formatted addnames;");
33646     +      call execute("tables ("||_proc_var_);
33647     +    end;
33648     +    else do;
33649     +      call execute(_proc_var_);
33650     +    end;
33651     +    if eof then do;
33652     +      call execute(") * &ignbintarget/ missing;");
33653     +      %if %EM_FREQ ne %then %do;
33654     +        call execute("weight %EM_FREQ;");
33655     +      %end;
33656     +      call execute("run;");
33657     +      call execute("ods output close;");
33658     +      call execute("ods listing;");
33659     +    end;
33660     +  run;
33662     +  data _null_;
33663     +    set sortedmap end=eof;
33664     +    by _proc_var_;
33665     +    if _n_=1 then do;
33666     +      call execute("data crosstabs;");
33667     +      call execute("  length _variable_ _split_value_  $200 ;");
33668     +      call execute("  set crosstabfreq(where=(_type_='11'));");
33669     +      call execute("  _variable_= RowVariable;");
33670     +    end;
33672     +    call execute("if strip(RowVariable) = '"||strip(_proc_var_)||"' then do;");
33673     +    call execute("  _split_value_="||_proc_var_||";");
33674     +    call execute("end;");
33676     +    if eof then do;
33677     +      call execute("keep _variable_ _split_value_ &ignbintarget Frequency Percent display_var;");
33678     +      call execute("run;");
33679     +    end;
33680     +  run;
33682     +  proc sort data=crosstabs; by _variable_ _split_value_; run;
33684     +  data crosstabs;
33685     +    length display_var $32;
33686     +    merge crosstabs sortedmap(rename=(_variable_=display_var _proc_var_=_variable_ ) keep=_variable_ _proc_var_ );
33687     +    by _variable_;
33688     +  run;
33690     +  proc sort data=crosstabs; by display_var _split_value_; run;
33691     +  proc sort data=&EM_DATA_VARIABLESET out=tempvarset; by name; run;
33693     +  data crosstabs;
33694     +    merge crosstabs tempvarset(rename=(name=display_var) keep=type format name level);
33695     +    by display_var;
33696     +    index = kindex(_variable_, "BIN_");
33697     +    if index gt 0 then do;
33698     +     level="ORDINAL";
33699     +     format = "";
33700     +    end;
33701     +    _temp = &ignbintarget;
33702     +    /*
33703     +    %if ((&target_type eq C) OR (&target_format ne ))  %then %do;
33704     +      %if &target_format ne %then %do;
33705     +        %if &target_type eq C %then %do;
33706     +           %dmnormcp(put(&ignbintarget, &target_format), _temp);
33707     +        %end;
33708     +        %else %do;
33709     +           %dmnormcp(put(&ignbintarget, &target_format), _temp);
33710     +        %end;
33711     +      %end;
33712     +      %else %do;
33713     +        %dmnormcp(&ignbintarget, _temp);
33714     +      %end;
33715     +    %end;
33716     +    %else %do;
33717     +      _temp = &ignbintarget;
33718     +    %end;
33719     +*/
33721     +    drop index;
33722     +  run;
33724     +  proc sort data=crosstabs; by _variable_ _split_value_; run;
33726     +  data &outdata;
33727     +    length _variable_ _split_value_ $200 eventCount nonEventCount Total EventRate nonEventRate  8 type $1 valfmt $20 ;
33729     +    retain eventCount noneventCount ;
33730     +    set crosstabs;
33731     +    by  _variable_ _split_value_;
33733     +    if first._split_value_ then do;
33734     +     total=0;
33735     +     eventcount=0;
33736     +     noneventcount=0;
33737     +    end;
33739     +    %if ((&target_type eq C) OR (&target_format ne ))  %then %do;
33740     +      %if &target_format ne %then %do;
33741     +        if upcase(strip(_temp))="&target_event" then
33742     +          eventCount=Frequency;
33743     +      %end;
33744     +      %else %do;
33745     +         if upcase(strip(_temp)) ="&target_event" then
33746     +          eventCount=Frequency;
33747     +      %end;
33748     +    %end;
33749     +    %else %do;
33750     +      if _temp=&target_event then
33751     +        eventCount=Frequency;
33752     +    %end;
33753     +    else
33754     +      noneventCount=Frequency;
33756     +    if last._split_value_ then do;
33757     +      total = eventCount + noneventCount;
33759     +      if total ne 0 then do;
33760     +        eventRate = eventCount / total;
33761     +        nonEventRate = nonEventCount / total;
33762     +      end;
33763     +      else do;
33764     +        eventRate = 0;
33765     +        nonEventRate = 0;
33766     +      end;
33767     +     output;
33768     +    end;
33769     +    valfmt = format;
33771     +    drop _temp Frequency percent;
33772     +   run;
33774     +%mend EM_SUMMARIZE_TABLE;
33777     +%macro EM_FINE_DETAIL(bindata, varmappings, fineDetailData, splitVals, binMappings, interactiveFlag=0);
33779     +   proc freq data=&bindata noprint;
33780     +     table &ignbintarget / missing out=temptargetB;
33781     +     %if %EM_FREQ ne %then %do;
33782     +       weight %EM_FREQ;
33783     +     %end;
33784     +   run;
33786     +   %let tdsid = %sysfunc(open(work.temptargetB));
33787     +   %if &tdsid %then %do;
33788     +      %let tarnum = %sysfunc(VARNUM(&tdsid, &ignbintarget));
33789     +      %let tnum  = %sysfunc(VARNUM(&tdsid, COUNT));
33791     +      %let temp = %nrbquote(%sysfunc(strip(&target_event)));
33792     +      %let target_event = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
33793     +      %let temp = %nrbquote(%sysfunc(strip(&target_nonevent)));
33794     +      %let target_nonevent = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
33797     +      %let obs = %sysfunc(fetch(&tdsid));
33798     +      %do %while(&obs = 0);
33799     +         %if ((&target_type eq C) or (&target_format ne )) %then %do;
33800     +           %if &target_type eq C %then %do;
33801     +             %let temp = %nrbquote(%sysfunc(getvarc(&tdsid, &tarnum)));
33802     +             %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
33803     +           %end;
33804     +           %else
33805     +             %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
33807     +           %if &target_format ne %then %do;
33808     +              %if &target_type eq C %then %do;
33809     +                %let temp = %nrbquote(%sysfunc(putc(%nrbquote(&tarvalue), &target_format)));
33810     +                %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
33811     +              %end;
33812     +              %else
33813     +                %let tarvalue = %sysfunc(putn(&tarvalue, &target_format));
33814     +           %end;
33815     +           %let tarvalue = %nrbquote(%upcase(%sysfunc(strip(&tarvalue))));
33816     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
33818     +           %if "&tarvalue" eq "&target_event" %then %do;
33819     +             %let totalevent = &count;
33820     +           %end;
33821     +           %else %if "&tarvalue" eq "&target_nonevent" %then %do;
33822     +              %let totalnonevent= &count;
33823     +           %end;
33824     +         %end;
33825     +         %else %do;
33826     +           %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
33827     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
33829     +           %if &tarvalue eq &target_event %then %do;
33830     +             %let totalevent = &count;
33831     +           %end;
33832     +           %else %if &tarvalue eq &target_nonevent %then %do;
33833     +              %let totalnonevent= &count;
33834     +           %end;
33835     +         %end;
33836     +         %let obs = %sysfunc(fetch(&tdsid));
33837     +      %end;
33838     +   %end;
33839     +   %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
33841     +   proc datasets lib=work nolist;
33842     +      delete temptargetB;
33843     +   run;
33844     +   quit;
33846     +   %if &interactiveFlag eq 0 %then %do;
33847     +     %EM_SUMMARIZE_TABLE(&bindata, &varmappings, &fineDetailData);
33848     +   %end;
33849     +   %else %do;
33850     +     %EM_SUMMARIZE_TABLE(&bindata, &varmappings, &fineDetailData, varname=&wherevar);
33851     +   %end;
33854     +   data &fineDetailData;
33855     +     length display_var $32 newgroup numsplitval 8;
33856     +     set &fineDetailData;
33858     +     display_var = _variable_;
33860     +     index = kindex(display_var, "BIN_");
33861     +     if index gt 0 then do;
33862     +       display_var = ksubstr(display_var, 5);
33863     +     end;
33865     +     index2 = kindex(display_var, "SV_");
33866     +     if index2 gt 0 then do;
33867     +       display_var = ksubstr(display_var, 4);
33868     +     end;
33870     +     /* re-code missing values to "Missing" */
33871     +     if ((_SPLIT_VALUE_ = "") or (_SPLIT_VALUE_ = " ") or (_SPLIT_VALUE_ = ".")) then _SPLIT_VALUE_="MISSING";
33872     +     _index_ = _N_;
33873     +     newgroup = .;
33874     +     drop index index2 ;
33875     +   run;
33877     +   /* add group information to fineDetailData; */
33878     +   /* add label information for binned variables to fineDetailData*/
33880     +   proc sort data=&fineDetailData; by _variable_ _split_value_; run;
33882     +   data tmpsplitvals;
33883     +     set &splitvals;
33884     +     _norm_level_ = upcase(_norm_level_);
33885     +     if _split_value_ eq 'Missing' then _split_value_ = 'MISSING';
33886     +    * drop _split_value_;
33887     +   run;
33889     +   proc sort data=tmpsplitvals out=sortedsplit; by _variable_ _split_value_; run;
33890     +   proc datasets library=work nolist;
33891     +     delete tmpsplitvals;
33892     +   run;
33893     +   quit;
33895     +   proc sort data=&BINMAPPINGS out=sortedbin; by BIN_NAME BIN; run;
33897     +   data &fineDetailData;
33898     +      merge &fineDetailData(in=_c) work.sortedsplit(in=_b) work.sortedbin(rename=(BIN_NAME=_variable_ BIN=_split_value_) in=_a);
33899     +      by _variable_ _split_value_;
33900     +      if _a then do;
33901     +        binFlag = 1;
33902     +        VALUE=EM_BIN_LABEL;
33903     +      end;
33904     +      else do;
33905     +        binFlag = 0;
33906     +        *VALUE=strip(display_var)!!"="!!strip(_split_value_);
33907     +        VALUE=strip(_split_value_);
33909     +      end;
33911     +      if ((eventCount=.) or (nonEventCount=.)) then do;
33912     +        eventCount=0;
33913     +        nonEventCount=0;
33914     +        total = 0;
33915     +        eventRate= 0;
33916     +        nonEventRate = 0;
33917     +      end;
33919     +      eventCount = round(eventCount, .001);
33920     +      nonEventCount = round(nonEventCount, .001);
33921     +      total= round(total, .001);
33922     +      eventRate = round(eventRate, .001);
33923     +      nonEventRate = round(nonEventRate, .001);
33925     +     if ((type='N') AND (VERIFY(trim(left(_split_value_)) , '.0123456789')=0) ) then
33926     +         numsplitval = _split_value_;
33927     +     else if ((type='N') AND (valfmt ne "")) then
33928     +        numsplitval = _order_;
33929     +     else numsplitval=.;
33931     +      if DISPLAY_VAR = "" and _VARIABLE_ = "" then delete;
33932     +      if _a and ^_b then delete;
33933     +      if _c and ^_b then delete;
33934     +      drop NAME EM_BIN_LABEL valfmt;
33935     +   run;
33937     +   /* for class variables that have values falling into the "other" category, set _LEVEL_ and _GROUP_ based on Missing level */
33938     +   data &fineDetailData;
33939     +     set &fineDetailData;
33941     +     %let choice = _LEVEL_ ne "INTERVAL" and _SPLIT_VALUE_ eq "Missing";
33942     +     %let dsid = %sysfunc(open(&splitvals(where=(&choice))));
33943     +     %if &dsid %then %do;
33944     +       %let dnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
33945     +       %let lvlnum = %sysfunc(VARNUM(&dsid, _LEVEL_));
33946     +       %let grpnum = %sysfunc(VARNUM(&dsid, _GROUP_));
33948     +       %let obs = %sysfunc(fetch(&dsid));
33949     +       %do %while(&obs=0);
33950     +         %let dispvar = %sysfunc(getvarc(&dsid, &dnum));
33951     +         %let lvl     = %sysfunc(getvarc(&dsid, &lvlnum));
33952     +         %let group   = %sysfunc(getvarn(&dsid, &grpnum));
33954     +         if DISPLAY_VAR = "&dispvar" then do;
33955     +           if _LEVEL_ = "" then _LEVEL_ ="&lvl";
33956     +           if _GROUP_ = . then _GROUP_ = &group;
33957     +         end;
33959     +         %let obs = %sysfunc(fetch(&dsid));
33960     +       %end;
33961     +     %end;
33962     +     %if &dsid %then %let dsid = %sysfunc(close(&dsid));
33963     +     if _GROUP_ = . then delete;
33964     +    * if binFlag=1 and UB=LB then delete;
33965     +    * if upcase(_SPLIT_VALUE_) ne "MISSING" and _index_ eq . then delete;
33966     +   run;
33968     +   proc sort data=&fineDetailData;
33969     +     by DISPLAY_VAR _index_;
33970     +   run;
33972     +   proc datasets lib=work nolist;
33973     +     delete sortedsplit sortedbin
33974     +     ;
33975     +   run;
33976     +   quit;
33977     +%mend EM_FINE_DETAIL;
33979     +%macro EM_CREATE_GROUPING(bindata, fineDetailData, coarse);
33981     +   proc freq data=&bindata noprint;
33982     +     table &ignbintarget / missing out=temptargetC;
33983     +     %if %EM_FREQ ne %then %do;weight %EM_FREQ;
33984     +     %end;
33985     +   run;
33987     +   %let tdsid = %sysfunc(open(work.temptargetC));
33988     +   %if &tdsid %then %do;
33989     +      %let tarnum = %sysfunc(VARNUM(&tdsid, &ignbintarget));
33990     +      %let tnum  = %sysfunc(VARNUM(&tdsid, COUNT));
33992     +      %let obs = %sysfunc(fetch(&tdsid));
33993     +      %do %while(&obs = 0);
33994     +        /* %if &target_type eq C or &target_format ne %then %do; */
33995     +         %if ((&target_type eq C) or (&target_format ne )) %then %do;
33996     +           %if &target_type eq C %then %do;
33997     +             %let temp = %nrbquote(%sysfunc(getvarc(&tdsid, &tarnum)));
33998     +             %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
33999     +           %end;
34000     +           %else
34001     +             %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
34003     +           %if &target_format ne %then %do;
34004     +              %if &target_type eq C %then %do;
34005     +                %let temp = %nrbquote(%sysfunc(putc(%nrbquote(&tarvalue), &target_format)));
34006     +                %let tarvalue = %nrbquote(%sysfunc(tranwrd(&temp, %str(%"),"")));
34007     +              %end;
34008     +              %else
34009     +                %let tarvalue = %sysfunc(putn(&tarvalue, &target_format));
34010     +           %end;
34011     +           %let tarvalue =%nrbquote(%upcase(&tarvalue));
34012     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
34014     +           %let tarvalue = %nrbquote(%upcase(%sysfunc(strip(&tarvalue))));
34015     +           %let target_event = %nrbquote(%sysfunc(strip(&target_event)));
34016     +           %let target_nonevent = %nrbquote(%sysfunc(strip(&target_nonevent)));
34018     +           %if "&tarvalue" eq "&target_event" %then %do;
34019     +             %let totalevent = &count;
34020     +           %end;
34021     +           %else %if "&tarvalue" eq "&target_nonevent" %then %do;
34022     +              %let totalnonevent= &count;
34023     +           %end;
34024     +         %end;
34025     +         %else %do;
34026     +           %let tarvalue = %sysfunc(getvarn(&tdsid, &tarnum));
34027     +           %let count = %sysfunc(getvarn(&tdsid, &tnum));
34029     +           %if &tarvalue eq &target_event %then %do;
34030     +             %let totalevent = &count;
34031     +           %end;
34032     +           %else %if &tarvalue eq &target_nonevent %then %do;
34033     +              %let totalnonevent= &count;
34034     +           %end;
34035     +         %end;
34036     +         %let obs = %sysfunc(fetch(&tdsid));
34037     +      %end;
34038     +   %end;
34039     +   %if &tdsid %then %let tdsid = %sysfunc(close(&tdsid));
34041     +   proc datasets lib=work nolist;
34042     +      delete temptargetC;
34043     +   run;
34044     +   quit;
34046     +   proc means data=&FINEDETAILDATA noprint;
34047     +      var eventCount nonEventCount;
34048     +      class _variable_  _group_;
34049     +      output out=summ(where=(_type_ in(2,3))) sum=eventCount nonEventCount;
34050     +   run;
34052     +   proc sort data=summ(drop=_type_ _freq_);
34053     +     by _variable_ _group_;
34054     +   run;
34056     +   data gini(keep=_variable_ eventCount nonEventCount groupresprate)
34057     +        tempcoarse(keep=_variable_  _group_ eventCount nonEventCount groupresprate groupNonRespRate eventRate nonEventRate respper nrespper);
34058     +        set summ;
34059     +        *format groupresprate 6.2;
34060     +        *format groupnonresprate 6.2;
34061     +        by _variable_ ;
34062     +        if _group_=. then do;
34063     +        end;
34064     +        else do;
34065     +           respper = eventCount / &totalEvent;
34066     +           nrespper = nonEventCount / &totalNonEvent;
34068     +           if ((nonEventCount = 0) AND (eventCount = 0)) then do;
34069     +                groupresprate=0;
34070     +                groupNonresprate = 0;
34071     +                eventRate = 0;
34072     +                nonEventRate = 0;
34073     +           end;
34074     +           else do;
34075     +               groupresprate = eventCount / (eventCount + nonEventCount) ;
34076     +               groupNonRespRate = 1 - groupRespRate;
34077     +               eventRate = eventCount / &totalEvent ;
34078     +               nonEventRate = nonEventCount / &totalNonEvent ;
34079     +            end;
34081     +           output gini tempcoarse;
34083     +        end;
34084     +   run;
34085     +   proc sort data=gini;
34086     +      by _variable_ descending groupresprate;
34087     +   run;
34089     +   data gini(keep= _variable_ _gini_);
34090     +     retain between within cumresp cumnresp;
34091     +     set gini(keep=_variable_  eventCount nonEventCount);
34092     +     by _variable_;
34093     +     if first._variable_ then do;
34094     +       between  = 0;
34095     +       within   = 0;
34096     +       cumresp  = 0;
34097     +       cumnresp = 0;
34098     +     end;
34099     +     between + 2 * cumnresp * eventCount;
34100     +     within + nonEventCount * eventCount;
34101     +     cumresp + eventCount;
34102     +     cumnresp + nonEventCount;
34103     +     if last._variable_ then do;
34104     +       if ^(cumnresp=0 or cumresp=0) then do;
34105     +         _gini_ = 100 * (1 - (within + between) / (cumnresp * cumresp));
34106     +         output;
34107     +       end;
34108     +     end;
34109     +   run;
34111     +   data tempdisplayvar;
34112     +      set &EM_USER_VARMAPPINGS;
34113     +      rename _variable_ = display_var
34114     +      _proc_var_ = _variable_;
34115     +   keep _variable_ _proc_var_ label;
34116     +   run;
34117     +   proc sort data=tempdisplayvar; by _variable_; run;
34119     +   data  &COARSE;
34120     +     length display_Var $32 label _label_ $200 role $10 _group_ 8;
34121     +     merge tempdisplayvar tempcoarse gini ;
34122     +     by _variable_;
34123     +     label display_var = "%sysfunc(sasmsg(sashelp.dmine, rpt_variable_vlabel , NOQUOTE))"
34124     +           eventRate   = "%sysfunc(sasmsg(sashelp.dmine, rpt_eventrate_vlabel , NOQUOTE))"
34125     +           nonEventRate = "%sysfunc(sasmsg(sashelp.dmine, rpt_noneventrate_vlabel , NOQUOTE))"
34126     +           _group_    = "%sysfunc(sasmsg(sashelp.dmine, rpt_group_vlabel , NOQUOTE))"
34127     +           role       = "%sysfunc(sasmsg(sashelp.dmine, meta_role_vlabel , NOQUOTE))"
34128     +           _gini_     = "%sysfunc(sasmsg(sashelp.dmine, rpt_gini_vlabel  , NOQUOTE))"
34129     +           eventcount = "%sysfunc(sasmsg(sashelp.dmine, rpt_eventcount_vlabel  , NOQUOTE))"
34130     +           noneventcount = "%sysfunc(sasmsg(sashelp.dmine, rpt_noneventcount_vlabel  , NOQUOTE))"
34131     +           groupresprate = "%sysfunc(sasmsg(sashelp.dmine, rpt_groupresprate_vlabel  , NOQUOTE))"
34132     +           groupnonresprate = "%sysfunc(sasmsg(sashelp.dmine, rpt_groupnonresprate_vlabel  , NOQUOTE))"
34133     +           ;
34135     +    eventCount = round(eventCount, .001);
34136     +    nonEventCount = round(nonEventCount, .001);
34137     +    groupRespRate = round(groupRespRate, .001);
34139     +     drop _variable_ index index2 respper nrespper;
34140     +   run;
34142     +   proc datasets library=work nolist;
34143     +     delete  tempcoarse gini             ;
34145     +   run;
34146     +   quit;
34148     +%mend EM_CREATE_GROUPING;
34152     +%macro EM_GENERATE_LABELVALUES(filename, splitvals, binmappings, coarse);
34154     +         data _null_;
34155     +            FILE &filename;
34156     +            put " length _LABEL_ $200;";
34157     +            put ' label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";';
34158     +         run;
34160     +         proc sort data=&SPLITVALS out=work.sortedsplitval; by display_var _split_Value_; run;
34161     +         proc sort data=&BINMAPPINGS; by display_var bin; run;
34163     +         data temp;
34164     +           merge work.sortedsplitval(in=_a) &BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
34165     +           by Display_Var _Split_value_;
34166     +           if upcase(_Split_value_) ne 'MISSING';
34167     +           if _a then output;
34168     +           if display_var eq '' then delete;
34169     +         run;
34171     +         data temp_missing;
34172     +           merge work.sortedsplitval(in=_a rename=(_GROUP_=MISSGRP)) &BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
34173     +           by Display_Var _Split_value_;
34174     +           if upcase(_Split_value_) eq 'MISSING';
34175     +           if _a then output;
34176     +           keep _variable_ display_var missgrp;
34177     +         run;
34179     +         proc sort data=temp out=class;
34180     +            by _variable_ _group_ LB;
34181     +         run;
34183     +         data _null_;
34185     +            file &filename MOD;
34186     +            length string $200 flag 8;
34187     +            retain string flag;
34188     +            set class end=eof;
34189     +            by _variable_  _group_;
34191     +            index = kindex(_variable_, "BIN_");
34192     +            if index gt 0 then do;
34193     +              if first._group_ then do;
34194     +                flag = 0;
34195     +                if ^first._variable_ then
34196     +                    put 'else';
34197     +                 else
34198     +                    put ' ';
34200     +                 string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = "
34201     +                          !!strip(put(_GROUP_,best12.))!!' then do;';
34202     +                 put string;
34204     +                 if LB ne . then do;
34205     +                   * string = strip(string)!!" _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
34206     +                    string = " _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
34207     +                 end;
34208     +                 else do;
34209     +                    flag = 1;
34210     +                    *string = strip(string)!!" _LABEL_='"!!strip(DISPLAY_VAR);
34211     +                    string = " _LABEL_='"!!strip(DISPLAY_VAR);
34212     +                 end;
34214     +              end;
34215     +              if last._Group_ then do;
34216     +                 if UB ne . then do;
34217     +                    string = strip(string)!!'< '!!strip(UB)!!"';";
34218     +                 end;
34219     +                 else do;
34220     +                    if flag=1 then do;
34221     +                      string = strip(string)!!"';";
34222     +                     /* string = strip(string)!!'='!!strip(_split_Value_)!!"';";*/
34223     +                    end;
34224     +                    else do;
34225     +                      string = strip(string)!!"';";
34226     +                    end;
34227     +                 end;
34228     +                 put string;
34230     +                 string= " UB="!!strip(UB)!!";";
34231     +                 put string;
34232     +                 put "end;";
34235     +              end;
34236     +            end;
34237     +            else do;
34238     +              _split_value_ = tranwrd(_split_value_,"'","''");
34239     +              if first._group_ then do;
34240     +                 flag = 0;
34241     +                 if ^first._variable_ then
34242     +                    put 'else';
34243     +                 else
34244     +                    put ' ';
34245     +                 string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = "
34246     +                          !!strip(put(_GROUP_,best12.))!!' then';
34247     +                 put string;
34248     +                 string = "_LABEL_='"!!strip(_split_value_);
34249     +              end;
34250     +              else do;
34251     +                 if flag ne 1 then do;
34252     +                   tempstring = strip(string)!!', '!!strip(_split_value_);
34253     +                   length = length(tempstring);
34255     +                   if length < 195 then do;
34256     +                      string = tempstring;
34257     +                   end;
34258     +                   else do;
34259     +                      string = strip(string)||",...";
34260     +                      flag=1;
34261     +                   end;
34262     +                 end;
34263     +              end;
34265     +              if last._group_ then do;
34266     +                 string = strip(string)!!"';";
34267     +                 put string;
34268     +              end;
34269     +            end;
34270     +         run;
34272     +         data &COARSE;
34273     +           set &COARSE;
34274     +          /* %inc Y; */
34275     +           %inc &filename;
34276     +         run;
34277     +         *filename Y;
34279     +         /* add missing to appropriate label - based on temp_missing data */
34280     +         data &COARSE;
34281     +           set &COARSE;
34283     +           %let dsid = %sysfunc(open(work.temp_missing));
34284     +           %if &dsid %then %do;
34285     +              %let varnum = %sysfunc(VARNUM(&dsid, DISPLAY_VAR));
34286     +              %let grpnum = %sysfunc(VARNUM(&dsid, MISSGRP));
34288     +              %let obs = %sysfunc(fetch(&dsid));
34289     +              %do %while(&obs=0);
34290     +                 %let var = %sysfunc(getvarc(&dsid, &varnum));
34291     +                 %let grp = %sysfunc(getvarn(&dsid, &grpnum));
34293     +                 if DISPLAY_VAR = "&var" and _GROUP_ = &grp then do;
34294     +                   if _LABEL_ eq '' then do;
34295     +                     _LABEL_ = "Missing";
34296     +                   end;
34297     +                   else do;
34298     +                     _LABEL_ = strip(_LABEL_)!!", Missing";
34299     +                   end;
34300     +                 end;
34301     +                 %let obs = %sysfunc(fetch(&dsid));
34302     +              %end;
34303     +           %end;
34304     +           %if &dsid %then %let dsid = %sysfunc(close(&dsid));
34305     +           drop ub;
34306     +         run;
34308     +         proc datasets library=work nolist;
34309     +           delete class temp temp_missing;
34310     +         run;
34311     +         quit;
34313     +%mend EM_GENERATE_LABELVALUES;
34315     +%macro calcValidationCoarse(input, output, varmappings, resultsTable);
34318     +%mend calcValidationCoarse;
34321     +%macro EM_IBN_IntTargetTrans(inttgtvar,method,newlevels=binlevs);
34322     +/* macro for transforming interval target to binary */
34324     +   %if &method = CUTMEAN %then %do;
34325     +      proc sql noprint;
34326     +         %if %EM_FREQ ne %then %do;
34327     +            select sum(&inttgtvar * %EM_FREQ) / sum(%EM_FREQ)
34328     +         %end;
34329     +         %else %do;
34330     +            select mean(&inttgtvar)
34331     +         %end;
34332     +         into :ignbincut from &em_import_data;
34333     +      quit;
34334     +   %end;
34336     +   /* create binary target */
34337     +   data &EM_USER_NEWTRAIN;
34338     +      set &EM_IMPORT_DATA;
34339     +      %if &method = CUTUSER %then %do;
34340     +           %let ignbincut = &EM_PROPERTY_USERCUTVALUE;
34341     +      %end;
34342     +      if &inttgtvar = . then &IGNBinTarget = .;
34343     +      else do;
34344     +         if &inttgtvar > &ignbincut then &IGNBinTarget=1;
34345     +         else &IGNBinTarget=0;
34346     +      end;
34347     +   run;
34349     +   /* Check that new target is actually binary */
34350     +   proc sql noprint;
34351     +      select distinct &IGNBINTarget into :bintv1 - from &EM_USER_NEWTRAIN where &IGNBinTarget ne .;
34352     +   quit;
34353     +   %global &newlevels;
34354     +   %let &newlevels=&sqlobs;
34356     +%mend EM_IBN_IntTargetTrans;
NOTE: %INCLUDE (level 1) ending.
MPRINT(TRAIN):   filename trtemp;
NOTE: Fileref TRTEMP has been deassigned.
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(SETPROPERTIES):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data temp;
MPRINT(TRAIN):   set EMWS1.BINNING_VariableSet;
MPRINT(TRAIN):   where NAME =
MPRINT(TRAIN):  "BAD";
MPRINT(TRAIN):   run;

NOTE: There were 1 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE NAME='BAD';
NOTE: The data set WORK.TEMP has 1 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc dmdb data=EMWS1.Trans_TRAIN(where=(^missing(
MPRINT(EM_BINARY_TARGET):  BAD
MPRINT(TRAIN):  ))) classout=EVENTOUT;
MPRINT(TRAIN):   target
MPRINT(EM_BINARY_TARGET):   BAD
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   class
MPRINT(EM_BINARY_TARGET):   BAD
MPRINT(TRAIN):  (DESC);
MPRINT(TRAIN):   run;

NOTE: Records processed = 2382   Memory used = 511K.
NOTE: View EMWS1.TRANS_TRAIN.VIEW used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      
NOTE: There were 2382 observations read from the data set EMWS1.PART_TRAIN.
NOTE: There were 2382 observations read from the data set EMWS1.TRANS_TRAIN.
      WHERE not MISSING(BAD);
NOTE: The data set WORK.EVENTOUT has 2 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.06 seconds
      cpu time            0.04 seconds
      

MPRINT(TRAIN):   data _null_;
MPRINT(TRAIN):   dsid = open("EVENTOUT");
MPRINT(TRAIN):   if dsid>0 then do;
MPRINT(TRAIN):   levelnum = VARNUM(dsid, "LEVEL");
MPRINT(TRAIN):   if levelnum then do;
MPRINT(TRAIN):   if ^fetch(dsid) then call symput('TARGET_EVENT', strip(getvarc(dsid, levelnum)));
MPRINT(TRAIN):   if ^fetch(dsid) then call symput('TARGET_NONEVENT',strip(getvarc(dsid, levelnum)));
MPRINT(TRAIN):   end;
MPRINT(TRAIN):   dsid=close(dsid);
MPRINT(TRAIN):   end;
MPRINT(TRAIN):   run;

NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc datasets library=work nolist;
MPRINT(TRAIN):   delete eventout;
MPRINT(TRAIN):   run;

NOTE: Deleting WORK.EVENTOUT (memtype=DATA).
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   data EMWS1.BINNING_NEWTRAIN;
MPRINT(TRAIN):   set EMWS1.Trans_TRAIN;
MPRINT(TRAIN):   run;

NOTE: View EMWS1.TRANS_TRAIN.VIEW used (Total process time):
      real time           0.07 seconds
      cpu time            0.06 seconds
      
NOTE: There were 2382 observations read from the data set EMWS1.PART_TRAIN.
NOTE: There were 2382 observations read from the data set EMWS1.TRANS_TRAIN.
NOTE: The data set EMWS1.BINNING_NEWTRAIN has 2382 observations and 25 variables.
NOTE: DATA statement used (Total process time):
      real time           0.14 seconds
      cpu time            0.07 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data tempvarnames;
MPRINT(TRAIN):   set EMWS1.BINNING_VariableSet;
MPRINT(TRAIN):   where ((ROLE='INPUT' and USE in('Y', 'D')) or (ROLE='REJECTED' and USE='Y')) and level ne 'UNARY';
MPRINT(TRAIN):   keep NAME LEVEL LABEL;
MPRINT(TRAIN):   run;

NOTE: There were 14 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y'))) and (level not = 'UNARY');
NOTE: The data set WORK.TEMPVARNAMES has 14 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc dmdb data=tempvarnames outtable=tempmapping nameserver;
MPRINT(TRAIN):   names NAME;
MPRINT(TRAIN):   prefix WOE_ GRP_ ;
MPRINT(TRAIN):   run;

NOTE: There were 14 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPMAPPING has 14 observations and 3 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sort data=tempmapping;
MPRINT(TRAIN):   by name;
MPRINT(TRAIN):   run;

NOTE: There were 14 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPMAPPING has 14 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   proc sort data=tempvarnames;
MPRINT(TRAIN):   by name;
MPRINT(TRAIN):   run;

NOTE: There were 14 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPVARNAMES has 14 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):   data tempmapping;
MPRINT(TRAIN):   merge tempmapping tempvarnames;
MPRINT(TRAIN):   by NAME;
MPRINT(TRAIN):   rename LEVEL=procLevel;
MPRINT(TRAIN):   run;

NOTE: There were 14 observations read from the data set WORK.TEMPMAPPING.
NOTE: There were 14 observations read from the data set WORK.TEMPVARNAMES.
NOTE: The data set WORK.TEMPMAPPING has 14 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_GENERATE_MAPPING_TABLE):  ;
MPRINT(EM_GENERATE_MAPPING_TABLE):   data EMWS1.BINNING_VARMAPPINGS(keep=_variable_ _grp_variable_ procLevel label);
MPRINT(EM_GENERATE_MAPPING_TABLE):   length _variable_ _grp_variable_ $32 procLevel $8;
MPRINT(EM_GENERATE_MAPPING_TABLE):   set tempmapping;
MPRINT(EM_GENERATE_MAPPING_TABLE):   label _variable_ = "Input Variable" _grp_variable_ = "Group Variable";
MPRINT(EM_GENERATE_MAPPING_TABLE):   _variable_ = NAME;
MPRINT(EM_GENERATE_MAPPING_TABLE):   _grp_variable_ = GRP;
MPRINT(EM_GENERATE_MAPPING_TABLE):   run;

NOTE: There were 14 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set EMWS1.BINNING_VARMAPPINGS has 14 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.09 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc datasets library=work nolist;
MPRINT(TRAIN):   delete tempImport tempScore;
MPRINT(TRAIN):   run;

NOTE: The file WORK.TEMPIMPORT (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.TEMPSCORE (memtype=DATA) was not found, but appears on a DELETE statement.
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   data tempvariableset;
MPRINT(EM_PRE_BINNING):   set EMWS1.BINNING_VariableSet;
MPRINT(EM_PRE_BINNING):   where LEVEL = 'INTERVAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 12 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (LEVEL='INTERVAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 12 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_ '' maxvar 0;
MPRINT(EM_VARMACRO):   set tempvariableset end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   maxvar +1;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 4 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' "'!!trim(NAME)!!'"n';
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = '"'!!TRIM(NAME)!!'"n';
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intervalvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=4,
      Created=Thu, Oct 25, 2018 11:41:37 PM,
      Last Modified=Thu, Oct 25, 2018 11:41:37 PM,
      Filename=C:\Users\jmmorr01\AppData\Local\Temp\SAS Temporary Files\_TD2096_COB-MBA021_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M3,Host Created=X64_8PRO

NOTE: 6 records were written to the file MACFILE.
      The minimum record length was 19.
      The maximum record length was 76.
NOTE: There were 12 observations read from the data set WORK.TEMPVARIABLESET.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
34361     +%macro intervalvars;
34362     +"INDELINQ"n "INDEROG"n "LOG_CLAGE"n "LOG_CLNO"n "LOG_DEBTINC"n "LOG_DELINQ"n
34363     +"LOG_DEROG"n "LOG_LOAN"n "LOG_MORTDUE"n "LOG_VALUE"n "LOG_YOJ"n "NINQ"n
34364     +%mend intervalvars;
34365     +%global num_intvars;
34366     +%let num_intvars = 12 ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_PRE_BINNING):  ;
MPRINT(EM_PRE_BINNING):   proc dmdb data=EMWS1.BINNING_NEWTRAIN classout=_CLASSOUT maxlevel=5;
MPRINT(EM_PRE_BINNING):   class
MPRINT(INTERVALVARS):   "INDELINQ"n "INDEROG"n "LOG_CLAGE"n "LOG_CLNO"n "LOG_DEBTINC"n "LOG_DELINQ"n "LOG_DEROG"n "LOG_LOAN"n "LOG_MORTDUE"n "LOG_VALUE"n "LOG_YOJ"n
MPRINT(EM_PRE_BINNING):   "NINQ"n;
MPRINT(EM_PRE_BINNING):   run;

NOTE: Records processed = 2382   Memory used = 511K.
NOTE: There were 2382 observations read from the data set EMWS1.BINNING_NEWTRAIN.
NOTE: The data set WORK._CLASSOUT has 54 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.03 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   proc freq data=_CLASSOUT order=DATA noprint;
MPRINT(EM_PRE_BINNING):   table NAME / OUT= _COUNT(where=(COUNT<5));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 54 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._COUNT has 2 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   data _null_;
MPRINT(EM_PRE_BINNING):   set _COUNT;
MPRINT(EM_PRE_BINNING):   call symput('_INTBINS',symget('_INTBINS') !! ' ' !! ktrim(kleft(NAME)));
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 2 observations read from the data set WORK._COUNT.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   proc sort data=_CLASSOUT;
MPRINT(EM_PRE_BINNING):   by NAME;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 54 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._CLASSOUT has 54 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   proc transpose data=_CLASSOUT out=_OUT(DROP=_NAME_ RENAME=(NAME=VARIABLE)) prefix=_MIDPOINT;
MPRINT(EM_PRE_BINNING):   var NRAW;
MPRINT(EM_PRE_BINNING):   by NAME;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 54 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._OUT has 12 observations and 6 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_PRE_BINNING):   data _null_;
MPRINT(EM_PRE_BINNING):   dsid = open('_OUT');
MPRINT(EM_PRE_BINNING):   if dsid then do;
MPRINT(EM_PRE_BINNING):   call symput('NUMCLASSBARS', kleft(ktrim(put(attrn(dsid, 'NVARS')-1, best12.))));
MPRINT(EM_PRE_BINNING):   csid = close(dsid);
MPRINT(EM_PRE_BINNING):   end;
MPRINT(EM_PRE_BINNING):   run;

NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRE_BINNING):   data _INTMID;
MPRINT(EM_PRE_BINNING):   set _OUT;
MPRINT(EM_PRE_BINNING):   keep VARIABLE _MIDPOINT1--_MIDPOINT5 ;
MPRINT(EM_PRE_BINNING):   run;

NOTE: There were 12 observations read from the data set WORK._OUT.
NOTE: The data set WORK._INTMID has 12 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   data EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   set EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   label procLevel = "Level for Interactive";
MPRINT(TRAIN):   run;

NOTE: There were 14 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set EMWS1.BINNING_VARMAPPINGS has 14 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.10 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename temp catalog 'sashelp.emapps.quantile_binning.source';
NOTE: %INCLUDE (level 1) file TEMP is file SASHELP.EMAPPS.QUANTILE_BINNING.SOURCE.
34368     +%macro em_apps_quantile_binning(input, vartable, numbins, binmappings, binningCode, codeMappings=, precision=0.01, dropOriginal=N, IncludeTarget=N);
34370     +  /* initialize binmappings table */
34371     +  data &BINMAPPINGS;
34372     +    length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
34373     +  run;
34377     +  %if &IncludeTarget=N %then %do;
34378     +   /* process only INTERVAL INPUTS */
34379     +  data tempvars;
34380     +    set &vartable(where=(ROLE="INPUT" AND LEVEL="INTERVAL"));
34381     +  run;
34382     +  %end;
34384     +  %if &IncludeTarget=Y %then %do;
34385     +   /* process both INTERVAL INPUTS and INTERVAL TARGETS*/
34386     +  data tempvars;
34387     +    set &vartable(where=((ROLE="INPUT" AND LEVEL="INTERVAL") or (ROLE="TARGET" AND LEVEL="INTERVAL")));
34388     +  run;
34389     +  %end;
34391     +  /* retrieve the name of interval inputs to bin */
34392     +  filename tempopen catalog 'sashelp.emutil.em_varmacro.source';
34393     +  %include tempopen;
34394     +  filename tempopen;
34396     +  %let intvars = ;
34397     +  %global num_intvars;
34398     +  %let num_intvars = 0;
34399     +  %em_varmacro(name=intvars, metadata=tempvars, key=NAME, nummacro=num_intvars);
34401     +  /* retrieve the name of frequency variable if it exists */
34402     +  %let em_bin_freq = ;
34403     +  %let choice = ROLE="FREQ";
34404     +  %let fdsid = %sysfunc(open(&vartable(where=(&choice))));
34405     +  %if &fdsid %then %do;
34406     +    %let fvarnum = %sysfunc(VARNUM(&fdsid, NAME));
34407     +    %let fobs = %sysfunc(fetch(&fdsid));
34408     +    %do %while(&fobs=0);
34409     +       %let em_bin_freq = %sysfunc(getvarc(&fdsid, &fvarnum));
34410     +       %let fobs = %sysfunc(fetch(&fdsid));
34411     +    %end;
34412     +  %end;
34413     +  %if &fdsid >0 %then %let fdsid = %sysfunc(close(&fdsid));
34415     +  /* process all inputs */
34416     +  %if &num_intvars > 0 %then %do;
34418     +    /* Computing quantile binning of interval inputs */
34419     +    %let numbin = %eval(&NUMBINS - 1);
34420     +    %let optstr=;
34421     +    %do i=1 %to &numbin;
34422     +       %let optstr = &optstr %sysevalf(&i*100/&&NUMBINS);
34423     +    %end;
34425     +    data tempInt / view = tempInt;
34426     +      set &input(keep= %intvars
34427     +      %if &em_bin_freq ne %then %do;
34428     +        &em_bin_freq
34429     +      %end;
34430     +      );
34431     +    run;
34433     +    proc stdize data=work.tempInt outstat=work.pctdata out=_null_ pctlpts=&optstr;
34434     +       var %intvars;
34435     +       %if &em_bin_freq ne %then %do;
34436     +          freq &em_bin_freq / notrunc;
34437     +       %end;
34438     +    run;
34440     +    proc transpose data=work.pctdata(where=(_type_=:'P')) out=work.pctdata;
34441     +    run;
34443     +    /* generate unique BIN_xxx names for all inputs processed */
34444     +    proc dmdb data=tempvars outtable=tempmapping nameserver;
34445     +     names NAME;
34446     +     prefix BIN_ ;
34447     +    run;
34449     +    proc sort data=tempmapping(keep=NAME bin); by NAME; run;
34450     +    proc sort data=work.pctdata; by _NAME_; run;
34451     +    %if ((&codemappings ne ) and (%sysfunc(exist(&codemappings, data)))) %then %do;
34452     +      proc sort data=&codemappings nodupkey out=tempcodemappings(keep= codeVar variable) ; by codeVar; run;
34453     +    %end;
34455     +    data tempbins;
34456     +      length display_var $32;
34457     +      merge work.pctdata(in=_a) tempmapping(rename=(name=_name_ bin=binVar))
34458     +      %if ((&codemappings ne ) and (%sysfunc(exist(&codemappings, data)))) %then %do;
34459     +         tempcodemappings(rename=(codeVar=_name_ variable=display_var))
34460     +      %end;
34461     +      ;
34462     +      by _NAME_;
34463     +      if _a;
34464     +      if missing(display_var) then display_var = _NAME_;
34465     +    run;
34467     +    /* generate BINMAPPINGS dataset and binningCode file*/
34468     +    data _null_;
34469     +      FILE &binningCode;
34470     +      set tempbins end=eof;
34471     +      length string $200;
34472     +      by _NAME_;
34474     +      if _n_=1 then do;
34475     +        put "&EM_CODEBAR;";
34476     +        %let note = %sysfunc(sasmsg(sashelp.dmine, generatebins_note, NOQUOTE));
34477     +        put "* &note;";
34478     +        put "&EM_CODEBAR;";
34480     +        call execute(" data &BINMAPPINGS; ");
34481     +        call execute("   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;");
34482     +      end;
34484     +      %do i=1 %to %eval(&numbins-1);
34485     +       %if &i eq 1 %then %do;
34486     +         %let colname = COL&i;
34487     +         %let binvalnum = 1;
34488     +         LB = .;
34489     +         UB = round(&colname, &precision);
34490     +         bin=&binvalnum;
34492     +         call execute("name='"||strip(_NAME_)||"'; ");
34493     +         call execute("bin_name='"||strip(binVar)||"'; ");
34494     +         call execute("bin='"||strip(bin)||"';");
34495     +         call execute("LB=.;");
34496     +         call execute("UB="||UB||";");
34497     +         call execute("EM_BIN_LABEL='"||strip(display_var)||" < "||strip(UB)||"';");
34498     +         call execute("output;");
34500     +         string = "if "||strip(_name_)||" eq . then "||strip(binVar)||"= .;";
34502     +         put string;
34503     +         string = "else do;";
34504     +         put string;
34506     +         string= "  if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
34507     +         put string;
34510     +       %end;
34511     +       %else %do;
34512     +         %let colname = COL&i;
34513     +         %let lbnum = %sysevalf(&i-1);
34514     +         %let lbcol = COL&lbnum;
34515     +         UB = round(&colname, &precision);
34516     +         LB = round(&lbcol, &precision);
34517     +         if UB ne LB then do;
34518     +           bin=bin+1;
34520     +           call execute("name='"||strip(_NAME_)||"'; ");
34521     +           call execute("bin_name='"||strip(binVar)||"'; ");
34522     +           call execute("bin='"||strip(bin)||"';");
34523     +           call execute("LB="||LB||";");
34524     +           call execute("UB="||UB||";");
34525     +           call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" < "||strip(UB)||"';");
34526     +           call execute("output;");
34528     +           string= "  else if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
34529     +           put string;
34531     +         end;
34532     +       %end;
34533     +      %end;
34534     +      %let binvalnum = %sysevalf(&binvalnum + 1);
34535     +      bin=bin+1;
34536     +      LB = round(&colname, &precision);
34537     +      UB = .;
34539     +      call execute("name='"||strip(_NAME_)||"'; ");
34540     +      call execute("bin_name = '"||strip(binVar)||"'; ");
34541     +      call execute("bin='"||strip(bin)||"';");
34542     +      call execute("UB=.;");
34543     +      call execute("LB="||LB||";");
34544     +      call execute("EM_BIN_LABEL='"||strip(display_Var)||" >= "||strip(LB)||"';");
34545     +      call execute("output;");
34547     +      string= "  else if "||strip(_name_)||" >= "||strip(LB)||" then "||strip(binVar)||"="||strip(bin)||";";
34548     +      put string;
34549     +      string="end;";
34550     +      put string;
34552     +      if eof then do;
34553     +        call execute("  if NAME='' and BIN_NAME='' and BIN='' then delete;");
34554     +        call execute("  if LB=UB then delete;");
34555     +        call execute("run;");
34556     +      end;
34558     +    run;
The SAS System

34560     +    /* drop original inputs */
34561     +    %if &dropOriginal=Y %then %do;
34562     +      data _null_;
34563     +        set work.tempvars end=eof;
34564     +        FILE &binningCode MOD;
34565     +        length string $200;
34567     +        if _n_=1 then do;
34568     +          put "drop";
34569     +        end;
34570     +        string = " "||strip(name);
34571     +        put string;
34573     +        if eof then do;
34574     +          put ";";
34575     +        end;
34576     +      run;
34577     +    %end;
34579     +    proc datasets library=work nolist;
34580     +      delete pctdata tempmapping tempbins tempInt;
34581     +    run;
34582     +    quit;
34583     +  %end;
34585     +  proc datasets library=work nolist;
34586     +    delete tempvars;
34587     +  run;
34588     +  quit;
34590     +%mend em_apps_quantile_binning;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_QUANTILE_BINNING):   filename temp;
NOTE: Fileref TEMP has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   filename X "J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\BINNINGCODE.sas";
MPRINT(EM_QUANTILE_BINNING):   data work.vartable;
MPRINT(EM_QUANTILE_BINNING):   set work._intmid;
MPRINT(EM_QUANTILE_BINNING):   level = "INTERVAL";
MPRINT(EM_QUANTILE_BINNING):   role = "INPUT";
MPRINT(EM_QUANTILE_BINNING):   rename variable=name;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 12 observations read from the data set WORK._INTMID.
NOTE: The data set WORK.VARTABLE has 12 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_APPS_QUANTILE_BINNING):   length NAME BIN_NAME $32 LB UB 8 BIN EM_BIN_LABEL $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Variable NAME is uninitialized.
NOTE: Variable BIN_NAME is uninitialized.
NOTE: Variable LB is uninitialized.
NOTE: Variable UB is uninitialized.
NOTE: Variable BIN is uninitialized.
NOTE: Variable EM_BIN_LABEL is uninitialized.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 1 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.09 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data tempvars;
MPRINT(EM_APPS_QUANTILE_BINNING):   set work.vartable(where=(ROLE="INPUT" AND LEVEL="INTERVAL"));
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 12 observations read from the data set WORK.VARTABLE.
      WHERE (ROLE='INPUT') and (LEVEL='INTERVAL');
NOTE: The data set WORK.TEMPVARS has 12 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   filename tempopen catalog 'sashelp.emutil.em_varmacro.source';
NOTE: %INCLUDE (level 1) file TEMPOPEN is file SASHELP.EMUTIL.EM_VARMACRO.SOURCE.
34595     +%macro em_varMacro(name=emMacro, metadata=, where=, key=NAME, nummacro=, maxvar=-1);
34597     +   filename macFile catalog 'work.emutil.macro.source';
34598     +   %let _METAOBS = 0;
34599     +   %let _maxvar = &maxvar;
34600     +   %if "&_maxvar" eq "" %then %let maxvar = -1;
34602     +   %if (%sysfunc(exist(&metadata))<1 and %sysfunc(exist(&metadata, VIEW))<1)
34603     +                   or (&metadata eq ) %then %do;
34604     +       %put * No metadata data set defined;
34605     +       %goto doend;
34606     +   %end;
34608     +   data _null_;
34609     +      length _STRING_ $80;
34610     +      retain _STRING_ '' maxvar 0;
34611     +      set &metadata end=eof;
34612     +      file macFile;
34613     +      %if %nrbquote(&where) ne %then %do;
34614     +          %let whereClause = where (%nrbquote(&where));
34615     +          %unquote(&whereClause);
34616     +      %end;
34617     +      if _N_=1 then do;
34618     +         string = "%"!!"macro &name;";
34619     +         put string;
34620     +      end;
34621     +      maxvar +1;
34622     +      if (length(_STRING_) + length(trim(&key))+ 4 < 80) then do;
34623     +         _STRING_ = trim(_STRING_)!!' '!!trim(&key);
34624     +         if eof
34625     +            %if  %sysevalf(&_maxvar > 0) %then %do;
34626     +                or maxvar >= &maxvar
34627     +            %end;
34628     +            then do;
34629     +            put _STRING_;
34630     +            string = "%"!!"mend &name;";
34631     +            put string;
34632     +            string = strip(put(_N_, best.));
34633     +            call symput('_METAOBS', string);
34634     +            %if (&nummacro ne ) %then %do;
34635     +                put "%" "global &nummacro;";
34636     +                put "%" "let &nummacro = " string ";";
34637     +            %end;
34638     +            stop;
34639     +         end;
34640     +      end;
34641     +      else do;
34642     +         put _STRING_;
34643     +         _string_ = TRIM(&key);
34644     +         if eof
34645     +            %if  %sysevalf(&_maxvar > 0) %then %do;
34646     +              or maxvar >= &maxvar
34647     +           %end;
34648     +            then do;
34649     +            put _STRING_;
34650     +            string = "%"!!"mend &name;";
34651     +            put string;
34652     +        end;
34653     +      end;
34654     +      if eof
34655     +         %if  %sysevalf(&_maxvar > 0) %then %do;
34656     +             or maxvar >= &maxvar
34657     +         %end;
34658     +         then do;
34659     +         string = strip(put(_N_, best.));
34660     +         call symput('_METAOBS', string);
34661     +         %if (&nummacro ne ) %then %do;
34662     +             put "%" "global &nummacro;";
34663     +             put "%" "let &nummacro = " string ";";
34664     +         %end;
34665     +         stop;
34666     +      end;
34667     +   run;
34669     +   %doend:
34670     +   %if ^&_METAOBS %then %do;
34671     +       data _null_;
34672     +          file macFile;
34673     +          put "%" "macro &name;";
34674     +          put "%" "mend &name;";
34675     +          %if (&nummacro ne ) %then %do;
34676     +              put "%" "global &nummacro;";
34677     +              put "%" "let &nummacro = 0;";
34678     +          %end;
34679     +      run;
34680     +   %end;
34681     +   %inc macFile;
34682     +   filename macFile;
34683     +%mend em_varMacro;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_APPS_QUANTILE_BINNING):   filename tempopen;
NOTE: Fileref TEMPOPEN has been deassigned.
MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_ '' maxvar 0;
MPRINT(EM_VARMACRO):   set tempvars end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   maxvar +1;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 4 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' '!!trim(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = TRIM(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend intvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_intvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_intvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=Thu, Oct 25, 2018 11:41:37 PM,
      Last Modified=Thu, Oct 25, 2018 11:41:37 PM,
      Filename=C:\Users\jmmorr01\AppData\Local\Temp\SAS Temporary Files\_TD2096_COB-MBA021_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M3,Host Created=X64_8PRO

NOTE: 6 records were written to the file MACFILE.
      The minimum record length was 14.
      The maximum record length was 68.
NOTE: There were 12 observations read from the data set WORK.TEMPVARS.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
34684     +%macro intvars;
34685     +INDELINQ INDEROG LOG_CLAGE LOG_CLNO LOG_DEBTINC LOG_DELINQ LOG_DEROG
34686     +LOG_LOAN LOG_MORTDUE LOG_VALUE LOG_YOJ NINQ
34687     +%mend intvars;
34688     +%global num_intvars;
34689     +%let num_intvars = 12 ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_APPS_QUANTILE_BINNING):  ;
MPRINT(EM_APPS_QUANTILE_BINNING):   data tempInt / view = tempInt;
MPRINT(EM_APPS_QUANTILE_BINNING):   set EMWS1.BINNING_NEWTRAIN(keep
MPRINT(EM_APPS_QUANTILE_BINNING):  = INDELINQ INDEROG LOG_CLAGE LOG_CLNO LOG_DEBTINC LOG_DELINQ LOG_DEROG LOG_LOAN LOG_MORTDUE LOG_VALUE LOG_YOJ NINQ );
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: DATA STEP view saved on file WORK.TEMPINT.
NOTE: A stored DATA STEP view cannot run under a different operating system.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc stdize data=work.tempInt outstat=work.pctdata out=_null_ pctlpts=25 50 75;
MPRINT(EM_APPS_QUANTILE_BINNING):   var
MPRINT(INTVARS):   INDELINQ INDEROG LOG_CLAGE LOG_CLNO LOG_DEBTINC LOG_DELINQ LOG_DEROG LOG_LOAN LOG_MORTDUE LOG_VALUE LOG_YOJ NINQ
MPRINT(EM_APPS_QUANTILE_BINNING):  ;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: View WORK.TEMPINT.VIEW used (Total process time):
      real time           0.12 seconds
      cpu time            0.11 seconds
      
NOTE: There were 2382 observations read from the data set EMWS1.BINNING_NEWTRAIN.
NOTE: There were 2382 observations read from the data set WORK.TEMPINT.
NOTE: The data set WORK.PCTDATA has 11 observations and 13 variables.
NOTE: PROCEDURE STDIZE used (Total process time):
      real time           0.15 seconds
      cpu time            0.11 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc transpose data=work.pctdata(where=(_type_=:'P')) out=work.pctdata;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 3 observations read from the data set WORK.PCTDATA.
      WHERE _type_=:'P';
NOTE: The data set WORK.PCTDATA has 12 observations and 5 variables.
NOTE: PROCEDURE TRANSPOSE used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc dmdb data=tempvars outtable=tempmapping nameserver;
MPRINT(EM_APPS_QUANTILE_BINNING):   names NAME;
MPRINT(EM_APPS_QUANTILE_BINNING):   prefix BIN_ ;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 12 observations read from the data set WORK.TEMPVARS.
NOTE: The data set WORK.TEMPMAPPING has 12 observations and 2 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc sort data=tempmapping(keep=NAME bin);
MPRINT(EM_APPS_QUANTILE_BINNING):   by NAME;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 12 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPMAPPING has 12 observations and 2 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc sort data=work.pctdata;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: There were 12 observations read from the data set WORK.PCTDATA.
NOTE: The data set WORK.PCTDATA has 12 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data tempbins;
MPRINT(EM_APPS_QUANTILE_BINNING):   length display_var $32;
MPRINT(EM_APPS_QUANTILE_BINNING):   merge work.pctdata(in=_a) tempmapping(rename=(name=_name_ bin=binVar)) ;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _a;
MPRINT(EM_APPS_QUANTILE_BINNING):   if missing(display_var) then display_var = _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

WARNING: Multiple lengths were specified for the BY variable _NAME_ by input data sets. This might cause unexpected results.
NOTE: There were 12 observations read from the data set WORK.PCTDATA.
NOTE: There were 12 observations read from the data set WORK.TEMPMAPPING.
NOTE: The data set WORK.TEMPBINS has 12 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data _null_;
MPRINT(EM_APPS_QUANTILE_BINNING):   FILE X;
MPRINT(EM_APPS_QUANTILE_BINNING):   set tempbins end=eof;
MPRINT(EM_APPS_QUANTILE_BINNING):   length string $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   by _NAME_;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _n_=1 then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put "*------------------------------------------------------------*;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put "* Generating Bins for interval variables;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put "*------------------------------------------------------------*;";
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute(" data EMWS1.BINNING_BINMAPPINGS; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;");
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = .;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL1, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB=.;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(display_var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string = "if "||strip(_name_)||" eq . then "||strip(binVar)||"= .;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string = "else do;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL2, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL1, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   if UB ne LB then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = round(COL3, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL2, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   if UB ne LB then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name='"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB="||UB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(LB)||" <= "||strip(display_Var)||" < "||strip(UB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" < "||strip(UB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   bin=bin+1;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB = round(COL3, 1 / 100);
MPRINT(EM_APPS_QUANTILE_BINNING):   UB = .;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("name='"||strip(_NAME_)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin_name = '"||strip(binVar)||"'; ");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("bin='"||strip(bin)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("UB=.;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("LB="||LB||";");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("EM_BIN_LABEL='"||strip(display_Var)||" >= "||strip(LB)||"';");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("output;");
MPRINT(EM_APPS_QUANTILE_BINNING):   string= "  else if "||strip(_name_)||" >= "||strip(LB)||" then "||strip(binVar)||"="||strip(bin)||";";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   string="end;";
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   if eof then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("  if NAME='' and BIN_NAME='' and BIN='' then delete;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("  if LB=UB then delete;");
MPRINT(EM_APPS_QUANTILE_BINNING):   call execute("run;");
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      216:110   222:129   225:166   254:48    254:89    283:110   286:111   289:122   292:139   292:185   303:44    303:85    337:110   340:111   343:122   346:139   346:185   357:44    357:85    388:108   394:129   397:167   407:45    407:86    
NOTE: The file X is:
      Filename=J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\BINNINGCODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=25Oct2018:23:41:37,
      Create Time=25Oct2018:23:41:37

MPRINT(EM_APPS_QUANTILE_BINNING):   data EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_APPS_QUANTILE_BINNING):   length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='INDELINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_INDELINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='INDELINQ < 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='INDELINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_INDELINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='INDELINQ >= 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='INDEROG';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_INDEROG';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='INDEROG < 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='INDEROG';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_INDEROG';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='INDEROG >= 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 4.77;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_CLAGE < 4.77';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 4.77;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 5.17;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='4.77 <= LOG_CLAGE < 5.17';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 5.17;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 5.46;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='5.17 <= LOG_CLAGE < 5.46';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_CLAGE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 5.46;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_CLAGE >= 5.46';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 2.71;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_CLNO < 2.71';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 2.71;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 3.04;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='2.71 <= LOG_CLNO < 3.04';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 3.04;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 3.3;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='3.04 <= LOG_CLNO < 3.3';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_CLNO';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 3.3;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_CLNO >= 3.3';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 3.4;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_DEBTINC < 3.4';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 3.4;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 3.58;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='3.4 <= LOG_DEBTINC < 3.58';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 3.58;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 3.69;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='3.58 <= LOG_DEBTINC < 3.69';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_DEBTINC';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 3.69;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_DEBTINC >= 3.69';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_DELINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_DELINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_DELINQ < 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_DELINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_DELINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_DELINQ >= 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_DEROG';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_DEROG';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_DEROG < 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_DEROG';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_DEROG';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_DEROG >= 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 9.32;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_LOAN < 9.32';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 9.32;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 9.7;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='9.32 <= LOG_LOAN < 9.7';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 9.7;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 10.06;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='9.7 <= LOG_LOAN < 10.06';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_LOAN';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 10.06;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_LOAN >= 10.06';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 10.74;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_MORTDUE < 10.74';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 10.74;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 11.07;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='10.74 <= LOG_MORTDUE < 11.07';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 11.07;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 11.44;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='11.07 <= LOG_MORTDUE < 11.44';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_MORTDUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 11.44;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_MORTDUE >= 11.44';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 11.1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_VALUE < 11.1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 11.1;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 11.4;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='11.1 <= LOG_VALUE < 11.4';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 11.4;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 11.71;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='11.4 <= LOG_VALUE < 11.71';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_VALUE';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 11.71;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_VALUE >= 11.71';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1.39;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_YOJ < 1.39';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1.39;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 2.08;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='1.39 <= LOG_YOJ < 2.08';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_LOG_YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 2.08;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 2.64;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='2.08 <= LOG_YOJ < 2.64';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='LOG_YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_LOG_YOJ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 2.64;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='LOG_YOJ >= 2.64';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='NINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_NINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='1';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='NINQ < 0';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='NINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_NINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='2';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 0;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='0 <= NINQ < 1';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='NINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name='BIN_NINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='3';
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 1;
MPRINT(EM_APPS_QUANTILE_BINNING):   UB= 2;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='1 <= NINQ < 2';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   name='NINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin_name = 'BIN_NINQ';
MPRINT(EM_APPS_QUANTILE_BINNING):   bin='4';
MPRINT(EM_APPS_QUANTILE_BINNING):   UB=.;
MPRINT(EM_APPS_QUANTILE_BINNING):   LB= 2;
MPRINT(EM_APPS_QUANTILE_BINNING):   EM_BIN_LABEL='NINQ >= 2';
MPRINT(EM_APPS_QUANTILE_BINNING):   output;
MPRINT(EM_APPS_QUANTILE_BINNING):   if NAME='' and BIN_NAME='' and BIN='' then delete;
MPRINT(EM_APPS_QUANTILE_BINNING):   if LB=UB then delete;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;
NOTE: 79 records were written to the file X.
      The minimum record length was 4.
      The maximum record length was 63.
NOTE: There were 12 observations read from the data set WORK.TEMPBINS.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.01 seconds
      

NOTE: CALL EXECUTE generated line.
1         +  data EMWS1.BINNING_BINMAPPINGS;
2         +    length name bin_name $32 LB UB 8 EM_BIN_LABEL BIN $200;
MPRINT(EM_APPS_QUANTILE_BINNING):  32 LB UB EM_BIN_LABEL BIN200
3         + name='INDELINQ';
4         + bin_name='BIN_INDELINQ';
5         + bin='1';
6         + LB=.;
7         + UB=           0;
8         + EM_BIN_LABEL='INDELINQ < 0';
9         + output;
10        + name='INDELINQ';
11        + bin_name = 'BIN_INDELINQ';
12        + bin='2';
13        + UB=.;
14        + LB=           0;
15        + EM_BIN_LABEL='INDELINQ >= 0';
16        + output;
17        + name='INDEROG';
18        + bin_name='BIN_INDEROG';
19        + bin='1';
20        + LB=.;
21        + UB=           0;
22        + EM_BIN_LABEL='INDEROG < 0';
23        + output;
24        + name='INDEROG';
25        + bin_name = 'BIN_INDEROG';
26        + bin='2';
27        + UB=.;
28        + LB=           0;
29        + EM_BIN_LABEL='INDEROG >= 0';
30        + output;
31        + name='LOG_CLAGE';
32        + bin_name='BIN_LOG_CLAGE';
33        + bin='1';
34        + LB=.;
35        + UB=        4.77;
36        + EM_BIN_LABEL='LOG_CLAGE < 4.77';
37        + output;
38        + name='LOG_CLAGE';
39        + bin_name='BIN_LOG_CLAGE';
40        + bin='2';
41        + LB=        4.77;
42        + UB=        5.17;
43        + EM_BIN_LABEL='4.77 <= LOG_CLAGE < 5.17';
44        + output;
45        + name='LOG_CLAGE';
46        + bin_name='BIN_LOG_CLAGE';
47        + bin='3';
48        + LB=        5.17;
49        + UB=        5.46;
50        + EM_BIN_LABEL='5.17 <= LOG_CLAGE < 5.46';
51        + output;
52        + name='LOG_CLAGE';
53        + bin_name = 'BIN_LOG_CLAGE';
54        + bin='4';
55        + UB=.;
56        + LB=        5.46;
57        + EM_BIN_LABEL='LOG_CLAGE >= 5.46';
58        + output;
59        + name='LOG_CLNO';
60        + bin_name='BIN_LOG_CLNO';
61        + bin='1';
62        + LB=.;
63        + UB=        2.71;
64        + EM_BIN_LABEL='LOG_CLNO < 2.71';
65        + output;
66        + name='LOG_CLNO';
67        + bin_name='BIN_LOG_CLNO';
68        + bin='2';
69        + LB=        2.71;
70        + UB=        3.04;
71        + EM_BIN_LABEL='2.71 <= LOG_CLNO < 3.04';
72        + output;
73        + name='LOG_CLNO';
74        + bin_name='BIN_LOG_CLNO';
75        + bin='3';
76        + LB=        3.04;
77        + UB=         3.3;
78        + EM_BIN_LABEL='3.04 <= LOG_CLNO < 3.3';
79        + output;
80        + name='LOG_CLNO';
81        + bin_name = 'BIN_LOG_CLNO';
82        + bin='4';
83        + UB=.;
84        + LB=         3.3;
85        + EM_BIN_LABEL='LOG_CLNO >= 3.3';
86        + output;
87        + name='LOG_DEBTINC';
88        + bin_name='BIN_LOG_DEBTINC';
89        + bin='1';
90        + LB=.;
91        + UB=         3.4;
92        + EM_BIN_LABEL='LOG_DEBTINC < 3.4';
93        + output;
94        + name='LOG_DEBTINC';
95        + bin_name='BIN_LOG_DEBTINC';
96        + bin='2';
97        + LB=         3.4;
98        + UB=        3.58;
99        + EM_BIN_LABEL='3.4 <= LOG_DEBTINC < 3.58';
100       + output;
101       + name='LOG_DEBTINC';
102       + bin_name='BIN_LOG_DEBTINC';
103       + bin='3';
104       + LB=        3.58;
105       + UB=        3.69;
106       + EM_BIN_LABEL='3.58 <= LOG_DEBTINC < 3.69';
107       + output;
108       + name='LOG_DEBTINC';
109       + bin_name = 'BIN_LOG_DEBTINC';
110       + bin='4';
111       + UB=.;
112       + LB=        3.69;
113       + EM_BIN_LABEL='LOG_DEBTINC >= 3.69';
114       + output;
115       + name='LOG_DELINQ';
116       + bin_name='BIN_LOG_DELINQ';
117       + bin='1';
118       + LB=.;
119       + UB=           0;
120       + EM_BIN_LABEL='LOG_DELINQ < 0';
121       + output;
122       + name='LOG_DELINQ';
123       + bin_name = 'BIN_LOG_DELINQ';
124       + bin='2';
125       + UB=.;
126       + LB=           0;
127       + EM_BIN_LABEL='LOG_DELINQ >= 0';
128       + output;
129       + name='LOG_DEROG';
130       + bin_name='BIN_LOG_DEROG';
131       + bin='1';
132       + LB=.;
133       + UB=           0;
134       + EM_BIN_LABEL='LOG_DEROG < 0';
135       + output;
136       + name='LOG_DEROG';
137       + bin_name = 'BIN_LOG_DEROG';
138       + bin='2';
139       + UB=.;
140       + LB=           0;
141       + EM_BIN_LABEL='LOG_DEROG >= 0';
142       + output;
143       + name='LOG_LOAN';
144       + bin_name='BIN_LOG_LOAN';
145       + bin='1';
146       + LB=.;
147       + UB=        9.32;
148       + EM_BIN_LABEL='LOG_LOAN < 9.32';
149       + output;
150       + name='LOG_LOAN';
151       + bin_name='BIN_LOG_LOAN';
152       + bin='2';
153       + LB=        9.32;
154       + UB=         9.7;
155       + EM_BIN_LABEL='9.32 <= LOG_LOAN < 9.7';
156       + output;
157       + name='LOG_LOAN';
158       + bin_name='BIN_LOG_LOAN';
159       + bin='3';
160       + LB=         9.7;
161       + UB=       10.06;
162       + EM_BIN_LABEL='9.7 <= LOG_LOAN < 10.06';
163       + output;
164       + name='LOG_LOAN';
165       + bin_name = 'BIN_LOG_LOAN';
166       + bin='4';
167       + UB=.;
168       + LB=       10.06;
169       + EM_BIN_LABEL='LOG_LOAN >= 10.06';
170       + output;
171       + name='LOG_MORTDUE';
172       + bin_name='BIN_LOG_MORTDUE';
173       + bin='1';
174       + LB=.;
175       + UB=       10.74;
176       + EM_BIN_LABEL='LOG_MORTDUE < 10.74';
177       + output;
178       + name='LOG_MORTDUE';
179       + bin_name='BIN_LOG_MORTDUE';
180       + bin='2';
181       + LB=       10.74;
182       + UB=       11.07;
183       + EM_BIN_LABEL='10.74 <= LOG_MORTDUE < 11.07';
184       + output;
185       + name='LOG_MORTDUE';
186       + bin_name='BIN_LOG_MORTDUE';
187       + bin='3';
188       + LB=       11.07;
189       + UB=       11.44;
190       + EM_BIN_LABEL='11.07 <= LOG_MORTDUE < 11.44';
191       + output;
192       + name='LOG_MORTDUE';
193       + bin_name = 'BIN_LOG_MORTDUE';
194       + bin='4';
195       + UB=.;
196       + LB=       11.44;
197       + EM_BIN_LABEL='LOG_MORTDUE >= 11.44';
198       + output;
199       + name='LOG_VALUE';
200       + bin_name='BIN_LOG_VALUE';
201       + bin='1';
202       + LB=.;
203       + UB=        11.1;
204       + EM_BIN_LABEL='LOG_VALUE < 11.1';
205       + output;
206       + name='LOG_VALUE';
207       + bin_name='BIN_LOG_VALUE';
208       + bin='2';
209       + LB=        11.1;
210       + UB=        11.4;
211       + EM_BIN_LABEL='11.1 <= LOG_VALUE < 11.4';
212       + output;
213       + name='LOG_VALUE';
214       + bin_name='BIN_LOG_VALUE';
215       + bin='3';
216       + LB=        11.4;
217       + UB=       11.71;
218       + EM_BIN_LABEL='11.4 <= LOG_VALUE < 11.71';
219       + output;
220       + name='LOG_VALUE';
221       + bin_name = 'BIN_LOG_VALUE';
222       + bin='4';
223       + UB=.;
224       + LB=       11.71;
225       + EM_BIN_LABEL='LOG_VALUE >= 11.71';
226       + output;
227       + name='LOG_YOJ';
228       + bin_name='BIN_LOG_YOJ';
229       + bin='1';
230       + LB=.;
231       + UB=        1.39;
232       + EM_BIN_LABEL='LOG_YOJ < 1.39';
233       + output;
234       + name='LOG_YOJ';
235       + bin_name='BIN_LOG_YOJ';
236       + bin='2';
237       + LB=        1.39;
238       + UB=        2.08;
239       + EM_BIN_LABEL='1.39 <= LOG_YOJ < 2.08';
240       + output;
241       + name='LOG_YOJ';
242       + bin_name='BIN_LOG_YOJ';
243       + bin='3';
244       + LB=        2.08;
245       + UB=        2.64;
246       + EM_BIN_LABEL='2.08 <= LOG_YOJ < 2.64';
247       + output;
248       + name='LOG_YOJ';
249       + bin_name = 'BIN_LOG_YOJ';
250       + bin='4';
251       + UB=.;
252       + LB=        2.64;
253       + EM_BIN_LABEL='LOG_YOJ >= 2.64';
254       + output;
255       + name='NINQ';
256       + bin_name='BIN_NINQ';
257       + bin='1';
258       + LB=.;
259       + UB=           0;
260       + EM_BIN_LABEL='NINQ < 0';
261       + output;
262       + name='NINQ';
263       + bin_name='BIN_NINQ';
264       + bin='2';
265       + LB=           0;
266       + UB=           1;
267       + EM_BIN_LABEL='0 <= NINQ < 1';
268       + output;
269       + name='NINQ';
270       + bin_name='BIN_NINQ';
271       + bin='3';
272       + LB=           1;
273       + UB=           2;
274       + EM_BIN_LABEL='1 <= NINQ < 2';
275       + output;
276       + name='NINQ';
277       + bin_name = 'BIN_NINQ';
278       + bin='4';
279       + UB=.;
280       + LB=           2;
281       + EM_BIN_LABEL='NINQ >= 2';
282       + output;
283       +   if NAME='' and BIN_NAME='' and BIN='' then delete;
284       +   if LB=UB then delete;
285       + run;

NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 40 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.10 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   data _null_;
MPRINT(EM_APPS_QUANTILE_BINNING):   set work.tempvars end=eof;
MPRINT(EM_APPS_QUANTILE_BINNING):   FILE X MOD;
MPRINT(EM_APPS_QUANTILE_BINNING):   length string $200;
MPRINT(EM_APPS_QUANTILE_BINNING):   if _n_=1 then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put "drop";
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   string = " "||strip(name);
MPRINT(EM_APPS_QUANTILE_BINNING):   put string;
MPRINT(EM_APPS_QUANTILE_BINNING):   if eof then do;
MPRINT(EM_APPS_QUANTILE_BINNING):   put ";";
MPRINT(EM_APPS_QUANTILE_BINNING):   end;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: The file X is:
      Filename=J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\BINNINGCODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=2647,
      Last Modified=25Oct2018:23:41:37,
      Create Time=25Oct2018:23:41:37

NOTE: 14 records were written to the file X.
      The minimum record length was 1.
      The maximum record length was 11.
NOTE: There were 12 observations read from the data set WORK.TEMPVARS.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_APPS_QUANTILE_BINNING):   delete pctdata tempmapping tempbins tempInt;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: The file WORK.TEMPINT (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.PCTDATA (memtype=DATA).
NOTE: Deleting WORK.TEMPMAPPING (memtype=DATA).
NOTE: Deleting WORK.TEMPBINS (memtype=DATA).
MPRINT(EM_APPS_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_APPS_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_APPS_QUANTILE_BINNING):   delete tempvars;
MPRINT(EM_APPS_QUANTILE_BINNING):   run;

NOTE: Deleting WORK.TEMPVARS (memtype=DATA).
MPRINT(EM_APPS_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   by name lb;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 40 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 40 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.12 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_QUANTILE_BINNING):   length display_var $32 grp $8;
MPRINT(EM_QUANTILE_BINNING):   display_var = name;
MPRINT(EM_QUANTILE_BINNING):   GRP = BIN + 1;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      76:92   
NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      76:96   
NOTE: There were 40 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 40 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.10 seconds
      cpu time            0.06 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X;
NOTE: Fileref X has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_BINMAPPINGS out=sortedmapping nodupkey;
MPRINT(EM_QUANTILE_BINNING):   by NAME;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 40 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: 28 observations with duplicate key values were deleted.
NOTE: The data set WORK.SORTEDMAPPING has 12 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: The data set WORK.TEMPMISSVALUES has 1 observations and 0 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   set sortedmapping;
MPRINT(EM_QUANTILE_BINNING):   GRP="1";
MPRINT(EM_QUANTILE_BINNING):   bin="Missing";
MPRINT(EM_QUANTILE_BINNING):   _split_value_ = "Missing";
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 12 observations read from the data set WORK.SORTEDMAPPING.
NOTE: The data set WORK.TEMPMISSVALUES has 12 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X "J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\BINNINGCODE.sas";
MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_BINDATA;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_NEWTRAIN;
NOTE: %INCLUDE (level 1) file X is file J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\BINNINGCODE.sas.
34690     +*------------------------------------------------------------*;
MPRINT(EM_QUANTILE_BINNING):   *------------------------------------------------------------*;
34691     +* Generating Bins for interval variables;
MPRINT(EM_QUANTILE_BINNING):   * Generating Bins for interval variables;
34692     +*------------------------------------------------------------*;
MPRINT(EM_QUANTILE_BINNING):   *------------------------------------------------------------*;
34693     +if INDELINQ eq . then BIN_INDELINQ= .;
MPRINT(EM_QUANTILE_BINNING):   if INDELINQ eq . then BIN_INDELINQ= .;
34694     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
34695     +if INDELINQ < 0 then BIN_INDELINQ=1;
MPRINT(EM_QUANTILE_BINNING):   if INDELINQ < 0 then BIN_INDELINQ=1;
34696     +else if INDELINQ >= 0 then BIN_INDELINQ=2;
MPRINT(EM_QUANTILE_BINNING):   else if INDELINQ >= 0 then BIN_INDELINQ=2;
34697     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
34698     +if INDEROG eq . then BIN_INDEROG= .;
MPRINT(EM_QUANTILE_BINNING):   if INDEROG eq . then BIN_INDEROG= .;
34699     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
34700     +if INDEROG < 0 then BIN_INDEROG=1;
MPRINT(EM_QUANTILE_BINNING):   if INDEROG < 0 then BIN_INDEROG=1;
34701     +else if INDEROG >= 0 then BIN_INDEROG=2;
MPRINT(EM_QUANTILE_BINNING):   else if INDEROG >= 0 then BIN_INDEROG=2;
34702     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
34703     +if LOG_CLAGE eq . then BIN_LOG_CLAGE= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_CLAGE eq . then BIN_LOG_CLAGE= .;
34704     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
34705     +if LOG_CLAGE < 4.77 then BIN_LOG_CLAGE=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_CLAGE < 4.77 then BIN_LOG_CLAGE=1;
34706     +else if LOG_CLAGE < 5.17 then BIN_LOG_CLAGE=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_CLAGE < 5.17 then BIN_LOG_CLAGE=2;
34707     +else if LOG_CLAGE < 5.46 then BIN_LOG_CLAGE=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_CLAGE < 5.46 then BIN_LOG_CLAGE=3;
34708     +else if LOG_CLAGE >= 5.46 then BIN_LOG_CLAGE=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_CLAGE >= 5.46 then BIN_LOG_CLAGE=4;
34709     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
34710     +if LOG_CLNO eq . then BIN_LOG_CLNO= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_CLNO eq . then BIN_LOG_CLNO= .;
34711     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
34712     +if LOG_CLNO < 2.71 then BIN_LOG_CLNO=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_CLNO < 2.71 then BIN_LOG_CLNO=1;
34713     +else if LOG_CLNO < 3.04 then BIN_LOG_CLNO=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_CLNO < 3.04 then BIN_LOG_CLNO=2;
34714     +else if LOG_CLNO < 3.3 then BIN_LOG_CLNO=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_CLNO < 3.3 then BIN_LOG_CLNO=3;
34715     +else if LOG_CLNO >= 3.3 then BIN_LOG_CLNO=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_CLNO >= 3.3 then BIN_LOG_CLNO=4;
34716     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
34717     +if LOG_DEBTINC eq . then BIN_LOG_DEBTINC= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_DEBTINC eq . then BIN_LOG_DEBTINC= .;
34718     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
34719     +if LOG_DEBTINC < 3.4 then BIN_LOG_DEBTINC=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_DEBTINC < 3.4 then BIN_LOG_DEBTINC=1;
34720     +else if LOG_DEBTINC < 3.58 then BIN_LOG_DEBTINC=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_DEBTINC < 3.58 then BIN_LOG_DEBTINC=2;
34721     +else if LOG_DEBTINC < 3.69 then BIN_LOG_DEBTINC=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_DEBTINC < 3.69 then BIN_LOG_DEBTINC=3;
34722     +else if LOG_DEBTINC >= 3.69 then BIN_LOG_DEBTINC=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_DEBTINC >= 3.69 then BIN_LOG_DEBTINC=4;
34723     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
34724     +if LOG_DELINQ eq . then BIN_LOG_DELINQ= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_DELINQ eq . then BIN_LOG_DELINQ= .;
34725     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
34726     +if LOG_DELINQ < 0 then BIN_LOG_DELINQ=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_DELINQ < 0 then BIN_LOG_DELINQ=1;
34727     +else if LOG_DELINQ >= 0 then BIN_LOG_DELINQ=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_DELINQ >= 0 then BIN_LOG_DELINQ=2;
34728     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
34729     +if LOG_DEROG eq . then BIN_LOG_DEROG= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_DEROG eq . then BIN_LOG_DEROG= .;
34730     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
34731     +if LOG_DEROG < 0 then BIN_LOG_DEROG=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_DEROG < 0 then BIN_LOG_DEROG=1;
34732     +else if LOG_DEROG >= 0 then BIN_LOG_DEROG=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_DEROG >= 0 then BIN_LOG_DEROG=2;
34733     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
34734     +if LOG_LOAN eq . then BIN_LOG_LOAN= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_LOAN eq . then BIN_LOG_LOAN= .;
34735     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
34736     +if LOG_LOAN < 9.32 then BIN_LOG_LOAN=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_LOAN < 9.32 then BIN_LOG_LOAN=1;
34737     +else if LOG_LOAN < 9.7 then BIN_LOG_LOAN=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_LOAN < 9.7 then BIN_LOG_LOAN=2;
34738     +else if LOG_LOAN < 10.06 then BIN_LOG_LOAN=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_LOAN < 10.06 then BIN_LOG_LOAN=3;
34739     +else if LOG_LOAN >= 10.06 then BIN_LOG_LOAN=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_LOAN >= 10.06 then BIN_LOG_LOAN=4;
34740     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
34741     +if LOG_MORTDUE eq . then BIN_LOG_MORTDUE= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_MORTDUE eq . then BIN_LOG_MORTDUE= .;
34742     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
34743     +if LOG_MORTDUE < 10.74 then BIN_LOG_MORTDUE=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_MORTDUE < 10.74 then BIN_LOG_MORTDUE=1;
34744     +else if LOG_MORTDUE < 11.07 then BIN_LOG_MORTDUE=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_MORTDUE < 11.07 then BIN_LOG_MORTDUE=2;
34745     +else if LOG_MORTDUE < 11.44 then BIN_LOG_MORTDUE=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_MORTDUE < 11.44 then BIN_LOG_MORTDUE=3;
34746     +else if LOG_MORTDUE >= 11.44 then BIN_LOG_MORTDUE=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_MORTDUE >= 11.44 then BIN_LOG_MORTDUE=4;
34747     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
34748     +if LOG_VALUE eq . then BIN_LOG_VALUE= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_VALUE eq . then BIN_LOG_VALUE= .;
34749     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
34750     +if LOG_VALUE < 11.1 then BIN_LOG_VALUE=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_VALUE < 11.1 then BIN_LOG_VALUE=1;
34751     +else if LOG_VALUE < 11.4 then BIN_LOG_VALUE=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_VALUE < 11.4 then BIN_LOG_VALUE=2;
34752     +else if LOG_VALUE < 11.71 then BIN_LOG_VALUE=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_VALUE < 11.71 then BIN_LOG_VALUE=3;
34753     +else if LOG_VALUE >= 11.71 then BIN_LOG_VALUE=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_VALUE >= 11.71 then BIN_LOG_VALUE=4;
34754     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
34755     +if LOG_YOJ eq . then BIN_LOG_YOJ= .;
MPRINT(EM_QUANTILE_BINNING):   if LOG_YOJ eq . then BIN_LOG_YOJ= .;
34756     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
34757     +if LOG_YOJ < 1.39 then BIN_LOG_YOJ=1;
MPRINT(EM_QUANTILE_BINNING):   if LOG_YOJ < 1.39 then BIN_LOG_YOJ=1;
34758     +else if LOG_YOJ < 2.08 then BIN_LOG_YOJ=2;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_YOJ < 2.08 then BIN_LOG_YOJ=2;
34759     +else if LOG_YOJ < 2.64 then BIN_LOG_YOJ=3;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_YOJ < 2.64 then BIN_LOG_YOJ=3;
34760     +else if LOG_YOJ >= 2.64 then BIN_LOG_YOJ=4;
MPRINT(EM_QUANTILE_BINNING):   else if LOG_YOJ >= 2.64 then BIN_LOG_YOJ=4;
34761     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
34762     +if NINQ eq . then BIN_NINQ= .;
MPRINT(EM_QUANTILE_BINNING):   if NINQ eq . then BIN_NINQ= .;
34763     +else do;
MPRINT(EM_QUANTILE_BINNING):   else do;
34764     +if NINQ < 0 then BIN_NINQ=1;
MPRINT(EM_QUANTILE_BINNING):   if NINQ < 0 then BIN_NINQ=1;
34765     +else if NINQ < 1 then BIN_NINQ=2;
MPRINT(EM_QUANTILE_BINNING):   else if NINQ < 1 then BIN_NINQ=2;
34766     +else if NINQ < 2 then BIN_NINQ=3;
MPRINT(EM_QUANTILE_BINNING):   else if NINQ < 2 then BIN_NINQ=3;
34767     +else if NINQ >= 2 then BIN_NINQ=4;
MPRINT(EM_QUANTILE_BINNING):   else if NINQ >= 2 then BIN_NINQ=4;
34768     +end;
MPRINT(EM_QUANTILE_BINNING):   end;
34769     +drop
34770     +INDELINQ
34771     +INDEROG
34772     +LOG_CLAGE
34773     +LOG_CLNO
34774     +LOG_DEBTINC
34775     +LOG_DELINQ
34776     +LOG_DEROG
34777     +LOG_LOAN
34778     +LOG_MORTDUE
34779     +LOG_VALUE
34780     +LOG_YOJ
34781     +NINQ
34782     +;
MPRINT(EM_QUANTILE_BINNING):   drop INDELINQ INDEROG LOG_CLAGE LOG_CLNO LOG_DEBTINC LOG_DELINQ LOG_DEROG LOG_LOAN LOG_MORTDUE LOG_VALUE LOG_YOJ NINQ ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 2382 observations read from the data set EMWS1.BINNING_NEWTRAIN.
NOTE: The data set EMWS1.BINNING_BINDATA has 2382 observations and 25 variables.
NOTE: DATA statement used (Total process time):
      real time           0.11 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   filename X;
NOTE: Fileref X has been deassigned.
MPRINT(EM_QUANTILE_BINNING):   data tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_BINMAPPINGS tempmissvalues;
MPRINT(EM_QUANTILE_BINNING):   length newgroup _group_ _order_ 8 _level_ $8;
MPRINT(EM_QUANTILE_BINNING):   newgroup =.;
MPRINT(EM_QUANTILE_BINNING):   _LEVEL_ = 'ORDINAL';
MPRINT(EM_QUANTILE_BINNING):   _Group_ = grp;
MPRINT(EM_QUANTILE_BINNING):   rename NAME=DISPLAY_VAR BIN =_SPLIT_VALUE_ BIN_NAME = _VARIABLE_;
MPRINT(EM_QUANTILE_BINNING):   keep NAME NEWGROUP BIN_NAME BIN _LEVEL_ _GROUP_ _ORDER_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      199:121   
NOTE: Variable _order_ is uninitialized.
NOTE: There were 40 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: There were 12 observations read from the data set WORK.TEMPMISSVALUES.
NOTE: The data set WORK.TEMPSPLITVALS has 52 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   set tempsplitvals;
MPRINT(EM_QUANTILE_BINNING):   _order_ = _N_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 52 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set WORK.TEMPSPLITVALS has 52 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   set tempsplitvals ;
MPRINT(EM_QUANTILE_BINNING):   keep display_var _split_value_ _variable_ newgroup _group_ _level_ _order_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 52 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 52 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.07 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data tempvariableset;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_VariableSet;
MPRINT(EM_QUANTILE_BINNING):   where LEVEL ^= 'INTERVAL' and TYPE = 'C' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 2 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (LEVEL not = 'INTERVAL') and (TYPE='C') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 2 observations and 21 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_VARMACRO):   filename macFile catalog 'work.emutil.macro.source';
MPRINT(EM_VARMACRO):   data _null_;
MPRINT(EM_VARMACRO):   length _STRING_ $80;
MPRINT(EM_VARMACRO):   retain _STRING_ '' maxvar 0;
MPRINT(EM_VARMACRO):   set tempvariableset end=eof;
MPRINT(EM_VARMACRO):   file macFile;
MPRINT(EM_VARMACRO):   if _N_=1 then do;
MPRINT(EM_VARMACRO):   string = "%"!!"macro classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   maxvar +1;
MPRINT(EM_VARMACRO):   if (length(_STRING_) + length(trim(NAME))+ 4 < 80) then do;
MPRINT(EM_VARMACRO):   _STRING_ = trim(_STRING_)!!' '!!trim(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_classvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_classvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   else do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   _string_ = TRIM(NAME);
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   put _STRING_;
MPRINT(EM_VARMACRO):   string = "%"!!"mend classvars;";
MPRINT(EM_VARMACRO):   put string;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   if eof then do;
MPRINT(EM_VARMACRO):   string = strip(put(_N_, best.));
MPRINT(EM_VARMACRO):   call symput('_METAOBS', string);
MPRINT(EM_VARMACRO):   put "%" "global num_classvars;";
MPRINT(EM_VARMACRO):   put "%" "let num_classvars = " string ";";
MPRINT(EM_VARMACRO):   stop;
MPRINT(EM_VARMACRO):   end;
MPRINT(EM_VARMACRO):   run;

NOTE: The file MACFILE is:
      Catalog Name=WORK.EMUTIL.MACRO.SOURCE,
      Catalog Page Size=4096,
      Number of Catalog Pages=5,
      Created=Thu, Oct 25, 2018 11:41:37 PM,
      Last Modified=Thu, Oct 25, 2018 11:41:37 PM,
      Filename=C:\Users\jmmorr01\AppData\Local\Temp\SAS Temporary Files\_TD2096_COB-MBA021_\Prc2\emutil.sas7bcat,
      Release Created=9.0401M3,Host Created=X64_8PRO

NOTE: 5 records were written to the file MACFILE.
      The minimum record length was 10.
      The maximum record length was 24.
NOTE: There were 2 observations read from the data set WORK.TEMPVARIABLESET.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: %INCLUDE (level 1) file MACFILE is file WORK.EMUTIL.MACRO.SOURCE.
34783     +%macro classvars;
34784     +JOB REASON
34785     +%mend classvars;
34786     +%global num_classvars;
34787     +%let num_classvars = 2 ;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_VARMACRO):   filename macFile;
NOTE: Fileref MACFILE has been deassigned.
MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   proc dmdb data =EMWS1.BINNING_BINDATA classout=_classout nonorm;
MPRINT(EM_QUANTILE_BINNING):   class
MPRINT(CLASSVARS):   JOB REASON
MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Records processed = 2382   Memory used = 511K.
NOTE: There were 2382 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK._CLASSOUT has 10 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc dmdb data=EMWS1.BINNING_BINDATA classout=_classout2;
MPRINT(EM_QUANTILE_BINNING):   class
MPRINT(CLASSVARS):   JOB REASON
MPRINT(EM_QUANTILE_BINNING):  ;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Records processed = 2382   Memory used = 511K.
NOTE: There were 2382 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK._CLASSOUT2 has 10 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=_classout;
MPRINT(EM_QUANTILE_BINNING):   by NAME CRAW;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._CLASSOUT has 10 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=_classout2;
MPRINT(EM_QUANTILE_BINNING):   by NAME CRAW;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK._CLASSOUT2.
NOTE: The data set WORK._CLASSOUT2 has 10 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data _classout;
MPRINT(EM_QUANTILE_BINNING):   length _variable_ $32;
MPRINT(EM_QUANTILE_BINNING):   merge _classout _classout2 (rename=(LEVEL=_split_value_));
MPRINT(EM_QUANTILE_BINNING):   by NAME CRAW;
MPRINT(EM_QUANTILE_BINNING):   _variable_ = NAME;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK._CLASSOUT.
NOTE: There were 10 observations read from the data set WORK._CLASSOUT2.
NOTE: The data set WORK._CLASSOUT has 10 observations and 11 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=_classout;
MPRINT(EM_QUANTILE_BINNING):   by _variable_ _split_value_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 10 observations read from the data set WORK._CLASSOUT.
NOTE: The data set WORK._CLASSOUT has 10 observations and 11 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   by _variable_ _split_value_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 52 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 52 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.12 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   length _norm_level_ $200 _split_value_ $200;
MPRINT(EM_QUANTILE_BINNING):   merge EMWS1.BINNING_SPLITVALS _classout(rename=(LEVEL=_norm_level_));
MPRINT(EM_QUANTILE_BINNING):   by _variable_ _split_value_;
MPRINT(EM_QUANTILE_BINNING):   LEVEL = trim(left(LEVEL));
MPRINT(EM_QUANTILE_BINNING):   _split_value_ = trim(left(_split_value_));
MPRINT(EM_QUANTILE_BINNING):   _norm_level_ = trim(left(_norm_level_));
MPRINT(EM_QUANTILE_BINNING):   if _norm_level_ eq '' then _norm_level_= _split_value_;
MPRINT(EM_QUANTILE_BINNING):   drop NAME FREQUENCY TYPE CRAW NRAW;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      356:121   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      356:111   
NOTE: There were 52 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: There were 10 observations read from the data set WORK._CLASSOUT.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 62 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_QUANTILE_BINNING):   delete _classout _classout2;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Deleting WORK._CLASSOUT (memtype=DATA).
NOTE: Deleting WORK._CLASSOUT2 (memtype=DATA).
MPRINT(EM_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   set EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   if _norm_level_ eq '' then _norm_level_= _split_value_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 62 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 62 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.10 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_QUANTILE_BINNING):   by DISPLAY_VAR _Group_;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: There were 62 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 62 observations and 12 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.10 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_QUANTILE_BINNING):   proc datasets library=work nolist;
MPRINT(EM_QUANTILE_BINNING):   delete sortedmapping tempsplitvals tempmissvalues ;
MPRINT(EM_QUANTILE_BINNING):   run;

NOTE: Deleting WORK.SORTEDMAPPING (memtype=DATA).
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
NOTE: Deleting WORK.TEMPMISSVALUES (memtype=DATA).
MPRINT(EM_QUANTILE_BINNING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_CLASSVARS_GROUP):   proc sort data=EMWS1.BINNING_VariableSet out=tempvariableset;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   where ((LEVEL = 'NOMINAL') OR (LEVEL='BINARY')) and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 2 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE LEVEL in ('BINARY', 'NOMINAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 2 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc dmdb data=EMWS1.Trans_TRAIN classout=tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   class JOB REASON ;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: Records processed = 2382   Memory used = 511K.
NOTE: View EMWS1.TRANS_TRAIN.VIEW used (Total process time):
      real time           0.04 seconds
      cpu time            0.04 seconds
      
NOTE: There were 2382 observations read from the data set EMWS1.PART_TRAIN.
NOTE: There were 2382 observations read from the data set EMWS1.TRANS_TRAIN.
NOTE: The data set WORK.TEMPCLASSOUT has 10 observations and 9 variables.
NOTE: PROCEDURE DMDB used (Total process time):
      real time           0.06 seconds
      cpu time            0.06 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL='MISSING' then level='Missing';
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: The data set WORK.TEMPCLASSOUT has 10 observations and 9 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data=tempclassout nodupkey;
MPRINT(EM_CLASSVARS_GROUP):   by NAME descending FREQUENCY LEVEL;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPCLASSOUT has 10 observations and 9 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempds(keep=NAME NOBS);
MPRINT(EM_CLASSVARS_GROUP):   retain NOBS;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   if first.NAME then NOBS = frequency;
MPRINT(EM_CLASSVARS_GROUP):   else NOBS=NOBS+frequency;
MPRINT(EM_CLASSVARS_GROUP):   if last.name then do;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: The data set WORK.TEMPDS has 2 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempds;
MPRINT(EM_CLASSVARS_GROUP):   merge tempclassout tempds;
MPRINT(EM_CLASSVARS_GROUP):   by NAME;
MPRINT(EM_CLASSVARS_GROUP):   if ((LEVEL ne '') AND (LEVEL ne "."));
MPRINT(EM_CLASSVARS_GROUP):   PCT = 100 * (FREQUENCY/NOBS);
MPRINT(EM_CLASSVARS_GROUP):   if PCT < 0.5 then flag=1;
MPRINT(EM_CLASSVARS_GROUP):   else flag=0;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: There were 2 observations read from the data set WORK.TEMPDS.
NOTE: The data set WORK.TEMPDS has 8 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempmissvalues;
MPRINT(EM_CLASSVARS_GROUP):   length NAME $32 LEVEL $200 _LEVEL_ $8 _GROUP_ 8;
MPRINT(EM_CLASSVARS_GROUP):   NAME="JOB";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   NAME="REASON";
MPRINT(EM_CLASSVARS_GROUP):   LEVEL="Missing";
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_="BINARY";
MPRINT(EM_CLASSVARS_GROUP):   _group_ = 1;
MPRINT(EM_CLASSVARS_GROUP):   output;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: The data set WORK.TEMPMISSVALUES has 2 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data tempsplitvals;
MPRINT(EM_CLASSVARS_GROUP):   length _VARIABLE_ $32 newgroup _group_ 8 _Split_value_ $200;
MPRINT(EM_CLASSVARS_GROUP):   set tempclassout tempmissvalues ;
MPRINT(EM_CLASSVARS_GROUP):   if ((level ne '') AND (level ne '.'));
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "JOB" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "NOMINAL";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "OTHER" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "PROFEXE" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "OFFICE" then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "MGR" then _GROUP_ = 5;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "SELF" then _GROUP_ = 6;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "SALES" then _GROUP_ = 7;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 8;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   if NAME = "REASON" then do;
MPRINT(EM_CLASSVARS_GROUP):   _LEVEL_ = "BINARY";
MPRINT(EM_CLASSVARS_GROUP):   if LEVEL = "DEBTCON" then _GROUP_ = 2;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL = "HOMEIMP" then _GROUP_ = 3;
MPRINT(EM_CLASSVARS_GROUP):   else if LEVEL ^='Missing' then _GROUP_ = 4;
MPRINT(EM_CLASSVARS_GROUP):   end;
MPRINT(EM_CLASSVARS_GROUP):   _VARIABLE_ = NAME;
MPRINT(EM_CLASSVARS_GROUP):   newgroup = .;
MPRINT(EM_CLASSVARS_GROUP):   rename NAME = DISPLAY_VAR LEVEL = _SPLIT_VALUE_;
MPRINT(EM_CLASSVARS_GROUP):   keep NAME NEWGROUP _VARIABLE_ LEVEL _LEVEL_ _GROUP_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: Variable _Split_value_ is uninitialized.
NOTE: There were 10 observations read from the data set WORK.TEMPCLASSOUT.
NOTE: There were 2 observations read from the data set WORK.TEMPMISSVALUES.
NOTE: The data set WORK.TEMPSPLITVALS has 10 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sql;
MPRINT(EM_CLASSVARS_GROUP):   reset noprint;
MPRINT(EM_CLASSVARS_GROUP):   select count(*) into :nobs from EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   quit;
NOTE: PROCEDURE SQL used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data = EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_value_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 62 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 62 observations and 12 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.10 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data = tempsplitvals nodupkey;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_Value_ _group_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 10 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: 0 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPSPLITVALS has 10 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   data EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   merge EMWS1.BINNING_SPLITVALS tempsplitvals ;
MPRINT(EM_CLASSVARS_GROUP):   by _variable_ _split_value_ ;
MPRINT(EM_CLASSVARS_GROUP):   if display_var eq "" then delete;
MPRINT(EM_CLASSVARS_GROUP):   if _norm_level_ eq "" then _norm_level_ = _split_value_;
MPRINT(EM_CLASSVARS_GROUP):   keep display_var _split_value_ _variable_ newgroup _group_ _level_ _norm_level_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 62 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: There were 10 observations read from the data set WORK.TEMPSPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 62 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_CLASSVARS_GROUP):   by DISPLAY_VAR _Group_;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: There were 62 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set EMWS1.BINNING_SPLITVALS has 62 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.12 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CLASSVARS_GROUP):   proc datasets library= work nolist;
MPRINT(EM_CLASSVARS_GROUP):   delete tempsplitvals tempds tempclassout tempvariableset tempvars tempmissvalues ;
MPRINT(EM_CLASSVARS_GROUP):   run;

NOTE: The file WORK.TEMPVARS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
NOTE: Deleting WORK.TEMPDS (memtype=DATA).
NOTE: Deleting WORK.TEMPCLASSOUT (memtype=DATA).
NOTE: Deleting WORK.TEMPVARIABLESET (memtype=DATA).
NOTE: Deleting WORK.TEMPMISSVALUES (memtype=DATA).
MPRINT(EM_CLASSVARS_GROUP):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_ORDVARS_GROUP):   proc sort data=EMWS1.BINNING_VariableSet out=tempvariableset;
MPRINT(EM_ORDVARS_GROUP):   by NAME;
MPRINT(EM_ORDVARS_GROUP):   where LEVEL = 'ORDINAL' and ((ROLE='INPUT' and USE in ('Y', 'D')) OR (ROLE='REJECTED' and USE='Y'));
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: Input data set is empty.
NOTE: There were 0 observations read from the data set EMWS1.BINNING_VARIABLESET.
      WHERE (LEVEL='ORDINAL') and (((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y')));
NOTE: The data set WORK.TEMPVARIABLESET has 0 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_ORDVARS_GROUP):   proc sort data=EMWS1.BINNING_SPLITVALS;
MPRINT(EM_ORDVARS_GROUP):   by DISPLAY_VAR _Group_;
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: Input data set is already sorted, no sorting done.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_ORDVARS_GROUP):   proc datasets library= work nolist;
MPRINT(EM_ORDVARS_GROUP):   delete tempsplitvals varvals tempvariableset tempvars ;
MPRINT(EM_ORDVARS_GROUP):   run;

NOTE: The file WORK.TEMPSPLITVALS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.VARVALS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: The file WORK.TEMPVARS (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPVARIABLESET (memtype=DATA).
MPRINT(EM_ORDVARS_GROUP):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   proc print data=EMWS1.BINNING_VARMAPPINGS label;
MPRINT(TRAIN):   var _VARIABLE_ _GRP_VARIABLE_ ;
MPRINT(TRAIN):   run;

NOTE: There were 14 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The PROCEDURE PRINT printed page 5.
NOTE: PROCEDURE PRINT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   proc sort data=EMWS1.BINNING_SPLITVALS out=tempsplitvals nodupkey;
MPRINT(TRAIN):   by _VARIABLE_;
MPRINT(TRAIN):   run;

NOTE: There were 62 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: 48 observations with duplicate key values were deleted.
NOTE: The data set WORK.TEMPSPLITVALS has 14 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):   data EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   set EMWS1.BINNING_VARMAPPINGS;
MPRINT(TRAIN):   length _proc_var_ $32;
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "INDELINQ" then _proc_var_ = "BIN_INDELINQ";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "INDEROG" then _proc_var_ = "BIN_INDEROG";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_CLAGE" then _proc_var_ = "BIN_LOG_CLAGE";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_CLNO" then _proc_var_ = "BIN_LOG_CLNO";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_DEBTINC" then _proc_var_ = "BIN_LOG_DEBTINC";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_DELINQ" then _proc_var_ = "BIN_LOG_DELINQ";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_DEROG" then _proc_var_ = "BIN_LOG_DEROG";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_LOAN" then _proc_var_ = "BIN_LOG_LOAN";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_MORTDUE" then _proc_var_ = "BIN_LOG_MORTDUE";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_VALUE" then _proc_var_ = "BIN_LOG_VALUE";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "LOG_YOJ" then _proc_var_ = "BIN_LOG_YOJ";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "NINQ" then _proc_var_ = "BIN_NINQ";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "JOB" then _proc_var_ = "JOB";
MPRINT(TRAIN):   if upcase(_VARIABLE_) = "REASON" then _proc_var_ = "REASON";
MPRINT(TRAIN):   if missing(_proc_var_) then _proc_var_=_variable_;
MPRINT(TRAIN):   run;

NOTE: There were 14 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set EMWS1.BINNING_VARMAPPINGS has 14 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.09 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):   proc datasets library=work nolist;
MPRINT(TRAIN):   delete sortedbin tempsplitvals;
MPRINT(TRAIN):   run;

NOTE: The file WORK.SORTEDBIN (memtype=DATA) was not found, but appears on a DELETE statement.
NOTE: Deleting WORK.TEMPSPLITVALS (memtype=DATA).
MPRINT(TRAIN):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc freq data=EMWS1.BINNING_BINDATA noprint;
MPRINT(EM_FINE_DETAIL):   table BAD / missing out=temptargetB;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 2382 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTARGETB has 2 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.04 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets lib=work nolist;
MPRINT(EM_FINE_DETAIL):   delete temptargetB;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.TEMPTARGETB (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VariableSet out=tempvarset;
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 16 observations read from the data set EMWS1.BINNING_VARIABLESET.
NOTE: The data set WORK.TEMPVARSET has 16 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data temptrain ;
MPRINT(EM_SUMMARIZE_TABLE):   set EMWS1.BINNING_BINDATA;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 2382 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTRAIN has 2382 observations and 25 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   filename _temp catalog 'sashelp.emapps.em_Prenormalizeclassvars.source';
NOTE: %INCLUDE (level 1) file _TEMP is file SASHELP.EMAPPS.EM_PRENORMALIZECLASSVARS.SOURCE.
34788     +%macro em_PreNormalizeClassVars(incmeta=, outcmeta=);
34789     +
34790     +   data &outcmeta(keep=INDEXVAR NAME LEVEL TYPE LABEL FORMAT INFORMAT) ;
34791     +      length INDEXVAR $32; retain _index 0;
34792     +      set &incmeta(where=((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y'));
34793     +      if strip(LEVEL) eq 'INTERVAL' then delete;
34794     +      else do;
34795     +         _index+1;
34796     +         INDEXVAR='_INDEXVAR'||strip(put(_index, Best12.));
34797     +      end;
34798     +   run;
34799     +%mend em_PreNormalizeClassVars;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp;
NOTE: Fileref _TEMP has been deassigned.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp catalog 'sashelp.emapps.em_Normalizeclassvars.source';
NOTE: %INCLUDE (level 1) file _TEMP is file SASHELP.EMAPPS.EM_NORMALIZECLASSVARS.SOURCE.
34800     +%macro em_NormalizeClassVars(indata=,
34801     +                          cmeta=,
34802     +                          encodedTarget=N,
34803     +                          target=,
34804     +                          targetEvent=,
34805     +                          targetNonEvent=,
34806     +                          outdata=);
34807     + %let dsid = %sysfunc(open(&cmeta));
34808     + %let vn_name =%sysfunc(varnum(&dsid, NAME));
34809     + %let vn_indexvar =%sysfunc(varnum(&dsid, INDEXVAR));
34810     + %let vn_format =%sysfunc(varnum(&dsid, FORMAT));
34811     + %let vn_type =%sysfunc(varnum(&dsid, TYPE));
34812     +
34813     + data &outdata/view=&outdata;
34814     +      length _normedvar32 $32.;
34815     +      set &indata( rename = (
34816     +      %let k = 1;
34817     +      %do %while(^%sysfunc(fetch(&dsid)));
34818     +          %let _name     = %sysfunc(getvarc(&dsid, &vn_name));
34819     +          %let _indexvar = %sysfunc(getvarc(&dsid, &vn_indexvar));
34820     +          %let _format   = %sysfunc(getvarc(&dsid, &vn_format));
34821     +          &_name = &_indexvar
34822     +          %let k = %eval(&k+1);
34823     +      %end;
34824     +      ));
34825     +      drop  _normedvar32;
34826     +
34827     +      %let rc=%sysfunc(rewind(&dsid));
34828     +      %let k = 1;
34829     +      %do %while(^%sysfunc(fetch(&dsid)));
34830     +          %let _name     = %sysfunc(getvarc(&dsid, &vn_name));
34831     +          %let _indexvar = %sysfunc(getvarc(&dsid, &vn_indexvar));
34832     +          %let _format   = %sysfunc(getvarc(&dsid, &vn_format));
34833     +          %let _type     = %sysfunc(getvarc(&dsid, &vn_type));
34834     +          %if &_format ne %then %do;
34835     +              _normedvar32 = put(&_indexvar, &_format);
34836     +          %end;
34837     +          %else %do;
34838     +              %if &_type = N %then %do;
34839     +                  _normedvar32 = put(&_indexvar, Best12.);
34840     +              %end;
34841     +              %else %do;
34842     +                  _normedvar32 = put(&_indexvar, $32.);
34843     +              %end;
34844     +          %end;
34845     +          %DMNORMIP(_normedvar32);
34846     +          &_name = _normedvar32;
34847     +          drop &_indexvar;
34848     +          %let k = %eval(&k+1);
34849     +      %end;
34850     +      %let dsid = %sysfunc(close(&dsid));
34851     +
34852     +      %if &encodedTarget = Y %then %do;
34853     +          %let qtargetEvent = %sysfunc(quote(&targetEvent));
34854     +          %let qtargetNonEvent = %sysfunc(quote(&targetNonEvent));
34855     +          if upcase(strip(&target)) = &qtargetEvent then _EncodedTarget_ =1;
34856     +          else if upcase(strip(&target)) = &qtargetNonEvent then _EncodedTarget_ = 0;
34857     +      %end;
34858     + run;
34859     +
34860     +%mend em_NormalizeClassVars;
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_SUMMARIZE_TABLE):   filename _temp;
NOTE: Fileref _TEMP has been deassigned.
MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VARMAPPINGS out=tempmap;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 14 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set WORK.TEMPMAP has 14 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data _cmeta;
MPRINT(EM_SUMMARIZE_TABLE):   merge tempvarset tempmap(in=_a rename=(_variable_=name ));
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   if ((_a) or (role="TARGET"));
MPRINT(EM_SUMMARIZE_TABLE):   if role="INPUT" or (role="REJECTED" and Use="Y") then name=_proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   if role="TARGET" then role="INPUT";
MPRINT(EM_SUMMARIZE_TABLE):   level = procLevel;
MPRINT(EM_SUMMARIZE_TABLE):   index = kindex(name, "BIN_");
MPRINT(EM_SUMMARIZE_TABLE):   if index gt 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   level="ORDINAL";
MPRINT(EM_SUMMARIZE_TABLE):   format = "";
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   drop index;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      83:121   
NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      86:105   
NOTE: There were 16 observations read from the data set WORK.TEMPVARSET.
NOTE: There were 14 observations read from the data set WORK.TEMPMAP.
NOTE: The data set WORK._CMETA has 15 observations and 23 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_PRENORMALIZECLASSVARS):   data _cmetatmp(keep=INDEXVAR NAME LEVEL TYPE LABEL FORMAT INFORMAT) ;
MPRINT(EM_PRENORMALIZECLASSVARS):   length INDEXVAR $32;
MPRINT(EM_PRENORMALIZECLASSVARS):   retain _index 0;
MPRINT(EM_PRENORMALIZECLASSVARS):   set _cmeta(where=((ROLE='INPUT' and USE in('Y', 'D')) or ROLE='REJECTED' and USE='Y'));
MPRINT(EM_PRENORMALIZECLASSVARS):   if strip(LEVEL) eq 'INTERVAL' then delete;
MPRINT(EM_PRENORMALIZECLASSVARS):   else do;
MPRINT(EM_PRENORMALIZECLASSVARS):   _index+1;
MPRINT(EM_PRENORMALIZECLASSVARS):   INDEXVAR='_INDEXVAR'||strip(put(_index, Best12.));
MPRINT(EM_PRENORMALIZECLASSVARS):   end;
MPRINT(EM_PRENORMALIZECLASSVARS):   run;

NOTE: There were 15 observations read from the data set WORK._CMETA.
      WHERE ((ROLE='INPUT') and USE in ('D', 'Y')) or ((ROLE='REJECTED') and (USE='Y'));
NOTE: The data set WORK._CMETATMP has 15 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_NORMALIZECLASSVARS):   data _tmp_train/view=_tmp_train;
MPRINT(EM_NORMALIZECLASSVARS):   length _normedvar32 $32.;
MPRINT(EM_NORMALIZECLASSVARS):   set work.temptrain( rename = ( BAD = _INDEXVAR1 BIN_INDELINQ = _INDEXVAR2 BIN_INDEROG = _INDEXVAR3 JOB = _INDEXVAR4 BIN_LOG_CLAGE = _INDEXVAR5 BIN_LOG_CLNO = _INDEXVAR6 BIN_LOG_DEBTINC = _INDEXVAR7 BIN_LOG_DELINQ = 
_INDEXVAR8 BIN_LOG_DEROG = _INDEXVAR9 BIN_LOG_LOAN = _INDEXVAR10 BIN_LOG_MORTDUE = _INDEXVAR11 BIN_LOG_VALUE = _INDEXVAR12 BIN_LOG_YOJ = _INDEXVAR13 BIN_NINQ = _INDEXVAR14 REASON = _INDEXVAR15 ));
MPRINT(EM_NORMALIZECLASSVARS):   drop _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR1, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BAD = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR1;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR2, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_INDELINQ = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR2;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR3, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_INDEROG = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR3;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR4, $32.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   JOB = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR4;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR5, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_CLAGE = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR5;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR6, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_CLNO = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR6;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR7, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_DEBTINC = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR7;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR8, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_DELINQ = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR8;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR9, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_DEROG = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR9;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR10, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_LOAN = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR10;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR11, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_MORTDUE = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR11;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR12, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_VALUE = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR12;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR13, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_LOG_YOJ = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR13;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR14, Best12.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   BIN_NINQ = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR14;
MPRINT(EM_NORMALIZECLASSVARS):   _normedvar32 = put(_INDEXVAR15, $32.);
MPRINT(DMNORMIP):   call dmnorm(_normedvar32,
MPRINT(DMNORLEN):  32
MPRINT(DMNORMIP):  );
MPRINT(EM_NORMALIZECLASSVARS):  ;
MPRINT(EM_NORMALIZECLASSVARS):   REASON = _normedvar32;
MPRINT(EM_NORMALIZECLASSVARS):   drop _INDEXVAR15;
MPRINT(EM_NORMALIZECLASSVARS):   run;

NOTE: DATA STEP view saved on file WORK._TMP_TRAIN.
NOTE: A stored DATA STEP view cannot run under a different operating system.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VARMAPPINGS out=sortedmap;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 14 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set WORK.SORTEDMAP has 14 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data _null_;
MPRINT(EM_SUMMARIZE_TABLE):   set sortedmap end=eof;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   if _n_=1 then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods output CrossTabFreqs=crosstabfreq ;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods listing close;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("proc freq data=_tmp_train order=formatted addnames;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("tables ("||_proc_var_);
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   else do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute(_proc_var_);
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if eof then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute(") * BAD/ missing;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("run;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods output close;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("ods listing;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   run;

MPRINT(EM_SUMMARIZE_TABLE):   ods output CrossTabFreqs=crosstabfreq ;
MPRINT(EM_SUMMARIZE_TABLE):   ods listing close;
MPRINT(EM_SUMMARIZE_TABLE):   proc freq data=_tmp_train order=formatted addnames;
MPRINT(EM_SUMMARIZE_TABLE):   ) * BAD/ missing;
MPRINT(EM_SUMMARIZE_TABLE):   run;
MPRINT(EM_SUMMARIZE_TABLE):   ods output close;
MPRINT(EM_SUMMARIZE_TABLE):   ods listing;
NOTE: There were 14 observations read from the data set WORK.SORTEDMAP.
NOTE: DATA statement used (Total process time):
      real time           0.00 seconds
      cpu time            0.00 seconds
      

NOTE: CALL EXECUTE generated line.
1         + ods output CrossTabFreqs=crosstabfreq ;
MPRINT(EM_SUMMARIZE_TABLE):   CrossTabFreqs ;
2         + ods listing close;
MPRINT(EM_SUMMARIZE_TABLE):   close
3         + proc freq data=_tmp_train order=formatted addnames;
4         + tables (BIN_INDELINQ
5         + BIN_INDEROG
6         + BIN_LOG_CLAGE
7         + BIN_LOG_CLNO
8         + BIN_LOG_DEBTINC
9         + BIN_LOG_DELINQ
10        + BIN_LOG_DEROG
11        + BIN_LOG_LOAN
12        + BIN_LOG_MORTDUE
13        + BIN_LOG_VALUE
14        + BIN_LOG_YOJ
15        + BIN_NINQ
16        + JOB
17        + REASON
18        + ) * BAD/ missing;
19        + run;

NOTE: View WORK._TMP_TRAIN.VIEW used (Total process time):
      real time           0.25 seconds
      cpu time            0.14 seconds
      
NOTE: There were 2382 observations read from the data set WORK.TEMPTRAIN.
NOTE: The data set WORK.CROSSTABFREQ has 204 observations and 25 variables.
NOTE: There were 2382 observations read from the data set WORK._TMP_TRAIN.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.29 seconds
      cpu time            0.18 seconds
      

20        + ods output close;
MPRINT(EM_SUMMARIZE_TABLE):   close
21        + ods listing;
MPRINT(EM_SUMMARIZE_TABLE):  ;
MPRINT(EM_SUMMARIZE_TABLE):   data _null_;
MPRINT(EM_SUMMARIZE_TABLE):   set sortedmap end=eof;
MPRINT(EM_SUMMARIZE_TABLE):   by _proc_var_;
MPRINT(EM_SUMMARIZE_TABLE):   if _n_=1 then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("data crosstabs;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  length _variable_ _split_value_  $200 ;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  set crosstabfreq(where=(_type_='11'));");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  _variable_= RowVariable;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("if strip(RowVariable) = '"||strip(_proc_var_)||"' then do;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("  _split_value_="||_proc_var_||";");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("end;");
MPRINT(EM_SUMMARIZE_TABLE):   if eof then do;
MPRINT(EM_SUMMARIZE_TABLE):   call execute("keep _variable_ _split_value_ BAD Frequency Percent display_var;");
MPRINT(EM_SUMMARIZE_TABLE):   call execute("run;");
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   run;

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   length _variable_ _split_value_ $200 ;
MPRINT(EM_SUMMARIZE_TABLE):   set crosstabfreq(where=(_type_='11'));
MPRINT(EM_SUMMARIZE_TABLE):   _variable_= RowVariable;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_INDELINQ' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_INDELINQ ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_INDEROG' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_INDEROG ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_CLAGE' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_CLAGE ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_CLNO' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_CLNO ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_DEBTINC' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_DEBTINC ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_DELINQ' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_DELINQ ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_DEROG' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_DEROG ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_LOAN' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_LOAN ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_MORTDUE' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_MORTDUE ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_VALUE' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_VALUE ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_LOG_YOJ' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_LOG_YOJ ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'BIN_NINQ' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=BIN_NINQ ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'JOB' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=JOB ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if strip(RowVariable) = 'REASON' then do;
MPRINT(EM_SUMMARIZE_TABLE):   _split_value_=REASON ;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   keep _variable_ _split_value_ BAD Frequency Percent display_var;
MPRINT(EM_SUMMARIZE_TABLE):   run;
NOTE: There were 14 observations read from the data set WORK.SORTEDMAP.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

NOTE: CALL EXECUTE generated line.
1         + data crosstabs;
2         +   length _variable_ _split_value_  $200 ;
MPRINT(EM_SUMMARIZE_TABLE):  200
3         +   set crosstabfreq(where=(_type_='11'));
4         +   _variable_= RowVariable;
5         + if strip(RowVariable) = 'BIN_INDELINQ' then do;
6         +   _split_value_=BIN_INDELINQ                    ;
7         + end;
8         + if strip(RowVariable) = 'BIN_INDEROG' then do;
9         +   _split_value_=BIN_INDEROG                     ;
10        + end;
11        + if strip(RowVariable) = 'BIN_LOG_CLAGE' then do;
12        +   _split_value_=BIN_LOG_CLAGE                   ;
13        + end;
14        + if strip(RowVariable) = 'BIN_LOG_CLNO' then do;
15        +   _split_value_=BIN_LOG_CLNO                    ;
16        + end;
17        + if strip(RowVariable) = 'BIN_LOG_DEBTINC' then do;
18        +   _split_value_=BIN_LOG_DEBTINC                 ;
19        + end;
20        + if strip(RowVariable) = 'BIN_LOG_DELINQ' then do;
21        +   _split_value_=BIN_LOG_DELINQ                  ;
22        + end;
23        + if strip(RowVariable) = 'BIN_LOG_DEROG' then do;
24        +   _split_value_=BIN_LOG_DEROG                   ;
25        + end;
26        + if strip(RowVariable) = 'BIN_LOG_LOAN' then do;
27        +   _split_value_=BIN_LOG_LOAN                    ;
28        + end;
29        + if strip(RowVariable) = 'BIN_LOG_MORTDUE' then do;
30        +   _split_value_=BIN_LOG_MORTDUE                 ;
31        + end;
32        + if strip(RowVariable) = 'BIN_LOG_VALUE' then do;
33        +   _split_value_=BIN_LOG_VALUE                   ;
34        + end;
35        + if strip(RowVariable) = 'BIN_LOG_YOJ' then do;
36        +   _split_value_=BIN_LOG_YOJ                     ;
37        + end;
38        + if strip(RowVariable) = 'BIN_NINQ' then do;
39        +   _split_value_=BIN_NINQ                        ;
40        + end;
41        + if strip(RowVariable) = 'JOB' then do;
42        +   _split_value_=JOB                             ;
43        + end;
44        + if strip(RowVariable) = 'REASON' then do;
45        +   _split_value_=REASON                          ;
46        + end;
47        + keep _variable_ _split_value_ BAD Frequency Percent display_var;
48        + run;

WARNING: The variable display_var in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 108 observations read from the data set WORK.CROSSTABFREQ.
      WHERE _type_='11';
NOTE: The data set WORK.CROSSTABS has 108 observations and 5 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 108 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 108 observations and 5 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   length display_var $32;
MPRINT(EM_SUMMARIZE_TABLE):   merge crosstabs sortedmap(rename=(_variable_=display_var _proc_var_=_variable_ ) keep=_variable_ _proc_var_ );
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 108 observations read from the data set WORK.CROSSTABS.
NOTE: There were 14 observations read from the data set WORK.SORTEDMAP.
NOTE: The data set WORK.CROSSTABS has 108 observations and 6 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by display_var _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 108 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 108 observations and 6 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=EMWS1.BINNING_VariableSet out=tempvarset;
MPRINT(EM_SUMMARIZE_TABLE):   by name;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 16 observations read from the data set EMWS1.BINNING_VARIABLESET.
NOTE: The data set WORK.TEMPVARSET has 16 observations and 21 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   merge crosstabs tempvarset(rename=(name=display_var) keep=type format name level);
MPRINT(EM_SUMMARIZE_TABLE):   by display_var;
MPRINT(EM_SUMMARIZE_TABLE):   index = kindex(_variable_, "BIN_");
MPRINT(EM_SUMMARIZE_TABLE):   if index gt 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   level="ORDINAL";
MPRINT(EM_SUMMARIZE_TABLE):   format = "";
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   _temp = BAD;
MPRINT(EM_SUMMARIZE_TABLE):   drop index;
MPRINT(EM_SUMMARIZE_TABLE):   run;

WARNING: Multiple lengths were specified for the BY variable display_var by input data sets. This might cause unexpected results.
NOTE: There were 108 observations read from the data set WORK.CROSSTABS.
NOTE: There were 16 observations read from the data set WORK.TEMPVARSET.
NOTE: The data set WORK.CROSSTABS has 110 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   proc sort data=crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: There were 110 observations read from the data set WORK.CROSSTABS.
NOTE: The data set WORK.CROSSTABS has 110 observations and 10 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_SUMMARIZE_TABLE):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_SUMMARIZE_TABLE):   length _variable_ _split_value_ $200 eventCount nonEventCount Total EventRate nonEventRate 8 type $1 valfmt $20 ;
MPRINT(EM_SUMMARIZE_TABLE):   retain eventCount noneventCount ;
MPRINT(EM_SUMMARIZE_TABLE):   set crosstabs;
MPRINT(EM_SUMMARIZE_TABLE):   by _variable_ _split_value_;
MPRINT(EM_SUMMARIZE_TABLE):   if first._split_value_ then do;
MPRINT(EM_SUMMARIZE_TABLE):   total=0;
MPRINT(EM_SUMMARIZE_TABLE):   eventcount=0;
MPRINT(EM_SUMMARIZE_TABLE):   noneventcount=0;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   if _temp=1 then eventCount=Frequency;
MPRINT(EM_SUMMARIZE_TABLE):   else noneventCount=Frequency;
MPRINT(EM_SUMMARIZE_TABLE):   if last._split_value_ then do;
MPRINT(EM_SUMMARIZE_TABLE):   total = eventCount + noneventCount;
MPRINT(EM_SUMMARIZE_TABLE):   if total ne 0 then do;
MPRINT(EM_SUMMARIZE_TABLE):   eventRate = eventCount / total;
MPRINT(EM_SUMMARIZE_TABLE):   nonEventRate = nonEventCount / total;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   else do;
MPRINT(EM_SUMMARIZE_TABLE):   eventRate = 0;
MPRINT(EM_SUMMARIZE_TABLE):   nonEventRate = 0;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   output;
MPRINT(EM_SUMMARIZE_TABLE):   end;
MPRINT(EM_SUMMARIZE_TABLE):   valfmt = format;
MPRINT(EM_SUMMARIZE_TABLE):   drop _temp Frequency percent;
MPRINT(EM_SUMMARIZE_TABLE):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      375:126   
NOTE: Missing values were generated as a result of performing an operation on missing values.
      Each place is given by: (Number of times) at (Line):(Column).
      1 at 394:122   1 at 403:134   1 at 406:129   
NOTE: There were 110 observations read from the data set WORK.CROSSTABS.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 55 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):  ;
MPRINT(EM_FINE_DETAIL):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   length display_var $32 newgroup numsplitval 8;
MPRINT(EM_FINE_DETAIL):   set EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   display_var = _variable_;
MPRINT(EM_FINE_DETAIL):   index = kindex(display_var, "BIN_");
MPRINT(EM_FINE_DETAIL):   if index gt 0 then do;
MPRINT(EM_FINE_DETAIL):   display_var = ksubstr(display_var, 5);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   index2 = kindex(display_var, "SV_");
MPRINT(EM_FINE_DETAIL):   if index2 gt 0 then do;
MPRINT(EM_FINE_DETAIL):   display_var = ksubstr(display_var, 4);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if ((_SPLIT_VALUE_ = "") or (_SPLIT_VALUE_ = " ") or (_SPLIT_VALUE_ = ".")) then _SPLIT_VALUE_="MISSING";
MPRINT(EM_FINE_DETAIL):   _index_ = _N_;
MPRINT(EM_FINE_DETAIL):   newgroup = .;
MPRINT(EM_FINE_DETAIL):   drop index index2 ;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Variable numsplitval is uninitialized.
NOTE: There were 55 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 55 observations and 16 variables.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.04 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 55 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 55 observations and 16 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.10 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   data tmpsplitvals;
MPRINT(EM_FINE_DETAIL):   set EMWS1.BINNING_SPLITVALS;
MPRINT(EM_FINE_DETAIL):   _norm_level_ = upcase(_norm_level_);
MPRINT(EM_FINE_DETAIL):   if _split_value_ eq 'Missing' then _split_value_ = 'MISSING';
MPRINT(EM_FINE_DETAIL):   * drop _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 62 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set WORK.TMPSPLITVALS has 62 observations and 7 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=tmpsplitvals out=sortedsplit;
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 62 observations read from the data set WORK.TMPSPLITVALS.
NOTE: The data set WORK.SORTEDSPLIT has 62 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets library=work nolist;
MPRINT(EM_FINE_DETAIL):   delete tmpsplitvals;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.TMPSPLITVALS (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS1.BINNING_BINMAPPINGS out=sortedbin;
MPRINT(EM_FINE_DETAIL):   by BIN_NAME BIN;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 40 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set WORK.SORTEDBIN has 40 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_FINE_DETAIL):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   merge EMWS1.BINNING_FINEDETAILDATA(in=_c) work.sortedsplit(in=_b) work.sortedbin(rename=(BIN_NAME=_variable_ BIN=_split_value_) in=_a);
MPRINT(EM_FINE_DETAIL):   by _variable_ _split_value_;
MPRINT(EM_FINE_DETAIL):   if _a then do;
MPRINT(EM_FINE_DETAIL):   binFlag = 1;
MPRINT(EM_FINE_DETAIL):   VALUE=EM_BIN_LABEL;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   else do;
MPRINT(EM_FINE_DETAIL):   binFlag = 0;
MPRINT(EM_FINE_DETAIL):   *VALUE=strip(display_var)!!"="!!strip(_split_value_);
MPRINT(EM_FINE_DETAIL):   VALUE=strip(_split_value_);
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if ((eventCount=.) or (nonEventCount=.)) then do;
MPRINT(EM_FINE_DETAIL):   eventCount=0;
MPRINT(EM_FINE_DETAIL):   nonEventCount=0;
MPRINT(EM_FINE_DETAIL):   total = 0;
MPRINT(EM_FINE_DETAIL):   eventRate= 0;
MPRINT(EM_FINE_DETAIL):   nonEventRate = 0;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   eventCount = round(eventCount, .001);
MPRINT(EM_FINE_DETAIL):   nonEventCount = round(nonEventCount, .001);
MPRINT(EM_FINE_DETAIL):   total= round(total, .001);
MPRINT(EM_FINE_DETAIL):   eventRate = round(eventRate, .001);
MPRINT(EM_FINE_DETAIL):   nonEventRate = round(nonEventRate, .001);
MPRINT(EM_FINE_DETAIL):   if ((type='N') AND (VERIFY(trim(left(_split_value_)) , '.0123456789')=0) ) then numsplitval = _split_value_;
MPRINT(EM_FINE_DETAIL):   else if ((type='N') AND (valfmt ne "")) then numsplitval = _order_;
MPRINT(EM_FINE_DETAIL):   else numsplitval=.;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "" and _VARIABLE_ = "" then delete;
MPRINT(EM_FINE_DETAIL):   if _a and ^_b then delete;
MPRINT(EM_FINE_DETAIL):   if _c and ^_b then delete;
MPRINT(EM_FINE_DETAIL):   drop NAME EM_BIN_LABEL valfmt;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Character values have been converted to numeric values at the places given by: (Line):(Column).
      321:70   
NOTE: Variable _order_ is uninitialized.
NOTE: There were 55 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: There were 62 observations read from the data set WORK.SORTEDSPLIT.
NOTE: There were 40 observations read from the data set WORK.SORTEDBIN.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 62 observations and 24 variables.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):   data EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   set EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "INDELINQ" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "INDEROG" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "JOB" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="NOMINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_CLAGE" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_CLNO" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_DEBTINC" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_DELINQ" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_DEROG" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_LOAN" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_MORTDUE" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_VALUE" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "LOG_YOJ" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "NINQ" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="ORDINAL";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if DISPLAY_VAR = "REASON" then do;
MPRINT(EM_FINE_DETAIL):   if _LEVEL_ = "" then _LEVEL_ ="BINARY";
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then _GROUP_ = 1;
MPRINT(EM_FINE_DETAIL):   end;
MPRINT(EM_FINE_DETAIL):   if _GROUP_ = . then delete;
MPRINT(EM_FINE_DETAIL):   * if binFlag=1 and UB=LB then delete;
MPRINT(EM_FINE_DETAIL):   * if upcase(_SPLIT_VALUE_) ne "MISSING" and _index_ eq . then delete;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 62 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 62 observations and 24 variables.
NOTE: DATA statement used (Total process time):
      real time           0.14 seconds
      cpu time            0.06 seconds
      

MPRINT(EM_FINE_DETAIL):   proc sort data=EMWS1.BINNING_FINEDETAILDATA;
MPRINT(EM_FINE_DETAIL):   by DISPLAY_VAR _index_;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: There were 62 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set EMWS1.BINNING_FINEDETAILDATA has 62 observations and 24 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.12 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_FINE_DETAIL):   proc datasets lib=work nolist;
MPRINT(EM_FINE_DETAIL):   delete sortedsplit sortedbin ;
MPRINT(EM_FINE_DETAIL):   run;

NOTE: Deleting WORK.SORTEDSPLIT (memtype=DATA).
NOTE: Deleting WORK.SORTEDBIN (memtype=DATA).
MPRINT(EM_FINE_DETAIL):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_CREATE_GROUPING):   proc freq data=EMWS1.BINNING_BINDATA noprint;
MPRINT(EM_CREATE_GROUPING):   table BAD / missing out=temptargetC;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 2382 observations read from the data set EMWS1.BINNING_BINDATA.
NOTE: The data set WORK.TEMPTARGETC has 2 observations and 3 variables.
NOTE: PROCEDURE FREQ used (Total process time):
      real time           0.04 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc datasets lib=work nolist;
MPRINT(EM_CREATE_GROUPING):   delete temptargetC;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Deleting WORK.TEMPTARGETC (memtype=DATA).
MPRINT(EM_CREATE_GROUPING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc means data=EMWS1.BINNING_FINEDETAILDATA noprint;
MPRINT(EM_CREATE_GROUPING):   var eventCount nonEventCount;
MPRINT(EM_CREATE_GROUPING):   class _variable_ _group_;
MPRINT(EM_CREATE_GROUPING):   output out=summ(where=(_type_ in(2,3))) sum=eventCount nonEventCount;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 62 observations read from the data set EMWS1.BINNING_FINEDETAILDATA.
NOTE: The data set WORK.SUMM has 76 observations and 6 variables.
NOTE: PROCEDURE MEANS used (Total process time):
      real time           0.04 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=summ(drop=_type_ _freq_);
MPRINT(EM_CREATE_GROUPING):   by _variable_ _group_;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 76 observations read from the data set WORK.SUMM.
NOTE: The data set WORK.SUMM has 76 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   data gini(keep=_variable_ eventCount nonEventCount groupresprate) tempcoarse(keep=_variable_ _group_ eventCount nonEventCount groupresprate groupNonRespRate eventRate nonEventRate respper nrespper);
MPRINT(EM_CREATE_GROUPING):   set summ;
MPRINT(EM_CREATE_GROUPING):   *format groupresprate 6.2;
MPRINT(EM_CREATE_GROUPING):   *format groupnonresprate 6.2;
MPRINT(EM_CREATE_GROUPING):   by _variable_ ;
MPRINT(EM_CREATE_GROUPING):   if _group_=. then do;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   else do;
MPRINT(EM_CREATE_GROUPING):   respper = eventCount / 475;
MPRINT(EM_CREATE_GROUPING):   nrespper = nonEventCount / 1907;
MPRINT(EM_CREATE_GROUPING):   if ((nonEventCount = 0) AND (eventCount = 0)) then do;
MPRINT(EM_CREATE_GROUPING):   groupresprate=0;
MPRINT(EM_CREATE_GROUPING):   groupNonresprate = 0;
MPRINT(EM_CREATE_GROUPING):   eventRate = 0;
MPRINT(EM_CREATE_GROUPING):   nonEventRate = 0;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   else do;
MPRINT(EM_CREATE_GROUPING):   groupresprate = eventCount / (eventCount + nonEventCount) ;
MPRINT(EM_CREATE_GROUPING):   groupNonRespRate = 1 - groupRespRate;
MPRINT(EM_CREATE_GROUPING):   eventRate = eventCount / 475 ;
MPRINT(EM_CREATE_GROUPING):   nonEventRate = nonEventCount / 1907 ;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   output gini tempcoarse;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 76 observations read from the data set WORK.SUMM.
NOTE: The data set WORK.GINI has 62 observations and 4 variables.
NOTE: The data set WORK.TEMPCOARSE has 62 observations and 10 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=gini;
MPRINT(EM_CREATE_GROUPING):   by _variable_ descending groupresprate;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 62 observations read from the data set WORK.GINI.
NOTE: The data set WORK.GINI has 62 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CREATE_GROUPING):   data gini(keep= _variable_ _gini_);
MPRINT(EM_CREATE_GROUPING):   retain between within cumresp cumnresp;
MPRINT(EM_CREATE_GROUPING):   set gini(keep=_variable_ eventCount nonEventCount);
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   if first._variable_ then do;
MPRINT(EM_CREATE_GROUPING):   between = 0;
MPRINT(EM_CREATE_GROUPING):   within = 0;
MPRINT(EM_CREATE_GROUPING):   cumresp = 0;
MPRINT(EM_CREATE_GROUPING):   cumnresp = 0;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   between + 2 * cumnresp * eventCount;
MPRINT(EM_CREATE_GROUPING):   within + nonEventCount * eventCount;
MPRINT(EM_CREATE_GROUPING):   cumresp + eventCount;
MPRINT(EM_CREATE_GROUPING):   cumnresp + nonEventCount;
MPRINT(EM_CREATE_GROUPING):   if last._variable_ then do;
MPRINT(EM_CREATE_GROUPING):   if ^(cumnresp=0 or cumresp=0) then do;
MPRINT(EM_CREATE_GROUPING):   _gini_ = 100 * (1 - (within + between) / (cumnresp * cumresp));
MPRINT(EM_CREATE_GROUPING):   output;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   end;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 62 observations read from the data set WORK.GINI.
NOTE: The data set WORK.GINI has 14 observations and 2 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CREATE_GROUPING):   data tempdisplayvar;
MPRINT(EM_CREATE_GROUPING):   set EMWS1.BINNING_VARMAPPINGS;
MPRINT(EM_CREATE_GROUPING):   rename _variable_ = display_var _proc_var_ = _variable_;
MPRINT(EM_CREATE_GROUPING):   keep _variable_ _proc_var_ label;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 14 observations read from the data set EMWS1.BINNING_VARMAPPINGS.
NOTE: The data set WORK.TEMPDISPLAYVAR has 14 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc sort data=tempdisplayvar;
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: There were 14 observations read from the data set WORK.TEMPDISPLAYVAR.
NOTE: The data set WORK.TEMPDISPLAYVAR has 14 observations and 3 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_CREATE_GROUPING):   data EMWS1.BINNING_COARSE;
MPRINT(EM_CREATE_GROUPING):   length display_Var $32 label _label_ $200 role $10 _group_ 8;
MPRINT(EM_CREATE_GROUPING):   merge tempdisplayvar tempcoarse gini ;
MPRINT(EM_CREATE_GROUPING):   by _variable_;
MPRINT(EM_CREATE_GROUPING):   label display_var = "Variable" eventRate = "Event Rate" nonEventRate = "Non-Event Rate" _group_ = "Group" role = "Role" _gini_ = "Gini Coefficient" eventcount = "Event Count" noneventcount = "Non-Event Count" groupresprate = 
"Group Event Rate" groupnonresprate = "Group Non-Event Rate" ;
MPRINT(EM_CREATE_GROUPING):   eventCount = round(eventCount, .001);
MPRINT(EM_CREATE_GROUPING):   nonEventCount = round(nonEventCount, .001);
MPRINT(EM_CREATE_GROUPING):   groupRespRate = round(groupRespRate, .001);
MPRINT(EM_CREATE_GROUPING):   drop _variable_ index index2 respper nrespper;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Variable _label_ is uninitialized.
NOTE: Variable role is uninitialized.
WARNING: Multiple lengths were specified for the BY variable _variable_ by input data sets. This might cause unexpected results.
WARNING: The variable index in the DROP, KEEP, or RENAME list has never been referenced.
WARNING: The variable index2 in the DROP, KEEP, or RENAME list has never been referenced.
NOTE: There were 14 observations read from the data set WORK.TEMPDISPLAYVAR.
NOTE: There were 62 observations read from the data set WORK.TEMPCOARSE.
NOTE: There were 14 observations read from the data set WORK.GINI.
NOTE: The data set EMWS1.BINNING_COARSE has 62 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.10 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_CREATE_GROUPING):   proc datasets library=work nolist;
MPRINT(EM_CREATE_GROUPING):   delete tempcoarse gini ;
MPRINT(EM_CREATE_GROUPING):   run;

NOTE: Deleting WORK.TEMPCOARSE (memtype=DATA).
NOTE: Deleting WORK.GINI (memtype=DATA).
MPRINT(EM_CREATE_GROUPING):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename Y "J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas";
MPRINT(EM_GENERATE_LABELVALUES):   data _null_;
MPRINT(EM_GENERATE_LABELVALUES):   FILE Y;
MPRINT(EM_GENERATE_LABELVALUES):   put " length _LABEL_ $200;";
MPRINT(EM_GENERATE_LABELVALUES):   put ' label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";';
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: The file Y is:
      Filename=J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=0,
      Last Modified=25Oct2018:23:41:41,
      Create Time=25Oct2018:23:41:41

NOTE: 2 records were written to the file Y.
      The minimum record length was 21.
      The maximum record length was 83.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=EMWS1.BINNING_SPLITVALS out=work.sortedsplitval;
MPRINT(EM_GENERATE_LABELVALUES):   by display_var _split_Value_;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 62 observations read from the data set EMWS1.BINNING_SPLITVALS.
NOTE: The data set WORK.SORTEDSPLITVAL has 62 observations and 7 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=EMWS1.BINNING_BINMAPPINGS;
MPRINT(EM_GENERATE_LABELVALUES):   by display_var bin;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 40 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set EMWS1.BINNING_BINMAPPINGS has 40 observations and 8 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.11 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data temp;
MPRINT(EM_GENERATE_LABELVALUES):   merge work.sortedsplitval(in=_a) EMWS1.BINNING_BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
MPRINT(EM_GENERATE_LABELVALUES):   by Display_Var _Split_value_;
MPRINT(EM_GENERATE_LABELVALUES):   if upcase(_Split_value_) ne 'MISSING';
MPRINT(EM_GENERATE_LABELVALUES):   if _a then output;
MPRINT(EM_GENERATE_LABELVALUES):   if display_var eq '' then delete;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 62 observations read from the data set WORK.SORTEDSPLITVAL.
NOTE: There were 40 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set WORK.TEMP has 48 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data temp_missing;
MPRINT(EM_GENERATE_LABELVALUES):   merge work.sortedsplitval(in=_a rename=(_GROUP_=MISSGRP)) EMWS1.BINNING_BINMAPPINGS(rename=(BIN_NAME=_VARIABLE_ BIN=_SPLIT_VALUE_));
MPRINT(EM_GENERATE_LABELVALUES):   by Display_Var _Split_value_;
MPRINT(EM_GENERATE_LABELVALUES):   if upcase(_Split_value_) eq 'MISSING';
MPRINT(EM_GENERATE_LABELVALUES):   if _a then output;
MPRINT(EM_GENERATE_LABELVALUES):   keep _variable_ display_var missgrp;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 62 observations read from the data set WORK.SORTEDSPLITVAL.
NOTE: There were 40 observations read from the data set EMWS1.BINNING_BINMAPPINGS.
NOTE: The data set WORK.TEMP_MISSING has 14 observations and 3 variables.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc sort data=temp out=class;
MPRINT(EM_GENERATE_LABELVALUES):   by _variable_ _group_ LB;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 48 observations read from the data set WORK.TEMP.
NOTE: The data set WORK.CLASS has 48 observations and 12 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data _null_;
MPRINT(EM_GENERATE_LABELVALUES):   file Y MOD;
MPRINT(EM_GENERATE_LABELVALUES):   length string $200 flag 8;
MPRINT(EM_GENERATE_LABELVALUES):   retain string flag;
MPRINT(EM_GENERATE_LABELVALUES):   set class end=eof;
MPRINT(EM_GENERATE_LABELVALUES):   by _variable_ _group_;
MPRINT(EM_GENERATE_LABELVALUES):   index = kindex(_variable_, "BIN_");
MPRINT(EM_GENERATE_LABELVALUES):   if index gt 0 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if first._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 0;
MPRINT(EM_GENERATE_LABELVALUES):   if ^first._variable_ then put 'else';
MPRINT(EM_GENERATE_LABELVALUES):   else put ' ';
MPRINT(EM_GENERATE_LABELVALUES):   string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = " !!strip(put(_GROUP_,best12.))!!' then do;';
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   if LB ne . then do;
MPRINT(EM_GENERATE_LABELVALUES):   * string = strip(string)!!" _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   string = " _LABEL_='"!!strip(LB)!!"<= "!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 1;
MPRINT(EM_GENERATE_LABELVALUES):   *string = strip(string)!!" _LABEL_='"!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   string = " _LABEL_='"!!strip(DISPLAY_VAR);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if last._Group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   if UB ne . then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!'< '!!strip(UB)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   if flag=1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   string= " UB="!!strip(UB)!!";";
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   put "end;";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _split_value_ = tranwrd(_split_value_,"'","''");
MPRINT(EM_GENERATE_LABELVALUES):   if first._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   flag = 0;
MPRINT(EM_GENERATE_LABELVALUES):   if ^first._variable_ then put 'else';
MPRINT(EM_GENERATE_LABELVALUES):   else put ' ';
MPRINT(EM_GENERATE_LABELVALUES):   string = "if DISPLAY_VAR='"!!strip(DISPLAY_VAR)!!"' and _GROUP_ = " !!strip(put(_GROUP_,best12.))!!' then';
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   string = "_LABEL_='"!!strip(_split_value_);
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   if flag ne 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   tempstring = strip(string)!!', '!!strip(_split_value_);
MPRINT(EM_GENERATE_LABELVALUES):   length = length(tempstring);
MPRINT(EM_GENERATE_LABELVALUES):   if length < 195 then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = tempstring;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)||",...";
MPRINT(EM_GENERATE_LABELVALUES):   flag=1;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if last._group_ then do;
MPRINT(EM_GENERATE_LABELVALUES):   string = strip(string)!!"';";
MPRINT(EM_GENERATE_LABELVALUES):   put string;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: Numeric values have been converted to character values at the places given by: (Line):(Column).
      171:84    206:151   246:25    
NOTE: The file Y is:
      Filename=J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas,
      RECFM=V,LRECL=32767,File Size (bytes)=108,
      Last Modified=25Oct2018:23:41:41,
      Create Time=25Oct2018:23:41:41

NOTE: 224 records were written to the file Y.
      The minimum record length was 1.
      The maximum record length was 53.
NOTE: There were 48 observations read from the data set WORK.CLASS.
NOTE: DATA statement used (Total process time):
      real time           0.03 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   data EMWS1.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   set EMWS1.BINNING_COARSE;
NOTE: %INCLUDE (level 1) file Y is file J:\JMMORR01\CIS 445\Tutorial 2\My Project\Workspaces\EMWS1\BINNING\GROUPMAPPINGSCORECODE.sas.
34861     + length _LABEL_ $200;
MPRINT(EM_GENERATE_LABELVALUES):   length _LABEL_ $200;
34862     + label _LABEL_="%sysfunc(sasmsg(sashelp.dmine, rpt_groupvalues_vlabel , NOQUOTE))";
MPRINT(EM_GENERATE_LABELVALUES):   label _LABEL_= "Group Values";
34863     +
34864     +if DISPLAY_VAR='INDELINQ' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='INDELINQ' and _GROUP_ = 2 then do;
34865     +_LABEL_='INDELINQ< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='INDELINQ< 0';
34866     +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
34867     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34868     +else
34869     +if DISPLAY_VAR='INDELINQ' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='INDELINQ' and _GROUP_ = 3 then do;
34870     +_LABEL_='0<= INDELINQ';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= INDELINQ';
34871     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
34872     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34873     +
34874     +if DISPLAY_VAR='INDEROG' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='INDEROG' and _GROUP_ = 2 then do;
34875     +_LABEL_='INDEROG< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='INDEROG< 0';
34876     +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
34877     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34878     +else
34879     +if DISPLAY_VAR='INDEROG' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='INDEROG' and _GROUP_ = 3 then do;
34880     +_LABEL_='0<= INDEROG';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= INDEROG';
34881     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
34882     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34883     +
34884     +if DISPLAY_VAR='LOG_CLAGE' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_CLAGE' and _GROUP_ = 2 then do;
34885     +_LABEL_='LOG_CLAGE< 4.77';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_CLAGE< 4.77';
34886     +UB=4.77;
MPRINT(EM_GENERATE_LABELVALUES):   UB=4.77;
34887     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34888     +else
34889     +if DISPLAY_VAR='LOG_CLAGE' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_CLAGE' and _GROUP_ = 3 then do;
34890     +_LABEL_='4.77<= LOG_CLAGE< 5.17';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='4.77<= LOG_CLAGE< 5.17';
34891     +UB=5.17;
MPRINT(EM_GENERATE_LABELVALUES):   UB=5.17;
34892     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34893     +else
34894     +if DISPLAY_VAR='LOG_CLAGE' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_CLAGE' and _GROUP_ = 4 then do;
34895     +_LABEL_='5.17<= LOG_CLAGE< 5.46';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='5.17<= LOG_CLAGE< 5.46';
34896     +UB=5.46;
MPRINT(EM_GENERATE_LABELVALUES):   UB=5.46;
34897     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34898     +else
34899     +if DISPLAY_VAR='LOG_CLAGE' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_CLAGE' and _GROUP_ = 5 then do;
34900     +_LABEL_='5.46<= LOG_CLAGE';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='5.46<= LOG_CLAGE';
34901     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
34902     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34903     +
34904     +if DISPLAY_VAR='LOG_CLNO' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_CLNO' and _GROUP_ = 2 then do;
34905     +_LABEL_='LOG_CLNO< 2.71';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_CLNO< 2.71';
34906     +UB=2.71;
MPRINT(EM_GENERATE_LABELVALUES):   UB=2.71;
34907     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34908     +else
34909     +if DISPLAY_VAR='LOG_CLNO' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_CLNO' and _GROUP_ = 3 then do;
34910     +_LABEL_='2.71<= LOG_CLNO< 3.04';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='2.71<= LOG_CLNO< 3.04';
34911     +UB=3.04;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3.04;
34912     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34913     +else
34914     +if DISPLAY_VAR='LOG_CLNO' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_CLNO' and _GROUP_ = 4 then do;
34915     +_LABEL_='3.04<= LOG_CLNO< 3.3';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3.04<= LOG_CLNO< 3.3';
34916     +UB=3.3;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3.3;
34917     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34918     +else
34919     +if DISPLAY_VAR='LOG_CLNO' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_CLNO' and _GROUP_ = 5 then do;
34920     +_LABEL_='3.3<= LOG_CLNO';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3.3<= LOG_CLNO';
34921     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
34922     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34923     +
34924     +if DISPLAY_VAR='LOG_DEBTINC' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_DEBTINC' and _GROUP_ = 2 then do;
34925     +_LABEL_='LOG_DEBTINC< 3.4';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_DEBTINC< 3.4';
34926     +UB=3.4;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3.4;
34927     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34928     +else
34929     +if DISPLAY_VAR='LOG_DEBTINC' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_DEBTINC' and _GROUP_ = 3 then do;
34930     +_LABEL_='3.4<= LOG_DEBTINC< 3.58';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3.4<= LOG_DEBTINC< 3.58';
34931     +UB=3.58;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3.58;
34932     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34933     +else
34934     +if DISPLAY_VAR='LOG_DEBTINC' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_DEBTINC' and _GROUP_ = 4 then do;
34935     +_LABEL_='3.58<= LOG_DEBTINC< 3.69';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3.58<= LOG_DEBTINC< 3.69';
34936     +UB=3.69;
MPRINT(EM_GENERATE_LABELVALUES):   UB=3.69;
34937     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34938     +else
34939     +if DISPLAY_VAR='LOG_DEBTINC' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_DEBTINC' and _GROUP_ = 5 then do;
34940     +_LABEL_='3.69<= LOG_DEBTINC';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='3.69<= LOG_DEBTINC';
34941     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
34942     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34943     +
34944     +if DISPLAY_VAR='LOG_DELINQ' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_DELINQ' and _GROUP_ = 2 then do;
34945     +_LABEL_='LOG_DELINQ< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_DELINQ< 0';
34946     +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
34947     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34948     +else
34949     +if DISPLAY_VAR='LOG_DELINQ' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_DELINQ' and _GROUP_ = 3 then do;
34950     +_LABEL_='0<= LOG_DELINQ';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= LOG_DELINQ';
34951     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
34952     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34953     +
34954     +if DISPLAY_VAR='LOG_DEROG' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_DEROG' and _GROUP_ = 2 then do;
34955     +_LABEL_='LOG_DEROG< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_DEROG< 0';
34956     +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
34957     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34958     +else
34959     +if DISPLAY_VAR='LOG_DEROG' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_DEROG' and _GROUP_ = 3 then do;
34960     +_LABEL_='0<= LOG_DEROG';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= LOG_DEROG';
34961     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
34962     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34963     +
34964     +if DISPLAY_VAR='LOG_LOAN' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_LOAN' and _GROUP_ = 2 then do;
34965     +_LABEL_='LOG_LOAN< 9.32';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_LOAN< 9.32';
34966     +UB=9.32;
MPRINT(EM_GENERATE_LABELVALUES):   UB=9.32;
34967     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34968     +else
34969     +if DISPLAY_VAR='LOG_LOAN' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_LOAN' and _GROUP_ = 3 then do;
34970     +_LABEL_='9.32<= LOG_LOAN< 9.7';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='9.32<= LOG_LOAN< 9.7';
34971     +UB=9.7;
MPRINT(EM_GENERATE_LABELVALUES):   UB=9.7;
34972     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34973     +else
34974     +if DISPLAY_VAR='LOG_LOAN' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_LOAN' and _GROUP_ = 4 then do;
34975     +_LABEL_='9.7<= LOG_LOAN< 10.06';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='9.7<= LOG_LOAN< 10.06';
34976     +UB=10.06;
MPRINT(EM_GENERATE_LABELVALUES):   UB=10.06;
34977     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34978     +else
34979     +if DISPLAY_VAR='LOG_LOAN' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_LOAN' and _GROUP_ = 5 then do;
34980     +_LABEL_='10.06<= LOG_LOAN';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='10.06<= LOG_LOAN';
34981     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
34982     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34983     +
34984     +if DISPLAY_VAR='LOG_MORTDUE' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_MORTDUE' and _GROUP_ = 2 then do;
34985     +_LABEL_='LOG_MORTDUE< 10.74';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_MORTDUE< 10.74';
34986     +UB=10.74;
MPRINT(EM_GENERATE_LABELVALUES):   UB=10.74;
34987     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34988     +else
34989     +if DISPLAY_VAR='LOG_MORTDUE' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_MORTDUE' and _GROUP_ = 3 then do;
34990     +_LABEL_='10.74<= LOG_MORTDUE< 11.07';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='10.74<= LOG_MORTDUE< 11.07';
34991     +UB=11.07;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11.07;
34992     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34993     +else
34994     +if DISPLAY_VAR='LOG_MORTDUE' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_MORTDUE' and _GROUP_ = 4 then do;
34995     +_LABEL_='11.07<= LOG_MORTDUE< 11.44';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11.07<= LOG_MORTDUE< 11.44';
34996     +UB=11.44;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11.44;
34997     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
34998     +else
34999     +if DISPLAY_VAR='LOG_MORTDUE' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_MORTDUE' and _GROUP_ = 5 then do;
35000     +_LABEL_='11.44<= LOG_MORTDUE';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11.44<= LOG_MORTDUE';
35001     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
35002     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
35003     +
35004     +if DISPLAY_VAR='LOG_VALUE' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_VALUE' and _GROUP_ = 2 then do;
35005     +_LABEL_='LOG_VALUE< 11.1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_VALUE< 11.1';
35006     +UB=11.1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11.1;
35007     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
35008     +else
35009     +if DISPLAY_VAR='LOG_VALUE' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_VALUE' and _GROUP_ = 3 then do;
35010     +_LABEL_='11.1<= LOG_VALUE< 11.4';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11.1<= LOG_VALUE< 11.4';
35011     +UB=11.4;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11.4;
35012     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
35013     +else
35014     +if DISPLAY_VAR='LOG_VALUE' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_VALUE' and _GROUP_ = 4 then do;
35015     +_LABEL_='11.4<= LOG_VALUE< 11.71';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11.4<= LOG_VALUE< 11.71';
35016     +UB=11.71;
MPRINT(EM_GENERATE_LABELVALUES):   UB=11.71;
35017     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
35018     +else
35019     +if DISPLAY_VAR='LOG_VALUE' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_VALUE' and _GROUP_ = 5 then do;
35020     +_LABEL_='11.71<= LOG_VALUE';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='11.71<= LOG_VALUE';
35021     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
35022     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
35023     +
35024     +if DISPLAY_VAR='LOG_YOJ' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='LOG_YOJ' and _GROUP_ = 2 then do;
35025     +_LABEL_='LOG_YOJ< 1.39';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='LOG_YOJ< 1.39';
35026     +UB=1.39;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1.39;
35027     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
35028     +else
35029     +if DISPLAY_VAR='LOG_YOJ' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_YOJ' and _GROUP_ = 3 then do;
35030     +_LABEL_='1.39<= LOG_YOJ< 2.08';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1.39<= LOG_YOJ< 2.08';
35031     +UB=2.08;
MPRINT(EM_GENERATE_LABELVALUES):   UB=2.08;
35032     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
35033     +else
35034     +if DISPLAY_VAR='LOG_YOJ' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_YOJ' and _GROUP_ = 4 then do;
35035     +_LABEL_='2.08<= LOG_YOJ< 2.64';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='2.08<= LOG_YOJ< 2.64';
35036     +UB=2.64;
MPRINT(EM_GENERATE_LABELVALUES):   UB=2.64;
35037     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
35038     +else
35039     +if DISPLAY_VAR='LOG_YOJ' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='LOG_YOJ' and _GROUP_ = 5 then do;
35040     +_LABEL_='2.64<= LOG_YOJ';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='2.64<= LOG_YOJ';
35041     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
35042     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
35043     +
35044     +if DISPLAY_VAR='NINQ' and _GROUP_ = 2 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='NINQ' and _GROUP_ = 2 then do;
35045     +_LABEL_='NINQ< 0';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='NINQ< 0';
35046     +UB=0;
MPRINT(EM_GENERATE_LABELVALUES):   UB=0;
35047     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
35048     +else
35049     +if DISPLAY_VAR='NINQ' and _GROUP_ = 3 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='NINQ' and _GROUP_ = 3 then do;
35050     +_LABEL_='0<= NINQ< 1';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='0<= NINQ< 1';
35051     +UB=1;
MPRINT(EM_GENERATE_LABELVALUES):   UB=1;
35052     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
35053     +else
35054     +if DISPLAY_VAR='NINQ' and _GROUP_ = 4 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='NINQ' and _GROUP_ = 4 then do;
35055     +_LABEL_='1<= NINQ< 2';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='1<= NINQ< 2';
35056     +UB=2;
MPRINT(EM_GENERATE_LABELVALUES):   UB=2;
35057     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
35058     +else
35059     +if DISPLAY_VAR='NINQ' and _GROUP_ = 5 then do;
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='NINQ' and _GROUP_ = 5 then do;
35060     +_LABEL_='2<= NINQ';
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_='2<= NINQ';
35061     +UB=.;
MPRINT(EM_GENERATE_LABELVALUES):   UB=.;
35062     +end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
35063     +
35064     +if DISPLAY_VAR='JOB' and _GROUP_ = 2 then
35065     +_LABEL_='OTHER';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='JOB' and _GROUP_ = 2 then _LABEL_='OTHER';
35066     +else
35067     +if DISPLAY_VAR='JOB' and _GROUP_ = 3 then
35068     +_LABEL_='PROFEXE';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='JOB' and _GROUP_ = 3 then _LABEL_='PROFEXE';
35069     +else
35070     +if DISPLAY_VAR='JOB' and _GROUP_ = 4 then
35071     +_LABEL_='OFFICE';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='JOB' and _GROUP_ = 4 then _LABEL_='OFFICE';
35072     +else
35073     +if DISPLAY_VAR='JOB' and _GROUP_ = 5 then
35074     +_LABEL_='MGR';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='JOB' and _GROUP_ = 5 then _LABEL_='MGR';
35075     +else
35076     +if DISPLAY_VAR='JOB' and _GROUP_ = 6 then
35077     +_LABEL_='SELF';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='JOB' and _GROUP_ = 6 then _LABEL_='SELF';
35078     +else
35079     +if DISPLAY_VAR='JOB' and _GROUP_ = 7 then
35080     +_LABEL_='SALES';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='JOB' and _GROUP_ = 7 then _LABEL_='SALES';
35081     +
35082     +if DISPLAY_VAR='REASON' and _GROUP_ = 2 then
35083     +_LABEL_='DEBTCON';
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR='REASON' and _GROUP_ = 2 then _LABEL_='DEBTCON';
35084     +else
35085     +if DISPLAY_VAR='REASON' and _GROUP_ = 3 then
35086     +_LABEL_='HOMEIMP';
MPRINT(EM_GENERATE_LABELVALUES):   else if DISPLAY_VAR='REASON' and _GROUP_ = 3 then _LABEL_='HOMEIMP';
NOTE: %INCLUDE (level 1) ending.
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 62 observations read from the data set EMWS1.BINNING_COARSE.
NOTE: The data set EMWS1.BINNING_COARSE has 62 observations and 13 variables.
NOTE: DATA statement used (Total process time):
      real time           0.12 seconds
      cpu time            0.03 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   *filename Y;
MPRINT(EM_GENERATE_LABELVALUES):   data EMWS1.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   set EMWS1.BINNING_COARSE;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "INDELINQ" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "INDEROG" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "JOB" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_CLAGE" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_CLNO" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_DEBTINC" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_DELINQ" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_DEROG" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_LOAN" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_MORTDUE" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_VALUE" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "LOG_YOJ" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "NINQ" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   if DISPLAY_VAR = "REASON" and _GROUP_ = 1 then do;
MPRINT(EM_GENERATE_LABELVALUES):   if _LABEL_ eq '' then do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = "Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   else do;
MPRINT(EM_GENERATE_LABELVALUES):   _LABEL_ = strip(_LABEL_)!!", Missing";
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   end;
MPRINT(EM_GENERATE_LABELVALUES):   drop ub;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: There were 62 observations read from the data set EMWS1.BINNING_COARSE.
NOTE: The data set EMWS1.BINNING_COARSE has 62 observations and 12 variables.
NOTE: DATA statement used (Total process time):
      real time           0.15 seconds
      cpu time            0.01 seconds
      

MPRINT(EM_GENERATE_LABELVALUES):   proc datasets library=work nolist;
MPRINT(EM_GENERATE_LABELVALUES):   delete class temp temp_missing;
MPRINT(EM_GENERATE_LABELVALUES):   run;

NOTE: Deleting WORK.CLASS (memtype=DATA).
NOTE: Deleting WORK.TEMP (memtype=DATA).
NOTE: Deleting WORK.TEMP_MISSING (memtype=DATA).
MPRINT(EM_GENERATE_LABELVALUES):   quit;

NOTE: PROCEDURE DATASETS used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(TRAIN):   filename Y;
NOTE: Fileref Y has been deassigned.
MPRINT(EM_MODEL):   data WORK.EM_USER_MODEL;
MPRINT(EM_MODEL):   length DATA $65 TARGET $32 PREDICTED ASSESS DECSCORECODE FITSTATISTICS CLASSIFICATION RESIDUALS $1;
MPRINT(EM_MODEL):   data = "";
MPRINT(EM_MODEL):   target = "BAD";
MPRINT(EM_MODEL):   predicted = "Y";
MPRINT(EM_MODEL):   assess = "N";
MPRINT(EM_MODEL):   decscorecode = "N";
MPRINT(EM_MODEL):   fitstatistics = "N";
MPRINT(EM_MODEL):   classification = "N";
MPRINT(EM_MODEL):   residuals = "N";
MPRINT(EM_MODEL):   run;

NOTE: The data set WORK.EM_USER_MODEL has 1 observations and 8 variables.
NOTE: DATA statement used (Total process time):
      real time           0.01 seconds
      cpu time            0.01 seconds
      

MPRINT(TRAIN):  ;
MPRINT(EM_REPORT):   data WORK.EM_USER_REPORT;
MPRINT(EM_REPORT):   retain id 0;
MPRINT(EM_REPORT):   id + 1;
MPRINT(EM_REPORT):   length VIEW 8 NAME $32 VALUE $400;
MPRINT(EM_REPORT):   NAME = "KEY";
MPRINT(EM_REPORT):   VALUE = "COARSE";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWTYPE";
MPRINT(EM_REPORT):   VALUE = "DATA";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AUTODISPLAY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SPK";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COMPARE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOCALIZE";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZEROWY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLX";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EQUALIZECOLY";
MPRINT(EM_REPORT):   VALUE = "N";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NROWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NCOLS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISCRETEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LATTICETYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABSOLUTEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SORTORDERY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ORIENTATION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DIRECTION";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BYSET";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RENDERMODE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCRIPTION";
MPRINT(EM_REPORT):   VALUE = "EVENTRATESTAT";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "X";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "EXCLUDEVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Z";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQVARS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "AXIS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQ";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SUBGROUP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BLOCK";
MPRINT(EM_REPORT):   VALUE = "MODEL";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "COLORINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIPTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TOOLTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "REPORTID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "IDVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "VIEWS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "PARENT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "ABOVETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "BELOWTEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESIZE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "STATS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CLASSDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "INTDIST";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FOLDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YPLOTTYPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YREF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2REF2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "GROUPINDEX";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "JOIN";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "FREQEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YEXCLUDE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NAME";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "HEIGHT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "WIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2AXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YAXISLABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYXLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DISPLAYYLABEL";
MPRINT(EM_REPORT):   VALUE = "Y";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "CHOICETEXT";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SEGMENTVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LOWERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "UPPERBAND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YLINE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEKEY";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODEVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODECOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODESHAPEVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODELABEL";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NODETIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKID";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKVALUE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKCOLOR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKWIDTH";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LINKTIP";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "XTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YFROM";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "YTO";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MATRIXVAR";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "RESPONSE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SERIES";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "DESCARG";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SLIDER";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "MarkerSize";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Marker";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y1";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y2";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y3";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y4";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y5";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y6";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y7";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y8";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y9";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y10";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y11";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y12";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y13";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y14";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y15";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "Y16";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "TITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGEND";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "LEGENDTITLE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "SHAPE";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "METHOD";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   NAME = "NOBINMISS";
MPRINT(EM_REPORT):   VALUE = "";
MPRINT(EM_REPORT):   VIEW = 0.33510234408783;
MPRINT(EM_REPORT):   output;
MPRINT(EM_REPORT):   run;

NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: DATA statement used (Total process time):
      real time           0.04 seconds
      cpu time            0.03 seconds
      

MPRINT(TRAIN):  ;
MPRINT(MAIN):  ;
MPRINT(EM_DIAGRAM):  ;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   * End TRAIN: BINNING;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
35087      *------------------------------------------------------------*;
35088      * End TRAIN: BINNING;
35089      *------------------------------------------------------------*;
35090      

35091      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):    *------------------------------------------------------------*;
35092      * Close any missing semi colons;
MPRINT(EM_DIAGRAM):   * Close any missing semi colons;
35093      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
35094      ;
MPRINT(EM_DIAGRAM):   ;
35095      ;
MPRINT(EM_DIAGRAM):   ;
35096      ;
MPRINT(EM_DIAGRAM):   ;
35097      ;
MPRINT(EM_DIAGRAM):   ;
35098      quit;
MPRINT(EM_DIAGRAM):   quit;
35099      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
35100      * Close any unbalanced quotes;
MPRINT(EM_DIAGRAM):   * Close any unbalanced quotes;
35101      *------------------------------------------------------------*;
MPRINT(EM_DIAGRAM):   *------------------------------------------------------------*;
35102      /*; *"; *'; */
35103      ;
MPRINT(EM_DIAGRAM):   ;
35104      run;
MPRINT(EM_DIAGRAM):   run;
35105      quit;
MPRINT(EM_DIAGRAM):   quit;
35106      /* Reset EM Options */
35107      options formchar="|----|+|---+=|-/\<>*";
MPRINT(EM_DIAGRAM):   options formchar="|----|+|---+=|-/\<>*";
35108      options nocenter ls=256 ps=10000;
MPRINT(EM_DIAGRAM):   options nocenter ls=256 ps=10000;
35109      goptions reset=all device=GIF NODISPLAY;
MPRINT(EM_DIAGRAM):   goptions reset=all device=GIF NODISPLAY;
35110      proc sort data=WORK.EM_USER_REPORT;
MPRINT(EM_DIAGRAM):    proc sort data=WORK.EM_USER_REPORT;
35111      by ID VIEW;
MPRINT(EM_DIAGRAM):   by ID VIEW;
35112      run;
MPRINT(EM_DIAGRAM):   run;

NOTE: There were 132 observations read from the data set WORK.EM_USER_REPORT.
NOTE: The data set WORK.EM_USER_REPORT has 132 observations and 4 variables.
NOTE: PROCEDURE SORT used (Total process time):
      real time           0.01 seconds
      cpu time            0.00 seconds
      

MPRINT(EM_DIAGRAM):    proc printto;
MPRINT(EM_DIAGRAM):   run;
